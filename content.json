{"posts":[{"title":"OO第一单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 前言复杂度分析使用IDEA的 MetricsReloaded插件 代码规模分析利用IDEA的 static插件 UML类图使用IDEA绘图，再自行调整 任务概览作业要求 作业1：根据形式化定义解析输入的表达式，输出恒等变形展开括号后的表达式。 作业2：形式化定义加入指数函数和自定义函数。 作业3：支持自定义函数嵌套并加入求导算子。 第一次作业第一次作业为对包含幂函数与常数的表达式进行化简，涉及相对简单的嵌套，UML类图如下所示。 架构分析通过分析 Expr与 Term的结构。我们不难发现，一个基本的 Expr可以看成又一个个基元构成，即 $$Expr = \\sum a \\times x ^ b$$ 数据存储上，依照形式化表达设计为 Expr-&gt;Term-&gt;Factor。Parser和 Lexer作为工具类，分别承担句法分析和词法分析的功能。 值得注意的是，架构中事实上没有区分 Num和 Power，而是将其统一为 Unit类，存储一个形如$a \\times x ^ b$的因子。 在读取和存储过程中，Parser和 Lexer合作，构建了一棵多叉表达式树。 Factor接口为因子类的公共接口，所有的因子都实现了这个接口，所有的非 Unit类通过 Poly，即多项式类进行运算，最后通过 Poly类调用 Unit类的 toString方法实现输出。 下图展示了这种读取和存储的过程的一个例子： 具体而言，获得答案的计算过程是和读取解析相解耦合的。在调用顶层 Expr对象的 extend()方法后，逐层向下调用 extend()方法，得到展开式。这其中，得益于 Unit类的统一性，每一层向上返回的都是一个 Unit对象的集合，达到了形式上和接口的统一。 复杂度分析本次作业部分方法复杂度如下图，其余方法复杂度较低，未在图中体现。 可以看到，Parser中的 parseFactor()方法复杂度较高，分析原因知，设计该方法时对于常数和幂函数的解析都全部列在其中，没有分别抽象为分别的方法；Unit中的 toString()方法复杂度较高，为了优化输出的长度导致特判较多，复杂度较高。 Method CogC ev(G) iv(G) v(G) Parser.parseFactor() 14 1 8 8 Parser.parseExpr() 8 1 6 6 expr.Unit.toString() 7 1 6 7 Lexer.next() 6 2 4 6 expr.Expr.extend() 6 2 6 6 expr.Poly.toString() 5 4 3 5 expr.Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 expr.Poly.multiUnit(Unit) 4 1 3 3 expr.Poly.Merge() 3 1 3 3 expr.Poly.adjustUnit() 3 3 2 3 expr.Poly.multiExpr(Poly) 3 1 3 3 Lexer.getNumber() 2 1 3 3 Parser.getExp() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 expr.Poly.Negate() 1 1 2 2 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Main.main(String[]) 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 expr.Expr.Negate() 0 1 1 1 expr.Expr.addTerm(Term) 0 1 1 1 expr.Expr.equals(Expr) 0 1 1 1 expr.Expr.setExp(BigInteger) 0 1 1 1 expr.Poly.Poly() 0 1 1 1 expr.Poly.add(Poly) 0 1 1 1 expr.Poly.createOne() 0 1 1 1 expr.Poly.unitMulti(Unit, Unit) 0 1 1 1 expr.Term.Negate() 0 1 1 1 expr.Term.addFactor(Factor) 0 1 1 1 expr.Unit.Negate() 0 1 1 1 expr.Unit.Unit(BigInteger) 0 1 1 1 expr.Unit.Unit(Type) 0 1 1 1 expr.Unit.canMerge(Unit) 0 1 1 1 expr.Unit.compareTo(Unit) 0 1 1 1 expr.Unit.getCoff() 0 1 1 1 expr.Unit.getExp() 0 1 1 1 expr.Unit.getType() 0 1 1 1 expr.Unit.merge(Unit) 0 1 1 1 expr.Unit.multiUnit(Unit) 0 1 1 1 expr.Unit.setCoff(BigInteger) 0 1 1 1 expr.Unit.setExp(BigInteger) 0 1 1 1 Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是没有处理$0$的输出；另一个是没有妥善处理表达式里的 \\t和空格。 同时，我在此次作业中设计并实现了一个自动化评测机，这对检验程序的正确性有不小的帮助，也帮助我实现了hack，详细的分析将在评测部分介绍。 总结“工欲善其事，必先利其器” 在写本次作业之初，我设计过很多架构，在设计阶段就推倒重来若干次。尽管在Pre中的冒险者游戏中已经我初步领会了面向对象的思想，但是面对较为抽象的表达式解析仍然显得捉襟见肘。 尽管如此，得益于 training部分提供的 Parser和 Lexer思路，我最终得以确定这个较为面向对象的设计。但是，这个架构依然存在相当的不足，在后面的迭代开发介绍中将会着重介绍。 第二次作业相比于第一次作业，第二次作业新增了自定义函数与指数函数相关的内容，同时支持嵌套括号的解析。 相比第一次作业，增加了 Func类处理自定义函数，同时增加了 Exp类处理指数函数，UML类图如下： 架构分析相较于上一次作业以及未来的第三次作业，本次作业的工作量无疑是最大的，也难怪纪一鹏老师说这次作业很有可能会是本学期OO的难度巅峰。 对于本次作业的两个新增要求，我先完成了自定义函数的实现，再完成了指数函数的部分。 自定义函数部分自定义函数分为两个部分，一是读入，二是调用。 有关读入，由于函数定义式依然符合我们的多项式语意，且定义式内不允许循环定义，故而直接沿用上一次的 Lexer和 Parser来解析。 有关调用，我在读入表达式时，就建立了参数与实参的Map，在解析时利用Map中的Map.Entry接口进行替换，效果不错，但是相较正则表达式替换的方法，虽然正确性上有保障，但是时间复杂度较高。 指数函数部分通过分析本次式子可知，本次基元有所更新 $$Expr = \\sum a \\times x ^ b \\times exp(Factor) ^ c$$ 由于指数函数的特殊性，故我直接在初始化指数函数时直接将基元变形成如下式子，便于后续计算： $$Expr = \\sum a \\times x ^ b \\times exp(Factor \\times c)$$ 同样，我利用Poly类的 toString方法和String类的equals方法判断exp内的Factor是否相等，来进行后续合并。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 19 1 12 12 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Unit.setExp(BigInteger) 10 1 4 8 Lexer.next() 9 2 5 7 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Poly.unitMulti(Unit, Unit) 4 1 5 5 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Poly.adjustUnit() 3 3 2 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Main.main(String[]) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.clone() 0 1 1 1 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 可以看出，本次架构在Term类中实现自定义函数的替换部分的 replace方法复杂度极高，在Debug过程中，也同样是这个方法耗去了我大量的时间，可见越复杂，越易错！！！ Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是对于exp的括号化简出错；另一个是自定义函数中exp函数替换出错。 在本次hack过程中，我着重查看了同屋同学代码架构的复杂程度进行了分析，对于明显架构复杂的代码进行hack，都得到了成功。 具体的hack方法则是利用cxc同学的评测机，对于可疑代码进行评测，得到错误输出后针对数据进行化简使其符合互测数据限制，最终hack成功。 总结第二次作业是我在第一单元中花费时间最长的一次，尤其是指数函数的引入与化简合并，在Debug时给我造成了不小的困难，由于在完成本次作业时流感发烧，因此我在优化方面仅仅做了合并同类项和去exp函数的多余括号，但性能分上取得了 97.5分，可以说是十分侥幸的。同时，由于储存基元时采用了ArrayList，因此在合并同类项与Unit运算时被迫使用深克隆，而由于身体状态不佳，处于正确性考虑，我大量使用克隆，这也使我的程序运行时间大大增长。 第三次作业本次作业引入了求导因子。本以为是最痛苦的一集，没想到成了最速的一集。UML类图如下所示： 架构分析与第二次作业相比，本次作业架构几乎没有发生变化，没有引入新的类。对于求导操作，与求字符串相似，在每一个相关的类中引入getDerivative()方法，返回Poly多项式类。对于带函数的求导，采用将自定义函数完全展开后再进行求导的方法。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 20 1 13 13 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Lexer.next() 10 2 6 8 Unit.setExp(BigInteger) 10 1 4 8 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Main.main(String[]) 5 3 4 5 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Parser.parseDerivative() 3 1 4 4 Poly.adjustUnit() 3 3 2 3 Poly.compareTo(Poly) 3 3 3 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.clone() 2 1 1 2 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Unit.getDerivative(Type) 2 1 3 3 Exp.getDerivative(Type) 1 2 1 2 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.getDerivative(Type) 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Poly.toTerms() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Expr() 0 1 1 1 Expr.Expr(Poly) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.getDerivative(Type) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.addUnit(Unit) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Poly.unitMulti(Unit, Unit) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 Unit.simpleClone() 0 1 1 1 与第二次作业中复杂度较高的方法相同，原因一致。 Bug分析本次作业在强测中未出现Bug，但是在互测中由于TLE中刀，原因正如我在第二次作业总结中写的那样——无脑克隆，而克隆方法本身需要递归，导致最终超时，这也是由于我个人的侥幸心理，认为互测数据不强，在明知有超时风险时，选择写OS作业，未进行优化。虽然强测侥幸过关，但是在互测中还是漏了马脚，果然还是这个道理。 She was still too young to know that life never gives anything for nothing, and that a price is always exacted for what fate bestows. 那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。 ——茨威格 总结第三次作业不仅没有想象中可怕，还是三次作业中耗时最少的一次。得益于层次化结构的设计，新增求导运算的升级过程非常顺利，唯一的注意点是数学上的求导法则，需要在编码时严格遵守。只是可惜我的侥幸心理导致互测中刀，现在想来仍然感到深深可惜！！！ 测试本单元由于身体状况与个人时间的关系，只在第一次作业搭建了评测机，后续使用了cxc同学的评测机，这里再次感谢cxc同学！！！ 在个人搭建评测机的过程中，我主要还是使用模拟递归下降的过程构建测试数据，并利用 Python中的 Sympy包来达到化简表达式并判断正误的效果，唯一的缺点是速度太慢。同时，我在构建评测数据时特意加入了诸如 x-x,+00000等数据，来保证随机生成数据的特殊性，但是只是可惜评测机hack效果不佳，更多还是靠手动构建数据。 心得体会第一单元就这样痛并快乐地坚持了过去，但是和同学们投入的时间相比，我好像完成得还算轻松（?） 通过表达式解析的练习，我深刻体会了面向对象的设计思想，了解了递归下降的解析方法，初步尝试了层次化的类设计，这也为OS的Lab1提供了一些帮助。 最后还是感慨：设计为先，一个好的设计能为后续的编码工作省去不少麻烦；就比如，每次作业前，我都要花上一天半来进行设计，而不是基于上手编码，否则代码必然是漏洞百出。此外，还必须注重可扩展性，即在当前设计中打一个提前量，给未来可能引入的设计提前预留一些空间。 打个比方，我的程序在第一次就支持括号嵌套，第二次就支持自定义函数嵌套，现在第三次作业的程序还支持多变量运算与求导等等。 未来方向总体而言，我认为课程组对于第一单元的设置已相对完备，但是第三次作业相较前两次明显过于轻松，我认为可以加入多变量运算与求导等要求。同样，我认为强测应该设置专门数据来卡时间复杂度，这样就能狠狠整治向我这样心存侥幸的同学！！！","link":"/2025/08/13/OO-1/"},{"title":"OO第四单元总结暨课程总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z对于OO Unit4和课程总体的总结博客 正向建模与开发先简单介绍一下 正向建模与开发 的定义 正向建模与开发是一种根据给定的需求创建或制作应用程序的方法。正向建模与开发也被称为翻新和回收。正向建模与开发需要高水平的技能，它需要更多的时间来构建或开发应用程序。正向建模与开发是一种创建高层模型或设计的技术，以增加复杂性和低层信息。因此，这种工程在不同的软件和数据库过程中有不同的原则。正向建模与开发应用了所有的软件工程过程，包括软件开发生命周期（SDLC），以重新创建现有的应用程序。它是为了满足用户的新需求而进行重构的。 本单元的主题是 UML，正向建模与开发自然是最重要的一环，我个人也是按照课程组的指导，每次作业先做好建模设计再写代码。具体步骤如下： 通读指导书，记录需求重点和细节，并针对边界情况，各种功能编写各种样例 依据样例，整理项目逻辑，记录各个类的协作关系(类似于顺序图的要求) 依据整理的逻辑进行设计，画出类图草图和协作图草图 编写代码 使用 StarUml 软件参照画 uml 图 其实前几步在其他几个单元的作业中我也会做，毕竟在完全不做设计的情况下写代码是很难的。但是我认为在设计阶段就画仔细的 uml 图其实不太方便，因为 StarUml 细节比较多，要用鼠标点来点去，会分散设计阶段的注意力，但用纸和笔来画草图就很方便，而且还可以自己加各种提示在图中。所以我每次都是先画草图，再在全部写完以后用 StarUml画出最终的 uml 图。 放上一张 Unit1的设计图，也算是有始有终了🥳： ![](OO Unit1架构.jpg) 架构设计和UML模型设计之间的追踪关系本单元架构： 在这几次的作业中，为了做到高内聚，低耦合，我根据指导书的要求对于相应的对象都建了类，让他们各司其职。但是随着需求的增多以及复杂度要求更高，对于低耦合的实现就造成了很大的困难，尤其在 OrderRecord和 BorrowRecord两个类呈现出较大的耦合性。对于一致性方面，流程图以及状态图的实现都较简单，因此一致性较好。 架构设计思维的演进其实我感觉第一单元是架构设计最复杂的单元，因为表达式十分抽象，如果没有 training和实验，我甚至都不知道怎么设计各个类，导致架构设计的难度很高，所以我的架构设计能力基本是在第一单元中养成的。我设计架构以及写代码的核心思想就是追求简单，怎么简单怎么来。因为逻辑简单的代码更好把控，更不容易出 bug，即使真的出问题也很好定位。我在 1，2 单元中都进行了轻微重构，重构的方向都是把原来复杂一些的代码化简，即使这可能会牺牲一些性能或是架构的美观性。其实“面向对象性”和架构简单性的矛盾是我一直在思考的内容。以第四单元举例，如果想秉承模块化等思想，是应该把每个功能处拆成单个类来写的，而不是在图书馆类里面写多个组合函数。但更多的类、更多的包装会导致更多的函数嵌套调用或是对象的嵌套使用，这其实会增加代码逻辑上的复杂度，也可能会增加出问题时 debug 的难度，排查一个问题时可能需要跳转多个函数，且多个函数之间都可能出现问题。这个问题我一直没有一个清晰的答案，在几个单元的作业中，我认为代码逻辑简单更重要，但这种想法也不一定对。这个问题最终的答案我可能也要到后续的代码编写实践中获取了。 测试思维的演进其实在这四个单元中，我的测试思路没有什么变化，都是黑白箱结合的方式。一方面通过阅读代码梳理逻辑等方式进行白箱测试，另一方面编写评测机或者数据生成器进行测试或对拍。这种测试方法的优点是效果尚可，只要生成的数据强度过硬就能测出代码的 bug，同时结合一点编写针对性debug样例的技巧，能够快速地定位bug，便于后续debug。 具体而言： 第一单元，借用递归下降的优势，测试数据的生成，和程序的编写，都可以一同使用，采用了大量的随机数据与少数特殊数据因子相结合的构建方法。 第二单元，DPO😭狠狠的膜了。 第三单元，主要是随机数据，同时考虑查询数据的大量性，保证基本正确性的前提下，构建大量查询边界数据来测试 TLE。另外，还有 Junit测试。 第四单元，鉴于数据有极大的限制，前期边界条件的模糊，在没有保证自己评测会不会正确的前提下，后续参考张鑫和高鹏飞同学的评测机并加以魔改来完成评测。 课程收获 入宝山不要空手而归 其实在上 OO 课之前，我就已经听说过其大名了，知道 OO 很苦很累但是能学到不少东西。但实际体验的收获还是超乎我的想象。我竟然还在一个星期内学会了多线程，这种高效率的学习是我非常喜欢的。在这之前，我也自学过各种东西，但网上的教程总是学起来效率很低，且缺乏在指导下的大规模高效实践，导致学出来只能用来吹没法实干。但 OO 课程却完全解决了这个问题，OO 课通过高压的训练和适当的引导让我很快的发现解决问题所需的重点知识并掌握了它们，在 OO 课程的学习中，我还接触了很多面向对象和 Java 以外的有用的东西，比如 JML 与契约式编程或是非常使用的 UML还有通过python来搭建评测机。这些知识也让我受益匪浅。总而言之，通过 OO 课程的学习，我见识并掌握了很多各种各样的知识，练就了各种各样的能力，收获满满。最后，很感谢老师们和助教们长久以来的付出和对我的帮助，也注 OO 课程越办越好。 还是那句古训，无论艰难困苦，最后结果成功也好，失败也罢，莫以成败论英雄， 入宝山切莫空手而归！！！","link":"/2025/08/13/OO-4/"},{"title":"OO第二单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 如果要让我对这充满坎坷的“电梯月”做一个总结，我认为贝克特的这一句名言无疑是最贴切的： [!IMPORTANT] Ever tried,Ever failed,No matter.Try again,Fail again,Fail better. –塞缪尔·贝克特 事实上，如果你碰巧是一名文学爱好者，那么你可能很难相信以荒诞文学闻名的贝克特会说出这样励志的名言。正如在真正完成这一单元之前，我也不会想到自己会在面对多线程层出不穷的Bug时，依然坚持”Fail again, fail better”。 前言第二单元我们要实现的是基于共享数据的，多线程电梯调度问题，在这一过程中，要迭代出电梯重置，双轿电梯等功能。相比第一单元，在第二单元的设计工作中，我深刻感受到了设计架构的重要性，以及多线程并行计算的优势。 整体架构图UML图由于是迭代开发，在这张UML图上我们可以看到这一路的过程。 白色的部分代表第一次作业。 绿色的部分代表第二次作业的增添。 紫色的部分代表第三次作业的增添。 时序图 设计架构开发历程 [!CAUTION] 第二单元的架构开发，我想多介绍一些， 对比第一单元作业，性能不在是实实在在的需求，而是相对虚无缥缈的东西。在保证正确性的前提下，不进行任何性能优化，也能有不错的性能分，因此架构占据了绝对的主导作用。 关于方法的复杂度就放在最后一起分析了。 作业要求：第二单元的任务为模拟群控电梯调度，重点在于多线程并发的设计。以下是任务的迭代：· hw5模拟了6部电梯的调度，乘客的请求会指定特定电梯· hw6的乘客可以自由分配给任意一部电梯，电梯需要输出已接收信号。同时增加了电梯参数的重置，重置时会暂停并处于静默状态· hw7增加了分裂为双轿厢的重置模式，需要在换乘层进行协调 hw5同步块和锁第一次作业，同时也是首次进行多线程编程，完成作业的大部分时间都放在了理解什么是多线程，以及什么是同步块上。 那么什么是同步块呢？简单来说就是，随便找点什么，多个类共用（指的是多个线程在同一时刻共同访问），套上 synchronized关键字。同步块的效果是什么？套上 synchronized关键字之后，在每一个时刻只能有一个线程访问。什么是锁？锁是当多个线程竞争同一个共享数据的时候，不让其他线程访问的重要武器。在 synchronized之外，还可以通过重入锁，读写锁等方式实现灵活的上锁。 由于第一次作业要求实在太过简单，六台电梯分别有自己对应的乘客，因此只需将总请求池上锁即可，同时在电梯需要进行 sleep()时给电梯上锁，确保其状态不受改变就可以保证线程安全，具体细节上采用 ReentrantLock即可实现，无需多言。 调度器和调度策略由于第一次不涉及“电梯抢人”的问题，所以无需设计调度器以及调度策略。 电梯运行算法采用的是 LOOK运行算法，也是日常生活中的电梯算法，即顺带接人运行策略，略微不同的地方是，现实中，在乘客进入电梯前，我们是不知道乘客的目的地的。但在本单元的作业中，人不是线程而是一个 Object，不仅方便了调度器的分配，而且降低了复杂度。 hw6同步块和锁与第一次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。 调度器和调度策略调度器采用**影子电梯**策略，即算出局部最优解分配给6个线程。具体做法是对电梯和该电梯的处理队列进行深克隆，调用克隆后的 shadowElevator.move()实现模拟推进时间，遍历6个电梯，找出能够使得新请求加入后整体运行时间结束最早的那一种加入请求算法。 为方便说明，举例如下图所示：绿色方块为电梯原有请求完成需要花费时间，每一列为一种分配策略对应各个电梯用时（共六种，即把新请求分配给六个电梯，分别遍历），找出该策略下用时最久的电梯为该策略对应的全局任务完成时间，再将六个策略的时间找出最短的，就获得了局部最优解。下图的情况即为将新请求加入3号电梯是局部最优解。 注：示例图片来自武彬煦学长的博客 这样，调度器成为了线程，调度器和输入线程之间，调度器和各个电梯之间，通过一个等待队列连接。 这样的策略可以做到局部时间最优，由于本人的懒惰，并未在影子电梯的指标中加入耗电量的考量。 hw7同步块和锁与第二次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。事实上，这只是我粗浅的理解，让我在互测中身中15刀 [!CAUTION] 事实上，由于我的设计中，DC Reset要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException😭 调度器和调度策略调度器依旧采用**影子电梯**策略，由于这次存在双轿厢电梯，而影子电梯无法模拟换乘，因此在计算电梯结束时间时，对于双轿厢电梯中无法直达的请求，采取惩罚补时，来进行粗略模拟，效果还可以。 双轿厢电梯安全控制在设计这次作业时OS正好在学信号量，事实上，换乘楼层只允许一个轿厢停靠，本质上就是一种信号量操作，而最大值为一的信号量实际上就是一把锁，两轿厢要进入换乘楼层时尝试获得锁，离开换乘楼层时释放锁即可。 具体代码上通过设置 Police类来监管双轿厢： 123456789101112131415161718192021222324252627public class Police { private boolean occupied = false; public synchronized void getAccess(Character type) { tryAccess(type); occupied = true; notifyAll(); } private synchronized void tryAccess(Character type) { notifyAll(); while (occupied) { try { wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } public synchronized void release() { occupied = false; notifyAll(); }} 稳定和易变稳定：稳定的内容主要还是电梯的捎带一直采取 LOOK算法，保证了绝大多数情况下电梯平均性能的优越性。同时在二三次作业中都采取了影子电梯模拟的调度策略，改变不大。 易变：乘客需求，电梯的类型每次作业都在改变，而这些都是通过 Reset指令实现的，如何妥善实现这些指令也正是本单元的设计重点。 结束的条件也随之变化，从每个电梯自己结束，到调度器统一分配结束。 BUG分析hw5第五次作业较为简单，在本地编写代码以及线上测试时都未发现Bug hw6第六次作业在编写时遇到的最主要的Bug在于线程无法安全结束，原因在于与第五次作业不同，在第六次作业中调度器是作为一个线程存在的，因此要确定它和电梯线程结束的顺序就成为了Bug产生的重灾区，最终也是通过不断通过评测机测试得到错误数据再通过 Print大法来查看线程具体结束情况最终解决Bug。 在互测中产生了一个Bug，原因是在五台电梯 Reset时会将所有请求分给一台可以使用的电梯，最终导致 RTLE。只要在只有一台电梯不在 Reset时让调度器等一等就行了，也不会轮询。 hw7第七次作业的Bug堪称最搞笑的一集。 强测中没出现Bug，但在互测中，由于我的设计在DC Rese时要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException，或者造成无法正常 Reset，导致CTLE，最终身中15刀。 解决办法是做 ArrayList&lt;Elevator&gt; elevators $\\to$ CopyOnWriteArrayList&lt;Elevator&gt; elevators的修改即可。 总结毫无疑问，对于多线程编程而言，Debug绝对是最痛苦，最耗时的部分。总结来看，一个好的架构往往能保证较高的Bug复现率。 而对于多线程Bug，除了 Print大法我深感无力，这也导致在强测结果出来前我一直保持着“先质疑，再质疑”的态度，好在最后强测都没出事，也算是万幸。 [!IMPORTANT] 还是那句老话，对于多线程测试，评测机上十万组正确数据都不如一个能稳定复现的Bug来的金贵和安心。 心得体会线程安全从单线程到多线程，性能上的巨大飞跃，必然带来的是设计上的复杂性，数据安全便是这方面的核心，但是更重要的是保证线程安全的同时，提高解决效率，不能长时间占有锁，更不能在 sleep的时候占有锁，要保证原子性，但一定要对同一时间的多条判断语句进行原子锁。 保证线程安全下的提高效率，真正的拉开了与单线程之间的差距，只注重数据的安全的结果往往是死锁，和轮询，这是要极力避免的。 层次化设计好的设计带来的优势在这一单元体现的淋漓尽致。正如前文所言，好的设计能够极大减少性能优化上的工作，以及提高本地测试时的Bug复现率，能够减少代码编写时的时间耗费。 “两天设计，一日编码”。这单元最好的工作流程就是这样，多线程编程设计细节颇多，如果无法在设计上提前规划这些细节，那么只会徒增Bug，白白浪费时间罢了。","link":"/2025/08/13/OO-2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/08/13/hello-world/"},{"title":"challenge-shell","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 总述先上图，看看我的成品Shell 由于我选择的是Lab6的挑战性任务，整体的子任务数较多，故接下来的介绍顺序完全基于我的实现过程，如有不清楚之处，完全源于本人的能力不足，烦请各位看官海涵。 按照评测测试点，我的实现顺序为 $3 \\to 4 \\to 2 \\to 1 \\to 5$，接下来按照这种顺序介绍。 具体实现实现不带 .b 后缀指令spawn函数与 fork 函数类似，其最终效果都是产生一个子进程，不过与 fork函数不同的是，spawn 函数产生的子进程不再执行与父进程相同的程序，而是装载新的ELF文件，执行新的程序。 事实上spawn就是在尝试执行shell里的命令，所以在这里尝试追加执行是最佳位置。即当用户指定的程序路径不存在时，在这里尝试在路径后追加 .b 再打开。 具体代码： 123456789101112131415161718192021// user/lib/spawn.c spawnchar tmp[MAXPATHLEN]; if (prog[0] != '.') { strcpy(tmp, &quot;/&quot;); strcpy(tmp + 1, prog); } else { strcpy(tmp, prog); } int fd; fd = open(tmp, O_RDONLY); if (fd &lt; 0) { int len = strlen(tmp); strcpy(tmp + len, &quot;.b&quot;); fd = open(tmp, O_RDONLY); } if (fd &lt; 0) { return fd; } 实现反引号、注释和历史指令实现反引号实现反引号的思路实际上与引号类似，就是当parsecmd调用gettoken读到**`**,后，进一步解析其后的字符串，直到另一个反引号位置，获取其中的字符串，直接 runcmd()，具体思路可见下面的示意图： 实际上，上述思路的实现尚不成熟，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142//sh.c gettokenif (*s == '`') { in_quot = !in_quot; }if (in_quot) { *p1 = s; while (*s &amp;&amp; ((in_quot &amp;&amp; !strchr(&quot;`&quot;, *s)) ||!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; } //sh.c parsecmdcase '`': debugf(&quot;clg: use `\\n&quot;); gettoken(0, &amp;t); char s[100]; strcpy(s, t); char ch = gettoken(0, &amp;t); ch = gettoken(0, &amp;t); if (ch == 0 || ch == '\\0') { runcmd(s); } else { if (ch == ';') { int fork1 = 0; fork1 = fork(); if (fork1) { wait(fork1); return parsecmd(argv, rightpipe, 1, job_flag); } else { runcmd(s); } } runcmd(s); } 实际上，在后来处理引号的时候，思路就很清晰了： 12345678910111213//sh.c gettokenif(*s == '`') { // 识别反引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '`')){ s++; } *s++ = 0; *p2 = s; return 'r'; //表示反引号} 实现注释实际上，注释的功能和读取空白符并无区别，较为简单，代码见下： 12345678910111213//sh.c gettoken*p1 = s; while (*s &amp;&amp; (!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; 由于历史指令的实现我使用了追加重定向的功能，故放到下文一并说 实现追加重定向和引号支持实现引号支持与上文反引号思路相同，直接给出代码： 123456789101112131415161718192021222324//sh.c gettokenif(*s == '\\&quot;') { // 识别引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '\\&quot;')){ s++; } *s++ = 0; *p2 = s; return 's'; // it means &quot;string&quot; }//sh.c parsecmdcase 's': if (argc &gt;= MAXARGS) { debugf(&quot;too many arguments\\n&quot;); exit(); } if (need) { argv[argc++] = t; } 实现追加重定向我的思路是添加一个新的写入方式，即追加 APPEND 123456//user/include/lib.h#define O_APPEND 0x0004//user/lib/file.c openif ((mode &amp; O_APPEND) != 0) { fd-&gt;fd_offset = size;} 因为我们的shell原本就支持对于&gt;&gt;的解析，所以我们只需要在parsecmd中稍作修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case '&gt;':; int cc; cc = gettoken(0, &amp;t); if (cc == '&gt;') { if (gettoken(0, &amp;t) != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_APPEND | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } else { if (cc != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } //argv[argc++] = t; //user_panic(&quot;&gt; redirection not implemented&quot;); re_alloc = 1; 这里的re_alloc是一个全局变量，表示指令进行了重定向，在后续一行多指令的实现中起了作用。 实现历史指令由于我们已经实现了追加写入，那么保存命令就简单了： 1234567891011121314//sh.c save_cmdvoid save_cmd(char* cmd) { int r = open(&quot;/.mosh_history&quot;, O_CREAT | O_WRONLY | O_APPEND); if (r &lt; 0) { debugf(&quot;open /.mosh_history failed to save&quot;); return r; } write(r, cmd, strlen(cmd)); write(r, &quot;\\n&quot;, 1); return 0;}//sh.c main save_cmd(buf); 接下来就可以通过history命令调取历史记录并输出： 1234567891011121314151617181920212223242526272829//sh.c rumcmd 实现内置指令if (strcmp(argv[0], &quot;history&quot;) == 0) { history(); }//sh.c historyvoid history() { int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed\\n&quot;); return; } char buf; int r; int cnt = 0; int newline = 1; while ((r = read(fdnum, &amp;buf, 1)) != 0) { if (newline) { debugf(&quot;%c&quot;, buf); cnt++; newline = 0; } else { debugf(&quot;%c&quot;, buf); } if (buf == '\\n') { newline = 1; } }} 实现指令回显由于这部分在评测中尚未涉及，故不多赘述，简单介绍原理 我们知道Linux对于上下左右键的编码 上下左右键在linux中会被编码为 上： 27 ‘[’ ‘A’ 下： 27 ‘[’ ‘B’ 右： 27 ‘[’ ‘C’ 左： 27 ‘[’ ‘D’ 所以我们需要在读到27[Esc]后连续读取两个字符以判断指令的类型,从而分别调用属于左右键和上下键的不同功能。 具体这部分代码部分参考了Charles学长的博客，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180int newDirCmd = 1;int offset; // 0:empty line, -1:last cmd, -2:...int solveDirCmd(char* buf, int type) { // type: 0 means up, 1 means down if (newDirCmd == 1) { offset = 0; } if (type == 0) { offset--; } else if (offset &lt; 0) { offset++; } int x = 0; if (offset == 0) { while (buf[x] != '\\0') { buf[x] = '\\0'; x++; } return -1; } int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed in sloveDir!\\n&quot;); return 0; } struct Fd* fd = num2fd(fdnum); char* c; char* begin = fd2data(fd); char* end = begin + ((struct Filefd*)fd)-&gt;f_file.f_size; c = end - 1; while (((*c) == '\\n' || (*c) == 0) &amp;&amp; (c &gt; begin)) { c--; } if (c == begin) { // no history cmd buf[0] = '\\0'; return 0; } c++; // last \\n or \\0 int i; for (i = 0; i &gt; offset; i--) { while ((*c) != '\\n' &amp;&amp; (*c) != '\\0') { c--; if (c &lt;= begin) { break; } } c--; if (c &lt;= begin) { break; } } offset = i; // avoid offset too bigger than real cmd num if (c &gt; begin) { while (c &gt; begin &amp;&amp; (*c) != '\\n') { c--; } if ((*c) == '\\n') { c++; } } else { c = begin; } int now = 0; while (buf[now] != '\\0') { buf[now] = '\\0'; now++; } now = 0; while ((*c) != '\\n' &amp;&amp; (*c) != '\\0' &amp;&amp; (*c) &lt; end) { buf[now] = *c; now++; c++; } return now;}#define MOVELEFT(y) printf(&quot;\\033[%dD&quot;, (y))#define MOVERIGHT(y) printf(&quot;\\033[%dC&quot;, (y))void readline(char* buf, u_int n) { /* TODO:lab6-challenge */ int r; int off = 0; int len = 0; char op; while (off &lt; n) { if ((r = read(0, &amp;op, 1)) != 1) { if (r &lt; 0) { debugf(&quot;read error: %d\\n&quot;, r); } exit(); } if (op == '\\b' || op == 0x7f) { /* TODO:lab6-challenge */ if (off &gt; 0) { if (off == len) { buf[--off] = 0; printf(&quot;\\033[D \\033[D&quot;); } else { for (int j = off - 1; j &lt; len - 1; j++) { buf[j] = buf[j + 1]; } buf[len - 1] = 0; MOVELEFT(off--); printf(&quot;%s &quot;, buf); MOVELEFT(len - off); } len -= 1; } // } else if (op == '\\r' || op == '\\n') { buf[len] = 0; return; } /* TODO:lab6-challenge */ else if (op == 27) { char tmp; read(0, &amp;tmp, 1); char tmp2; read(0, &amp;tmp2, 1); if (tmp == 91 &amp;&amp; tmp2 == 65) { debugf(&quot;\\x1b[B&quot;); // down to cmd line int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); // left to line head } debugf(&quot;\\x1b[K&quot;); // clean line off = solveDirCmd(buf, 0); len = strlen(buf); debugf(&quot;%s&quot;, buf); } else if (tmp == 91 &amp;&amp; tmp2 == 66) { int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); } debugf(&quot;\\x1b[K&quot;); off = solveDirCmd(buf, 1); len = strlen(buf); debugf(&quot;%s&quot;, buf); } /* TODO:lab6-challenge */ else if (tmp == 91 &amp;&amp; tmp2 == 67) { if (off &lt; len) { off++; } else { MOVELEFT(1); } } else if (tmp == 91 &amp;&amp; tmp2 == 68) { if (off &gt; 0) { off--; } else { MOVERIGHT(1); } } // newDirCmd = 0; } else { newDirCmd = 1; if (off == len) { buf[off++] = op; } else { // i &lt; len for (int j = len; j &gt; off; j--) { buf[j] = buf[j - 1]; } buf[off] = op; buf[len + 1] = 0; MOVELEFT(++off); printf(&quot;%s&quot;, buf); MOVELEFT(len - off + 1); } len += 1; } } debugf(&quot;line too long\\n&quot;); while ((r = read(0, buf, 1)) == 1 &amp;&amp; buf[0] != '\\r' &amp;&amp; buf[0] != '\\n') { ; } buf[0] = 0;} 由于同时监听了左右键，所以同时了实现键入命令时任意位置的修改实现了在当前光标位置进行字符的增加与删除。在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。 实现一行多指令shell的原理是main 从控制台读取一行后fork，把这一行命令传递给子进程。子进程执行完毕后退出，父进程调用wait函数等待子进程执行结束被摧毁。 因为在 user/sh.c中的保留 SYMBOLS 里已经预留有 ; 字符，gettoken 函数本身就能够解析下一个 ; 字符，所以我们只需要将；作为一个特殊的token即可，我们无需改变词法部分，只需改变语法解释部分。 [!CAUTION] 注意，在实现一行多命令的过程中，务必考虑以下重定向样例 echo &quot;aaa&quot; &gt;&gt; file1; cat file1 如果在上条命令执行后未及时重定向回标准输出，则再进行一次cat file1会发现file1中写入了两个aaa 下附代码： 1234567891011121314151617case ';':; if (need == 0) { return parsecmd(argv, rightpipe, 1, job_flag); } else { int child = fork(); // fork出两个进程 if(child) { // 父进程等待子进程执行完再执行';'右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } wait(child); return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行';'左边的命令 return argc; } } 实现更多指令touch没什么好说的，就创建文件就行了，下附代码： 12345678910111213141516171819202122232425#include &lt;lib.h&gt;void usage(void) { debugf(&quot;usage: touch file...\\n&quot;); exit();}int main(int argc, char *argv[]) { int fd; if (argc &lt; 2) { usage(); } for (int i = 1; i &lt; argc; i++) { if ((fd = open(argv[i], O_CREAT)) &gt;= 0) { close(fd); } else { printf(&quot;touch: cannot touch \\'%s\\': No such file or directory\\n&quot;, argv[i]); } } return 0;} rmrm指令需要解析其输入后的参数，如-r, -f, -rf等等，我采用了全局变量来实现，同时编写了工具函数isdir来判断要求的文件是不是目录: 123456789101112131415static void init(){ enableForce = 0; // -f enableRecursive = 0; // -r}int isdir(const char* path){ struct Stat st; if (stat(path, &amp;st) &lt; 0) return 0; return st.st_isdir;} 主体实现部分为两个函数rm 和 _rm分别表示删除文件和目录，原理较为简单，rm调用remove删除文件，_rm则通过遍历目标目录后不断递归调用自身，来实现对于目标目录的递归删除，下附代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void rm(const char* path){ int ret; struct Stat st; if ((ret = stat(path, &amp;st)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } if (st.st_isdir &amp;&amp; !enableRecursive) { printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); return; } if (st.st_isdir) _rm(path); ret = remove(path); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, path, ret);}static void _rm(const char* path){ char dir[MAXPATHLEN]; // open directory int fd; if ((fd = open(path, O_RDONLY)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } // get number of sub items int size; int ret; int is_dir; struct File file; while ((size = readn(fd, &amp;file, sizeof(struct File))) == sizeof(struct File)) { if (!file.f_name[0]) continue; strcpy(dir, path); strcat_(dir, &quot;/&quot;); strcat_(dir, file.f_name); is_dir = isdir(dir); if (is_dir) { if (!enableRecursive) printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); else _rm(dir); } ret = remove(dir); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, dir, ret); }} mkdirmkdir是这3个指令中最麻烦的一个，考虑到-p指令的特殊性，为实现这一条指令，新增了不少工具函数： 12345678910111213141516171819202122232425262728293031323334//user/include/fsreq.hstruct Fsreq_create{ char req_path[MAXPATHLEN]; u_int req_omode;}; //表示创建目录//fs/fs.cint file_creat(const char* path, u_int omode, struct File** pfile){ char name[MAXNAMELEN]; struct File* dir; struct File* f; int ret; if ((ret = walk_path(path, &amp;dir, &amp;f, name)) == 0) return -E_FILE_EXISTS; if ((ret != -E_NOT_FOUND) || (dir == NULL)) return ret; if ((ret = dir_alloc_file(dir, &amp;f)) &lt; 0) return ret; strcpy(f-&gt;f_name, name); f-&gt;f_type = (omode &amp; O_MKDIR) ? FTYPE_DIR : FTYPE_REG; if (pfile) *pfile = f; // file_flush(f); return 0;} //创建目录 在mkdir.c中，思路与rm类似，同时创建了access工具函数，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void init(){ enableParents = 0;}//accessint access(const char* path, int type){ char dir[MAXPATHLEN]; struct Stat st; int ret; while (*path &amp;&amp; (*path == ' ')) path++; strcpy_(dir, path); // debugf(&quot;Access: %s\\n&quot;, dir); ret = stat(dir, &amp;st); if (ret &lt; 0) { // debugf(&quot;Acess error: %d\\n&quot;, ret); return 0; } if (type == FTYPE_DIR) return st.st_isdir; else if (type == FTYPE_REG) return !st.st_isdir; return 1;}//mkdirstatic int mkdir(const char* path){ char dir[MAXPATHLEN]; const char* p = path; const char* base = path; while (*p != '\\0') { while (*p &amp;&amp; (*p != '/')) p++; memcpy_(dir, base, p - base); dir[p - base] = '\\0'; while (*p &amp;&amp; (*p == '/')) p++; if (*p) // there are remaining directories to create try(_create(dir, enableParents, 0)); else // the last element try(_create(dir, 1, 1)); } return 0;} 主体mkdir函数中，通过不断调用_create函数，来实现目录的递归创建： 12345678910111213141516171819202122232425static int _create(const char* path, int create, int final){ if (access(path, FTYPE_DIR)) { if (!final) return 0; printf(&quot;mkdir: cannot create directory \\'%s\\': File exists\\n&quot;, path); return 11; } // now, there is no such a file if (!create &amp;&amp; !final) { printf(&quot;mkdir: cannot create directory \\'%s\\': No such file or directory\\n&quot;, path); return 13; } // now, it's time to create file int ret = creat(path, O_MKDIR); if (ret &lt; 0) { debugf(&quot;Failed to create '%s': %d\\n&quot;, path, ret); return ret; } return 0;} 实现指令条件执行个人认为这是本次挑战性任务中最难的一个点，在深思熟虑后，我并未采取课程组提供的修改exit函数的思路 指令返回值获取同时，根据讨论区于恩泽同学的前车之鉴，我新建了专门的ipc来发送返回值： 12345678910111213141516171819202122232425262728//user/lib/ipc.cvoid ipc_send_cmd(u_int whom, u_int val, const void *srcva, u_int perm) { int r; while ((r = syscall_ipc_try_send_cmd(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) { syscall_yield(); } user_assert(r == 0);}u_int ipc_recv_cmd(u_int *whom, void *dstva, u_int *perm) { int r = syscall_ipc_recv_cmd(dstva); if (r != 0) { user_panic(&quot;syscall_ipc_recv err: %d&quot;, r); } if (whom) { *whom = env-&gt;env_ipc_from; } if (perm) { *perm = env-&gt;env_ipc_perm; } return env-&gt;env_ipc_value;}//env.hu_int env_ipc_recving_cmd; //whether this env is receiving cmd 然后在libos.c 和 debugf.c中进行修改，使相关函数能够发送返回值： 12345678910111213141516171819202122232425262728//libos.cvoid libmain(int argc, char **argv) { // set env to point at our env structure in envs[]. env = &amp;envs[ENVX(syscall_getenvid())]; // call user main routine int r; r = main(argc, argv); debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); syscall_env_job_done(env-&gt;env_id); // exit gracefully exit();}//debugf.cvoid _user_panic(const char *file, int line, const char *fmt, ...) { debugf(&quot;panic at %s:%d: &quot;, file, line); va_list ap; va_start(ap, fmt); vdebugf(fmt, ap); va_end(ap); debugf(&quot;\\n&quot;); // //ipc_send(env-&gt;env_parent_id, r, 0, 0); ipc_send_cmd(env-&gt;env_parent_id, -1, 0, 0); exit();} 根据返回值条件执行指令同时在runcmd中进行修改，来获取和发送返回值，同时给parsecmd添加一个参数，根据上条命令的返回值，来指示当前命令是否执行，同时在gettoken中添加判断，来解析&amp;&amp; 和 ||，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//gettokenif (*s == '&amp;') { if (*(s + 1) == '&amp;') { *s++ = 0; flag = 'a'; } } if (*s == '|') { if (*(s + 1) == '|') { *s++ = 0; flag = 'o'; } } //parsecmd case 'a': debugf(&quot;we have &amp;&amp;\\n&quot;); if (need) { forkand = fork(); if (forkand == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); int need_ = (i == 0) ? 1 : 0; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 1, job_flag); }…… case 'o': debugf(&quot;we have ||\\n&quot;); if (need) { forkor = fork(); if (forkor == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); //wait(forkand); int need_ = (i == 0) ? 0 : 1; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 0, job_flag); }//runcmdif (argc == 0) { if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, 0, 0, 0); } return; }int child = spawn(argv[0], argv); close_all(); if (child &gt;= 0) { //debugf(&quot;Begin recv : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); if (job_flag) { syscall_env_save_job(child, tmp); } int r = ipc_recv_cmd(NULL, 0, 0); if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); } 实现前后台任务管理后台任务运行所谓后台运行所需要的任务便是shell 不需要等待此命令执行完毕后再继续执行，即当存在&amp;时，不进行wait即可，下附代码： 12345678910111213141516//parsecmdcase '&amp;':; int child_ = fork(); if(child_) { // 父进程执行右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } re_alloc = 0; return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行左边的命令 re_alloc = 0; *job_flag = 1; return argc; } 后台任务管理考虑到如果在用户进程中维护一个任务列表，那么各进程间共享将会非常麻烦，于是进过慎重考虑，我决定在内核维护一个任务列表，通过系统调用来进行操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//env.hstruct Job { int status; // 0表示已经结束，1表示正在运行 int envid; char cmd[200]; };//env.cstatic struct Job jobs[2000];void env_save_job(u_int envid, char *cmd) { jobs[job_cnt].envid = envid; strcpy(jobs[job_cnt].cmd, cmd); jobs[job_cnt].status = 1; job_cnt++;}void env_job_done(u_int envid) { for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].envid == envid) { jobs[i].status = 0; break; } }}int env_get_job(int i) { if (i &gt; job_cnt) { return -1; } return jobs[i - 1].envid;}void env_jobs() { char str[20]; for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].status == 0) { strcpy(str, &quot;Done&quot;); } else { strcpy(str, &quot;Running&quot;); } printk(&quot;[%d] %-10s 0x%08x %s\\n&quot;, i + 1, str, jobs[i].envid, jobs[i].cmd); }}//syscall_all.cvoid sys_env_save_job(u_int envid, char *cmd) { env_save_job(envid, cmd);}void sys_env_job_done(u_int envid) { env_job_done(envid);}int sys_env_get_job(int i) { return env_get_job(i);}void sys_env_jobs() { env_jobs();}//sh.cvoid jobs() { syscall_env_jobs();}void kill(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { syscall_env_destroy(envid); syscall_env_job_done(envid); }}void fg(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { wait(envid); }} fg即wait该任务完成。 同时，设置全局变量job_flag，表示该任务是否为后台任务，需要进行管理，在runcmd中完成内置指令的实现： 12345678910111213141516171819202122232425//sh.c runcmdelse if (strcmp(argv[0], &quot;jobs&quot;) == 0 &amp;&amp; argc == 1) { jobs(); close_all(); } else if (strcmp(argv[0], &quot;kill&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } kill(ret); close_all(); } else if (strcmp(argv[0], &quot;fg&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } syscall_env_job_done(ret); fg(ret); close_all(); } 易错点同时，有几个需要注意的点： 123456789101112//libos.c libmainsyscall_env_job_done(env-&gt;env_id); 在指令结束前将任务设置为Done//syscall_all.cint sys_cgetc(void) { int ch; //while ((ch = scancharc()) == 0) { //} ch = scancharc(); //Shell-Challenge return ch;}删除了造成忙等的死循环 完结撒花！！！至此，挑战性任务的所有功能实现完毕 心路历程从开始到结束，总计135次commit(超过了OO两学期的commit总和)，终于是把Shell做完了，虽然是一个残废版的shell，感谢yez，zyt，zx几位大佬，以及助教shk不厌其烦地解答我的疑问，是你们拯救了我羸弱的OS，衷心感谢","link":"/2025/08/14/challenge-shell/"},{"title":"OO第三单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是一篇 OO Unit3助教当年对于U3的吐槽，现在看实在是回旋镖🪃满天飞啊🤣 测试过程黑箱测试与白箱测试通过查阅资料，我暂且给出黑箱测试与白箱测试的定义和方法。 黑箱测试也称功能测试、数据驱动测试或基于规格说明的测试。测试者只知道程序的输入、输出和系统的功能，这是从使用者的角度针对软件的接口、功能及外部结构进行的测试，不考虑程序内部实现逻辑。 白箱测试也称结构测试、逻辑驱动测试或基于程序本身的测试，测试程序内部结构或运行。在白箱测试时，从程序设计语言的角度来设计测试样例。测试者输入数据并验证数据在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。 了解了黑箱测试和白箱测试的定义后，我认识到虽然之前从未接触过这两个概念，但已经使用类似的方法开始测试了。 首先是白箱测试，从C语言程序设计课开始，我似乎就已经开始使用白箱测试了。对我来说，白箱测试的用处是在写完代码后确定程序中的每一步是否都是按照设想执行的，具体的实现方法往往是在每一行可能改变变量值的代码后都加上 printf()或 System.out.println()语句输出想要查看的变量值。我认为这种方法的效果与单步调试的效果相当，但更加简单直接、更加灵活且可用于多线程情况。 之后是黑箱测试，仅关注在给定功能要求和输入下的输出。这个也不陌生，各种课程组的评测机、自己写的评测机和对拍器以及本单元作业中出现的OKTest都是黑箱测试。 在日常使用中，对代码的测试往往是黑箱和白箱相结合的。以OS上机为例，在自认为完成要求后，我会先使用 make xxxx &amp;&amp; make run跑一下课程组的测试。测试代码往往是单独的一个文件，并在其内调用我写好的函数，通过 assert语句检查函数的返回值是否符合预期，这是黑箱测试。在这测试后，如果出现了问题，便需要具体检查函数的实现。这个过程既需要用人脑模拟代码的执行，又可以在多条关键语句前后加上 printk(), debugf()检查变量值的变化是否符合逻辑预期，碰到不符合预期的地方便是发现bug，可以开始修改了，改完之后便可以使用黑箱测试继续测试最终结果，若结果不对就继续白箱测试…… 单元测试等多种测试手段 单元测试：单元测试是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作，对面向过程的语言来说是测试函数，对面向对象的语言来说是测试类的行为。在第10次作业中，我构造大数据完全图对 qsp, qtvs, qtav, qba, qcs等指令进行了测试，这便是单元测试的应用。 功能测试：通过上面黑箱测试的介绍可知功能测试大概就是黑箱测试，不考虑程序内部结构而仅测试程序执行的结果。 集成测试：集成测试是指把多个程序模块放在一起测试的方法。由于每个模块都正确不一定能保证整个程序正确，在单元测试后把多个单元结合在一起测试的集成测试必不可少。从实际效果上来说，在第三单元的功能不断增加的迭代开发过程中，前一次作业中全面的强测就相当于下一次作业的集成测试。 压力测试：压力测试是针对系统或是组建，为确定其稳定性而特意进行的严格测试。我感觉压力测试的意义在于低压测试对不同情况的覆盖不完全，从而可能检查不出程序的潜藏问题，而高压测试通过大数据、高并发(如果是多线程)，可以尽可能枚举出各种情况，增大发现问题的概率。距离而言，在电梯单元中，自己造出的弱数据不一定能发现像是轮询、死锁之类的问题，而助教出的压力测试强数据以及评测机超多线程同时跑多份代码的情况则几乎可以发现绝大多数问题。 回归测试：回归测试旨在测试软件原有功能在修改后是否保持完整，这也是纪老师在课上多次提到的。举例而言，在OO每个单元的迭代中，在测试完某一次作业后，要保留好自己构造的测试样例，下次迭代开发之后继续使用。 数据构造策略在三次作业中，我尝试写了两种数据生成器，一个是针对各种指令的集成测试数据生成器，一个是针对 qtvs, qbs, qcs等指令的单元测试/压力测试生成器。单元测试生成器的逻辑比较简单，首先通过 ln构建一个完全图，然后加入一定数量的 tag，同时不断 ar, mr并且 qtvs，最后再一直 qtvs总计10000条数据来进行压力测试，考虑到 OO评测机的玄学属性，对于一切本地运行时间超过 1.6s的数据，进行分析，并且对于代码进行相应的优化。对于集成测试数据生成器，我原本想采用全部随机生成的方式，但发现这样生成的数据会有大量的异常，对于各种计数指令几乎起不到测试效果。于是我在生成器中维护了几个 id池以及关系池用来存放已经生成的数据，并在具体生成指令时，通过随机数判断生成会引起异常的指令或是不会引起异常的指令，这样生成的数据效果尚可。 架构与图模型在架构上，由于官方包已经给出了比较多且明确的要求和限制，我并没有做什么突破，不同类之间的层次关系都是按照官方包写的。而对于图模型的设计和维护则是本单元算法考察的重点。下面重点谈谈我在三次作业中的图模型设计。 图使用邻接表，即 Acquaintance构建。对于 qci和 qbs，hw9就涉及删边，故并不采用并查集等算法，在每次 qci时做 BFS，在加边/删边时BFS动态维护 qbs。对于 qts，在加边和删边时动态维护。对于 qba，对每个点开一个 TreeSet，在增/删/修改边权时，动态维护该点的 bestAc；对于 qcs，每次遍历所有点进行统计。 优化的重点在于 Tag中的方法，尤其是 qtvs方法，经过本地压力测试，发现如果不进行动态维护，而是使用 JML描述的直接查询的O($n^2$)的复杂度方法，则会 CTLE，因此必须在每次 att, dft,ar, mr的时候进行动态维护。 规格与实现分离及性能问题规格与实现分离在这个单元中，其实很能体会到规格与实现的分离，因为假如不分离，实现按着 JML来，便会因为性能不佳O($n^2$)甚至O($n^3$)的时间复杂度可不是闹着玩的😅而大把扣分。而为了实现规格与代码的分离，我认为要做以下两步。 第一步是通读 JML规格，把 JML的规格设计转换为自然语言，抽象为一些符合常识的描述。在面对一些复杂方法时，这一步尤为重要，因为 JML只描述规格，而我们写代码一般需要知道某个函数的意义(我认为一般人都没有在不知道意义的情况下直接把一堆通过遍历描述的方法转换为 dijkstra等较优算法的能力)。 第二步是根据抽象出来的自然语言描述选取合适的数据结构和算法，完成需要实现的功能。 实现中的性能问题我的代码在本单元三次作业的强测和互测中均未出现性能问题。究其原因，在于我在每一次阅读 JML时就对其中蕴涵的时间复杂度“陷阱”，在经过压力测试后采用动态维护，最终避免了 CTLE。通过上面规格与实现分离部分的讨论便可看出，规格和实现是可以分离的，而作为程序员，应该追求满足规格下的最优性能实现。但是否能达到很好的效果，则取决于程序员的知识积累与阅历。简单来说，如果知道更好的算法，就有可能写出性能更好的代码，否则仅凭规格就写不出来。 Junit测试Junit测试与充分诠释了“测不准原理”的 OO评测机共同构成了Unit3的两大梦魇，甚至在中测环节，Junit测试带来的压迫感远比程序正确性要大得多。 看着即将见底的提交剩余次数与随时可能测出问题的代码，和随机刷新的Junit测试 WA测试点，大家难免骂骂咧咧😡，汗流浃背😅。 那么，有没有办法系统性的解决这一问题呢，我认为是有的。我们发现，Junit测试重点关注两个部分——覆盖率高的测试数据，以及确保“万无一失”的标程。 构造覆盖率高的数据构造覆盖率高的数据技巧不高，在完成数据构造后，可以运用IDEA中的使用覆盖率运行test来进行分支覆盖率测试，最终不断完善，获得一组对目标方法分支覆盖率100%的测试数据。 撰写标程标程考察的无非以下几个条件： 检查 ensure； 检查 pure/assignable； 检查 invariant/constraint； 等等 在具体了解了这些条件后，我们其实可以借鉴 OKTest的方法来撰写标程，下面以 hw11中的 deleteColdEmoji()的测试为例来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int judge(HashMap&lt;Integer, Integer&gt; beforeEmojis, HashMap&lt;Integer, Integer&gt; beforeMessages, HashMap&lt;Integer, Integer&gt; afterEmojis, HashMap&lt;Integer, Integer&gt; afterMessages, int limit, int result) { for (int eid : beforeEmojis.keySet()) { if (beforeEmojis.get(eid) &gt;= limit &amp;&amp; !afterEmojis.containsKey(eid)) { //System.out.println(eid + &quot; &quot; + beforeEmojis.get(eid)); return 1; } } for (int eid : afterEmojis.keySet()) { if (!beforeEmojis.containsKey(eid) || !beforeEmojis.get(eid).equals(afterEmojis.get(eid))) { return 2; } } int cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeEmojis.entrySet()) { if (entry.getValue() &gt;= limit) { ++cnt; } } if (cnt != afterEmojis.size()) { return 3; } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() != null &amp;&amp; afterEmojis.containsKey(entry.getValue()) &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || !entry.getValue().equals(afterMessages.get(entry.getKey())))) { return 5; } } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || afterMessages.get(entry.getKey()) != null)) { return 6; } } cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null) { ++cnt; } else if (afterEmojis.containsKey(entry.getValue())) { ++cnt; } } if (cnt != afterMessages.size()) { return 7; } return result == afterEmojis.size() ? 0 : 8; } 可以看到，我们针对 JML中的 \\old条件设置了 before*的一系列数据点，同时针对每个 ensure条件依次测试，对于违反条件的情况依次返回不同的错误值，这样也方便 Debug，最后，只要 assertEquals(0, judge(beforeEmojis, beforeMessages, afterEmojis, afterMessages, limit, result));即可完成正确性的判断。 借由 OKTest的思想，我们能够对于每一个 ensure条件都进行测试的撰写，保证了标程的**“万无一失”**。 心得体会收获还是照例先谈谈这一单元的收获吧，在Unit3的学习中，我主要在以下三个方面有所收获： 复习了图论的相关算法，包括 BFS，并查集，Dijkstra等 初步学习了 JML，对于规格化设计有了初步了解。 了解了各种测试方法，并且重新捡起了在电梯单元无暇进行的评测机撰写。 一点吐槽先谈谈对于 JML的感受吧，在进行这一单元学习的同时，我读到了一个有趣的对于语言的吐槽，来自我在北外的学弟。我认为这十分契合我在Unit3的学习体会，决心一定要写进博客作业里。 JML像是在英汉对译的时候，先将中文翻译为法语，再把法语翻译成英文。我中文还好点，英文水平一般，法语则是完全不会。纵使说法语严谨到天花乱坠，对我来讲与鬼画符真没啥区别。谈及JML的优点，我确实无话可说，能与JML相遇是我的缘分，不过我希望这样的缘分越少越好。 当然，JML能够流传下来，传播甚广，一定是有其独到之处的。就像是那个经典的哲学辩题——被误解是不是表达者的宿命，我在想，如果哲学家辩论时能够使用 JML华山论剑，那想必答案已然明了，作为一种**“建模”语言**，JML最大的有点便是尽可能的减少了误解的存在。 但事实是否真的如此呢，JML显然不便于撰写，Unit3横跨五一假期，假期中我最担心的便是指导书和 JML标程的突然修改，因为这很有可能使我的假期泡汤，而这，在这一单元经常发生！！！ 第二则是评测机的“不确定性”，虽说课程组给出的时间限制是10s，但是在实际情况下，一旦本地运行超过1.8s，那么便很有可能发生 CTLE，这实在叫人胆战心惊，每一次点开强测结果都像是开盲盒，非常刺激😊。 最后还是感谢助教的辛勤付出，以上只是我的一点牢骚，我们也很能理解助教频繁修改指导书，JML背后的不易。只是，连助教团队在实际编写过程中都频繁出错的 JML是否有继续推广的价值呢，我认为值得商榷！！！","link":"/2025/08/13/OO-3/"}],"tags":[{"name":"OO","slug":"OO","link":"/tags/OO/"},{"name":"OS","slug":"OS","link":"/tags/OS/"}],"categories":[{"name":"大二下课上","slug":"大二下课上","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E4%B8%8A/"}],"pages":[{"title":"MathJax 数学公式测试","text":"🧮 MathJax 数学公式测试页面1. 行内公式测试这是一个行内公式：$E = mc^2$，爱因斯坦的质能方程。 另一个行内公式：$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$，高斯积分。 2. 块级公式测试二次方程求根公式： $$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ 欧拉公式： $$e^{i\\pi} + 1 = 0$$ 傅里叶变换： $$F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$$ 3. 复杂公式测试矩阵乘法： $$\\begin{pmatrix}a &amp; b \\c &amp; d\\end{pmatrix}\\begin{pmatrix}e &amp; f \\g &amp; h\\end{pmatrix} =\\begin{pmatrix}ae+bg &amp; af+bh \\ce+dg &amp; cf+dh\\end{pmatrix}$$ 积分方程： $$\\int_{0}^{1} \\frac{x^n}{1+x} dx = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{n+k+1}$$ 极限公式： $$\\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n = e$$ 4. 中文混合公式测试当 $x \\to 0$ 时，$\\sin x \\approx x$，这是正弦函数在原点附近的线性近似。 对于任意实数 $a$ 和 $b$，都有：$(a+b)^2 = a^2 + 2ab + b^2$ 5. 特殊符号测试希腊字母： $\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\zeta, \\eta, \\theta$ 数学符号： $\\sum, \\prod, \\int, \\oint, \\nabla, \\partial, \\infty$ 关系符号： $\\leq, \\geq, \\neq, \\approx, \\equiv, \\propto$ 如果上面的数学公式都能正确显示和居中，说明 MathJax 配置成功！","link":"/math-test.html"},{"title":"功能测试页面","text":"🧪 功能测试页面 /* 内联样式测试 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background:rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"success\"] { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"warning\"] { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 内联JavaScript测试 document.addEventListener('DOMContentLoaded', function() { console.log('内联JavaScript加载成功！'); // 处理警告框 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; console.log('处理警告框:', calloutType); } } }); }); 1. 颜色类测试这是CadetBlue颜色的文本 这是蓝色文本 这是绿色文本 这是红色文本 这是橙色文本 这是紫色文本 2. 警告框测试 [!IMPORTANT]这是一个重要的警告框测试 [!CAUTION]这是一个注意提示框测试 [!NOTE]这是一个提示信息框测试 [!SUCCESS]这是一个成功信息框测试 [!WARNING]这是一个警告信息框测试 3. 强调文本测试这是强调文本 这是警告文本 这是成功文本 这是错误文本 如果上面的样式都正常显示，说明内联样式和JavaScript工作正常！","link":"/test.html"},{"title":"About Me","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 👋 你好，我是 RooKie_Z🎓 个人简介我是一名北京航空航天大学的计算机科学与技术专业的本科生，对人工智能、软件工程、编译器技术等方向有着浓厚兴趣。在学习过程中，我注重理论与实践结合，参与过多项课程项目与科研实习，积累了扎实的编程能力和项目管理经验。 🚀 技术栈 编程语言: C++, Java, Python, JavaScript, Go 开发工具: IntelliJ IDEA, CLion, PyCharm, GoLand, VS Code 框架与技术: Django, Qt, Vue.js, Pytorch, Hexo 数据库: MySQL 操作系统: Linux, macOS, Windows 📚 学习与实践 面向对象设计与构造 (OO): 担任课程助教与高阶助教，负责命题与指导学生项目实现。 科研实习: 参与大语言模型越狱攻击研究，积累了人工智能安全方向的实验与分析经验。 软件工程项目: 担任“科研文献助手”项目经理及AI功能负责人，带领团队完成从需求分析到功能实现的全流程，并与导师合作推进项目迭代。 🏆 荣誉与奖项 多次获得校级奖学金与学科竞赛奖项 全国大学生英语竞赛北京市二等奖 全国大学生数学竞赛北京市一等奖 美国大学生数学建模竞赛 Meritorious Winner 互联网+北京赛区三等奖 🌟 兴趣爱好 算法与编程竞赛 开源项目贡献 技术写作与分享 阅读与探索新技术 💌 联系方式 GitHub: RooKie_Z 邮箱：RooKie_Z 博客: RooKie_Z的小窝 💡 座右铭 “Ever tried, Ever failed, No matter. Try again, Fail again, Fail better.” —— 塞缪尔·贝克特 感谢访问我的博客！如果你对我的项目或技术文章有任何问题或建议，欢迎随时交流。","link":"/about.html"},{"title":"","text":"// Callout 警告框增强器 (function() { function enhanceCallouts() { // 查找所有 blockquote 元素 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { // 检查第一个段落是否包含 callout 标记 const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; // 匹配 [!TYPE] 格式 const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); // 添加 data-callout 属性 blockquote.setAttribute('data-callout', calloutType); // 移除第一个段落中的 [!TYPE] 标记 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; // 添加图标和标题 const calloutHeader = document.createElement('div'); calloutHeader.className = 'callout-header'; calloutHeader.style.cssText = ` display: block; font-weight: bold; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; `; // 根据类型设置样式 const calloutConfig = { important: { icon: '⚠️', text: '重要', color: '#7835dc' }, caution: { icon: '⚠️', text: '注意', color: '#b8860b' }, note: { icon: 'ℹ️', text: '提示', color: '#17a2b8' }, success: { icon: '✅', text: '成功', color: '#28a745' }, warning: { icon: '🚨', text: '警告', color: '#fd7e14' } }; const config = calloutConfig[calloutType]; if (config) { calloutHeader.innerHTML = `${config.icon} ${config.text}`; calloutHeader.style.color = config.color; // 在第一个段落之前插入标题 firstParagraph.parentNode.insertBefore(calloutHeader, firstParagraph); } } } }); } // 页面加载完成后执行 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', enhanceCallouts); } else { enhanceCallouts(); } // 如果页面使用了PJAX，需要重新执行 if (window.pjax) { document.addEventListener('pjax:end', enhanceCallouts); } // 监听动态内容变化 const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if (mutation.type === 'childList' && mutation.addedNodes.length > 0) { enhanceCallouts(); } }); }); // 开始观察 observer.observe(document.body, { childList: true, subtree: true }); })();","link":"/js/callout-enhancer.js"},{"title":"","text":"// Giscus评论系统加载脚本 (function() { // 等待页面完全加载 function initGiscus() { // 检查是否在文章页面 const isArticlePage = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || window.location.pathname.includes('/2025/'); if (isArticlePage) { console.log('检测到文章页面，正在加载Giscus评论系统...'); // 检查是否已经加载过评论 if (document.getElementById('giscus-comments')) { console.log('评论系统已存在，跳过重复加载'); return; } // 创建Giscus容器 const giscusContainer = document.createElement('div'); giscusContainer.id = 'giscus-comments'; giscusContainer.style.marginTop = '40px'; giscusContainer.style.padding = '20px'; giscusContainer.style.borderTop = '1px solid #eaecef'; giscusContainer.style.background = '#ffffff'; giscusContainer.style.borderRadius = '8px'; giscusContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)'; // 添加加载状态 giscusContainer.innerHTML = ` 💬 评论 🔄 正在加载评论... `; // 查找文章内容区域并插入评论框 const articleContent = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || document.querySelector('main') || document.querySelector('article'); if (articleContent) { articleContent.appendChild(giscusContainer); // 延迟加载Giscus脚本，确保页面完全渲染 setTimeout(function() { try { // 加载Giscus脚本 const script = document.createElement('script'); script.src = 'https://giscus.app/client.js'; script.setAttribute('data-repo', 'rookie-zgy1513/rookie-zgy1513.github.io'); script.setAttribute('data-repo-id', 'R_kgDOKRlxNA'); script.setAttribute('data-category', 'General'); script.setAttribute('data-category-id', 'DIC_kwDOKRlxNM4CuKH8'); script.setAttribute('data-mapping', 'pathname'); script.setAttribute('data-strict', '0'); script.setAttribute('data-reactions-enabled', '1'); script.setAttribute('data-emit-metadata', '0'); script.setAttribute('data-input-position', 'bottom'); script.setAttribute('data-theme', 'preferred_color_scheme'); script.setAttribute('data-lang', 'zh-CN'); script.crossOrigin = 'anonymous'; script.async = true; // 脚本加载成功后的处理 script.onload = function() { console.log('Giscus脚本加载成功'); // 移除加载状态 const loadingElement = giscusContainer.querySelector('.giscus-loading'); if (loadingElement) { loadingElement.remove(); } }; // 脚本加载失败的处理 script.onerror = function() { console.error('Giscus脚本加载失败'); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败，请刷新页面重试 `; }; giscusContainer.appendChild(script); } catch (error) { console.error('加载Giscus时发生错误:', error); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败: ${error.message} `; } }, 1500); // 延迟1.5秒加载 } else { console.warn('未找到文章内容区域，无法加载评论系统'); } } else { console.log('非文章页面，跳过评论系统加载'); } } // 多重检查确保页面加载完成 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGiscus); } else { // 如果DOM已经加载完成，等待一小段时间再执行 setTimeout(initGiscus, 100); } // 额外检查，确保在Icarus主题完全加载后执行 window.addEventListener('load', function() { setTimeout(initGiscus, 500); }); // 如果页面使用了PJAX，需要重新初始化 if (window.pjax) { document.addEventListener('pjax:end', function() { setTimeout(initGiscus, 300); }); } })();","link":"/js/giscus.js"},{"title":"","text":"/* 自定义颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #7835dc !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-pink { color: #e83e8c !important; } .text-gray { color: #6c757d !important; } .text-dark { color: #343a40 !important; } /* 强调文本 */ .text-emphasis { color: #007bff; font-weight: bold; } /* 警告文本 */ .text-warning { color: #ffc107; font-weight: bold; } /* 成功文本 */ .text-success { color: #28a745; font-weight: bold; } /* 错误文本 */ .text-danger { color: #7835dc; font-weight: bold; } /* 文章摘要样式 */ .article-excerpt { background: #f8f9fa; border-left: 4px solid #007bff; padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0; } .article-excerpt p { margin: 0; color: #6c757d; font-style: italic; } /* 封面图片样式 */ .article-cover { width: 100%; max-height: 300px; object-fit: cover; border-radius: 8px; margin-bottom: 20px; } /* 阅读更多按钮样式 */ .read-more { display: inline-block; background: #007bff; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; margin-top: 10px; transition: background-color 0.3s; } .read-more:hover { background: #0056b3; color: white; text-decoration: none; } /* 文章底部标签和分类样式 */ .article-tags, .article-categories { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff; } .article-tags h4, .article-categories h4 { margin: 0 0 10px 0; color: #495057; font-size: 16px; font-weight: 600; } .article-tags .tag, .article-categories .category { display: inline-block; background: #007bff; color: white; padding: 4px 12px; margin: 2px 4px 2px 0; border-radius: 20px; font-size: 12px; text-decoration: none; transition: all 0.3s ease; } .article-tags .tag:hover, .article-categories .category:hover { background: #0056b3; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); } .article-categories .category { background: #28a745; } .article-categories .category:hover { background: #1e7e34; } /* 文章元信息样式 */ .article-meta { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #6c757d; } .article-meta .meta-item { display: flex; align-items: center; gap: 5px; } .article-meta .meta-item i { color: #007bff; width: 16px; } /* Giscus评论系统样式 */ #giscus-comments { margin-top: 40px; padding: 20px; background: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #eaecef; } #giscus-comments h3 { margin: 0 0 20px 0; color: #24292e; font-size: 20px; font-weight: 600; text-align: center; } /* 评论加载状态 */ .giscus-loading { text-align: center; padding: 40px; color: #6a737d; } .giscus-loading::before { content: \"🔄 正在加载评论...\"; font-size: 16px; } /* 评论区域响应式设计 */ @media (max-width: 768px) { #giscus-comments { margin: 20px 10px; padding: 15px; } #giscus-comments h3 { font-size: 18px; } } /* Callout 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } /* IMPORTANT 警告框 */ blockquote[data-callout=\"important\"], blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\")) { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before, blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\"))::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* CAUTION 警告框 */ blockquote[data-callout=\"caution\"], blockquote:has(> p:first-child:contains(\"[!CAUTION]\")) { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before, blockquote:has(> p:first-child:contains(\"[!CAUTION]\"))::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* NOTE 提示框 */ blockquote[data-callout=\"note\"], blockquote:has(> p:first-child:contains(\"[!NOTE]\")) { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before, blockquote:has(> p:first-child:contains(\"[!NOTE]\"))::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* SUCCESS 成功框 */ blockquote[data-callout=\"success\"], blockquote:has(> p:first-child:contains(\"[!SUCCESS]\")) { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before, blockquote:has(> p:first-child:contains(\"[!SUCCESS]\"))::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* WARNING 警告框 */ blockquote[data-callout=\"warning\"], blockquote:has(> p:first-child:contains(\"[!WARNING]\")) { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before, blockquote:has(> p:first-child:contains(\"[!WARNING]\"))::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* 移除第一个段落的 [!TYPE] 标记 */ blockquote p:first-child { margin-top: 0; } /* 响应式设计 */ @media (max-width: 768px) { blockquote { margin: 15px 10px; padding: 12px 16px; } blockquote::before { font-size: 12px; } } /* MathJax 样式优化 */ .MathJax_Display { text-align: center !important; margin: 1em auto !important; } .MathJax { outline: none; } /* 行内公式样式 */ .MathJax_Display .MathJax { text-align: center !important; } /* 块级公式容器 */ .MathJax_Display { display: block !important; text-align: center !important; margin: 1em auto !important; } /* 确保公式不被截断 */ .MathJax_Display .MathJax { overflow-x: auto; overflow-y: hidden; } /* 响应式设计 */ @media (max-width: 768px) { .MathJax_Display { margin: 0.5em auto !important; } } mjx-container[display=\"true\"] { display: block !important; text-align: center !important; margin: 1em auto !important; } mjx-container[display=\"false\"] { display: inline-block !important; } /* 列表页/首页摘要中的警告框覆盖 */ article.media .media-content .content blockquote, .article-excerpt .content blockquote { background: rgba(2, 215, 242, 0.15) !important; /* 蓝色半透明背景，符合 cyberpunk */ border: .5px solid #02d7f2 !important; border-left: 5px solid #02d7f2 !important; } /* 文字颜色提亮，避免被通用文字色覆盖 */ article.media .media-content .content blockquote, article.media .media-content .content blockquote p, article.media .media-content .content blockquote * , .article-excerpt .content blockquote, .article-excerpt .content blockquote p, .article-excerpt .content blockquote * { color: #ffffff !important; font-weight: 500 !important; text-shadow: 0 0 2px rgba(0,0,0,.6) !important; } /* 分类型：IMPORTANT / CAUTION / NOTE */ article.media .media-content .content blockquote[data-callout=\"important\"], .article-excerpt .content blockquote[data-callout=\"important\"] { background: rgba(149,97,210,.22) !important; /* 紫色半透明 */ border-left-color: #02d7f2 !important; } article.media .media-content .content blockquote[data-callout=\"caution\"], .article-excerpt .content blockquote[data-callout=\"caution\"] { background: rgba(255,142,60,.22) !important; /* 橙色半透明 */ border-left-color: #ff8e3c !important; } article.media .media-content .content blockquote[data-callout=\"note\"], .article-excerpt .content blockquote[data-callout=\"note\"] { background: rgba(2,215,242,.20) !important; /* 蓝色半透明 */ border-left-color: #02d7f2 !important; } /* 标题行（::before）提亮 */ article.media .media-content .content blockquote[data-callout]::before, .article-excerpt .content blockquote[data-callout]::before { color: #02d7f2 !important; text-shadow: 0 0 4px rgba(2,215,242,.6) !important; }","link":"/css/custom.css"}]}