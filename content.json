{"posts":[{"title":"OO第一单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 前言复杂度分析使用IDEA的 MetricsReloaded插件 代码规模分析利用IDEA的 static插件 UML类图使用IDEA绘图，再自行调整 任务概览作业要求 作业1：根据形式化定义解析输入的表达式，输出恒等变形展开括号后的表达式。 作业2：形式化定义加入指数函数和自定义函数。 作业3：支持自定义函数嵌套并加入求导算子。 第一次作业第一次作业为对包含幂函数与常数的表达式进行化简，涉及相对简单的嵌套，UML类图如下所示。 架构分析通过分析 Expr与 Term的结构。我们不难发现，一个基本的 Expr可以看成又一个个基元构成，即 $$Expr = \\sum a \\times x ^ b$$ 数据存储上，依照形式化表达设计为 Expr-&gt;Term-&gt;Factor。Parser和 Lexer作为工具类，分别承担句法分析和词法分析的功能。 值得注意的是，架构中事实上没有区分 Num和 Power，而是将其统一为 Unit类，存储一个形如$a \\times x ^ b$的因子。 在读取和存储过程中，Parser和 Lexer合作，构建了一棵多叉表达式树。 Factor接口为因子类的公共接口，所有的因子都实现了这个接口，所有的非 Unit类通过 Poly，即多项式类进行运算，最后通过 Poly类调用 Unit类的 toString方法实现输出。 下图展示了这种读取和存储的过程的一个例子： 具体而言，获得答案的计算过程是和读取解析相解耦合的。在调用顶层 Expr对象的 extend()方法后，逐层向下调用 extend()方法，得到展开式。这其中，得益于 Unit类的统一性，每一层向上返回的都是一个 Unit对象的集合，达到了形式上和接口的统一。 复杂度分析本次作业部分方法复杂度如下图，其余方法复杂度较低，未在图中体现。 可以看到，Parser中的 parseFactor()方法复杂度较高，分析原因知，设计该方法时对于常数和幂函数的解析都全部列在其中，没有分别抽象为分别的方法；Unit中的 toString()方法复杂度较高，为了优化输出的长度导致特判较多，复杂度较高。 Method CogC ev(G) iv(G) v(G) Parser.parseFactor() 14 1 8 8 Parser.parseExpr() 8 1 6 6 expr.Unit.toString() 7 1 6 7 Lexer.next() 6 2 4 6 expr.Expr.extend() 6 2 6 6 expr.Poly.toString() 5 4 3 5 expr.Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 expr.Poly.multiUnit(Unit) 4 1 3 3 expr.Poly.Merge() 3 1 3 3 expr.Poly.adjustUnit() 3 3 2 3 expr.Poly.multiExpr(Poly) 3 1 3 3 Lexer.getNumber() 2 1 3 3 Parser.getExp() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 expr.Poly.Negate() 1 1 2 2 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Main.main(String[]) 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 expr.Expr.Negate() 0 1 1 1 expr.Expr.addTerm(Term) 0 1 1 1 expr.Expr.equals(Expr) 0 1 1 1 expr.Expr.setExp(BigInteger) 0 1 1 1 expr.Poly.Poly() 0 1 1 1 expr.Poly.add(Poly) 0 1 1 1 expr.Poly.createOne() 0 1 1 1 expr.Poly.unitMulti(Unit, Unit) 0 1 1 1 expr.Term.Negate() 0 1 1 1 expr.Term.addFactor(Factor) 0 1 1 1 expr.Unit.Negate() 0 1 1 1 expr.Unit.Unit(BigInteger) 0 1 1 1 expr.Unit.Unit(Type) 0 1 1 1 expr.Unit.canMerge(Unit) 0 1 1 1 expr.Unit.compareTo(Unit) 0 1 1 1 expr.Unit.getCoff() 0 1 1 1 expr.Unit.getExp() 0 1 1 1 expr.Unit.getType() 0 1 1 1 expr.Unit.merge(Unit) 0 1 1 1 expr.Unit.multiUnit(Unit) 0 1 1 1 expr.Unit.setCoff(BigInteger) 0 1 1 1 expr.Unit.setExp(BigInteger) 0 1 1 1 Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是没有处理$0$的输出；另一个是没有妥善处理表达式里的 \\t和空格。 同时，我在此次作业中设计并实现了一个自动化评测机，这对检验程序的正确性有不小的帮助，也帮助我实现了hack，详细的分析将在评测部分介绍。 总结“工欲善其事，必先利其器” 在写本次作业之初，我设计过很多架构，在设计阶段就推倒重来若干次。尽管在Pre中的冒险者游戏中已经我初步领会了面向对象的思想，但是面对较为抽象的表达式解析仍然显得捉襟见肘。 尽管如此，得益于 training部分提供的 Parser和 Lexer思路，我最终得以确定这个较为面向对象的设计。但是，这个架构依然存在相当的不足，在后面的迭代开发介绍中将会着重介绍。 第二次作业相比于第一次作业，第二次作业新增了自定义函数与指数函数相关的内容，同时支持嵌套括号的解析。 相比第一次作业，增加了 Func类处理自定义函数，同时增加了 Exp类处理指数函数，UML类图如下： 架构分析相较于上一次作业以及未来的第三次作业，本次作业的工作量无疑是最大的，也难怪纪一鹏老师说这次作业很有可能会是本学期OO的难度巅峰。 对于本次作业的两个新增要求，我先完成了自定义函数的实现，再完成了指数函数的部分。 自定义函数部分自定义函数分为两个部分，一是读入，二是调用。 有关读入，由于函数定义式依然符合我们的多项式语意，且定义式内不允许循环定义，故而直接沿用上一次的 Lexer和 Parser来解析。 有关调用，我在读入表达式时，就建立了参数与实参的Map，在解析时利用Map中的Map.Entry接口进行替换，效果不错，但是相较正则表达式替换的方法，虽然正确性上有保障，但是时间复杂度较高。 指数函数部分通过分析本次式子可知，本次基元有所更新 $$Expr = \\sum a \\times x ^ b \\times exp(Factor) ^ c$$ 由于指数函数的特殊性，故我直接在初始化指数函数时直接将基元变形成如下式子，便于后续计算： $$Expr = \\sum a \\times x ^ b \\times exp(Factor \\times c)$$ 同样，我利用Poly类的 toString方法和String类的equals方法判断exp内的Factor是否相等，来进行后续合并。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 19 1 12 12 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Unit.setExp(BigInteger) 10 1 4 8 Lexer.next() 9 2 5 7 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Poly.unitMulti(Unit, Unit) 4 1 5 5 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Poly.adjustUnit() 3 3 2 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Main.main(String[]) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.clone() 0 1 1 1 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 可以看出，本次架构在Term类中实现自定义函数的替换部分的 replace方法复杂度极高，在Debug过程中，也同样是这个方法耗去了我大量的时间，可见越复杂，越易错！！！ Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是对于exp的括号化简出错；另一个是自定义函数中exp函数替换出错。 在本次hack过程中，我着重查看了同屋同学代码架构的复杂程度进行了分析，对于明显架构复杂的代码进行hack，都得到了成功。 具体的hack方法则是利用cxc同学的评测机，对于可疑代码进行评测，得到错误输出后针对数据进行化简使其符合互测数据限制，最终hack成功。 总结第二次作业是我在第一单元中花费时间最长的一次，尤其是指数函数的引入与化简合并，在Debug时给我造成了不小的困难，由于在完成本次作业时流感发烧，因此我在优化方面仅仅做了合并同类项和去exp函数的多余括号，但性能分上取得了 97.5分，可以说是十分侥幸的。同时，由于储存基元时采用了ArrayList，因此在合并同类项与Unit运算时被迫使用深克隆，而由于身体状态不佳，处于正确性考虑，我大量使用克隆，这也使我的程序运行时间大大增长。 第三次作业本次作业引入了求导因子。本以为是最痛苦的一集，没想到成了最速的一集。UML类图如下所示： 架构分析与第二次作业相比，本次作业架构几乎没有发生变化，没有引入新的类。对于求导操作，与求字符串相似，在每一个相关的类中引入getDerivative()方法，返回Poly多项式类。对于带函数的求导，采用将自定义函数完全展开后再进行求导的方法。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 20 1 13 13 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Lexer.next() 10 2 6 8 Unit.setExp(BigInteger) 10 1 4 8 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Main.main(String[]) 5 3 4 5 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Parser.parseDerivative() 3 1 4 4 Poly.adjustUnit() 3 3 2 3 Poly.compareTo(Poly) 3 3 3 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.clone() 2 1 1 2 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Unit.getDerivative(Type) 2 1 3 3 Exp.getDerivative(Type) 1 2 1 2 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.getDerivative(Type) 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Poly.toTerms() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Expr() 0 1 1 1 Expr.Expr(Poly) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.getDerivative(Type) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.addUnit(Unit) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Poly.unitMulti(Unit, Unit) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 Unit.simpleClone() 0 1 1 1 与第二次作业中复杂度较高的方法相同，原因一致。 Bug分析本次作业在强测中未出现Bug，但是在互测中由于TLE中刀，原因正如我在第二次作业总结中写的那样——无脑克隆，而克隆方法本身需要递归，导致最终超时，这也是由于我个人的侥幸心理，认为互测数据不强，在明知有超时风险时，选择写OS作业，未进行优化。虽然强测侥幸过关，但是在互测中还是漏了马脚，果然还是这个道理。 She was still too young to know that life never gives anything for nothing, and that a price is always exacted for what fate bestows. 那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。 ——茨威格 总结第三次作业不仅没有想象中可怕，还是三次作业中耗时最少的一次。得益于层次化结构的设计，新增求导运算的升级过程非常顺利，唯一的注意点是数学上的求导法则，需要在编码时严格遵守。只是可惜我的侥幸心理导致互测中刀，现在想来仍然感到深深可惜！！！ 测试本单元由于身体状况与个人时间的关系，只在第一次作业搭建了评测机，后续使用了cxc同学的评测机，这里再次感谢cxc同学！！！ 在个人搭建评测机的过程中，我主要还是使用模拟递归下降的过程构建测试数据，并利用 Python中的 Sympy包来达到化简表达式并判断正误的效果，唯一的缺点是速度太慢。同时，我在构建评测数据时特意加入了诸如 x-x,+00000等数据，来保证随机生成数据的特殊性，但是只是可惜评测机hack效果不佳，更多还是靠手动构建数据。 心得体会第一单元就这样痛并快乐地坚持了过去，但是和同学们投入的时间相比，我好像完成得还算轻松（?） 通过表达式解析的练习，我深刻体会了面向对象的设计思想，了解了递归下降的解析方法，初步尝试了层次化的类设计，这也为OS的Lab1提供了一些帮助。 最后还是感慨：设计为先，一个好的设计能为后续的编码工作省去不少麻烦；就比如，每次作业前，我都要花上一天半来进行设计，而不是基于上手编码，否则代码必然是漏洞百出。此外，还必须注重可扩展性，即在当前设计中打一个提前量，给未来可能引入的设计提前预留一些空间。 打个比方，我的程序在第一次就支持括号嵌套，第二次就支持自定义函数嵌套，现在第三次作业的程序还支持多变量运算与求导等等。 未来方向总体而言，我认为课程组对于第一单元的设置已相对完备，但是第三次作业相较前两次明显过于轻松，我认为可以加入多变量运算与求导等要求。同样，我认为强测应该设置专门数据来卡时间复杂度，这样就能狠狠整治向我这样心存侥幸的同学！！！","link":"/2025/08/13/OO-1/"},{"title":"OO第二单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 如果要让我对这充满坎坷的“电梯月”做一个总结，我认为贝克特的这一句名言无疑是最贴切的： [!IMPORTANT] Ever tried,Ever failed,No matter.Try again,Fail again,Fail better. –塞缪尔·贝克特 事实上，如果你碰巧是一名文学爱好者，那么你可能很难相信以荒诞文学闻名的贝克特会说出这样励志的名言。正如在真正完成这一单元之前，我也不会想到自己会在面对多线程层出不穷的Bug时，依然坚持”Fail again, fail better”。 前言第二单元我们要实现的是基于共享数据的，多线程电梯调度问题，在这一过程中，要迭代出电梯重置，双轿电梯等功能。相比第一单元，在第二单元的设计工作中，我深刻感受到了设计架构的重要性，以及多线程并行计算的优势。 整体架构图UML图由于是迭代开发，在这张UML图上我们可以看到这一路的过程。 白色的部分代表第一次作业。 绿色的部分代表第二次作业的增添。 紫色的部分代表第三次作业的增添。 时序图 设计架构开发历程 [!CAUTION] 第二单元的架构开发，我想多介绍一些， 对比第一单元作业，性能不在是实实在在的需求，而是相对虚无缥缈的东西。在保证正确性的前提下，不进行任何性能优化，也能有不错的性能分，因此架构占据了绝对的主导作用。 关于方法的复杂度就放在最后一起分析了。 作业要求：第二单元的任务为模拟群控电梯调度，重点在于多线程并发的设计。以下是任务的迭代：· hw5模拟了6部电梯的调度，乘客的请求会指定特定电梯· hw6的乘客可以自由分配给任意一部电梯，电梯需要输出已接收信号。同时增加了电梯参数的重置，重置时会暂停并处于静默状态· hw7增加了分裂为双轿厢的重置模式，需要在换乘层进行协调 hw5同步块和锁第一次作业，同时也是首次进行多线程编程，完成作业的大部分时间都放在了理解什么是多线程，以及什么是同步块上。 那么什么是同步块呢？简单来说就是，随便找点什么，多个类共用（指的是多个线程在同一时刻共同访问），套上 synchronized关键字。同步块的效果是什么？套上 synchronized关键字之后，在每一个时刻只能有一个线程访问。什么是锁？锁是当多个线程竞争同一个共享数据的时候，不让其他线程访问的重要武器。在 synchronized之外，还可以通过重入锁，读写锁等方式实现灵活的上锁。 由于第一次作业要求实在太过简单，六台电梯分别有自己对应的乘客，因此只需将总请求池上锁即可，同时在电梯需要进行 sleep()时给电梯上锁，确保其状态不受改变就可以保证线程安全，具体细节上采用 ReentrantLock即可实现，无需多言。 调度器和调度策略由于第一次不涉及“电梯抢人”的问题，所以无需设计调度器以及调度策略。 电梯运行算法采用的是 LOOK运行算法，也是日常生活中的电梯算法，即顺带接人运行策略，略微不同的地方是，现实中，在乘客进入电梯前，我们是不知道乘客的目的地的。但在本单元的作业中，人不是线程而是一个 Object，不仅方便了调度器的分配，而且降低了复杂度。 hw6同步块和锁与第一次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。 调度器和调度策略调度器采用**影子电梯**策略，即算出局部最优解分配给6个线程。具体做法是对电梯和该电梯的处理队列进行深克隆，调用克隆后的 shadowElevator.move()实现模拟推进时间，遍历6个电梯，找出能够使得新请求加入后整体运行时间结束最早的那一种加入请求算法。 为方便说明，举例如下图所示：绿色方块为电梯原有请求完成需要花费时间，每一列为一种分配策略对应各个电梯用时（共六种，即把新请求分配给六个电梯，分别遍历），找出该策略下用时最久的电梯为该策略对应的全局任务完成时间，再将六个策略的时间找出最短的，就获得了局部最优解。下图的情况即为将新请求加入3号电梯是局部最优解。 注：示例图片来自武彬煦学长的博客 这样，调度器成为了线程，调度器和输入线程之间，调度器和各个电梯之间，通过一个等待队列连接。 这样的策略可以做到局部时间最优，由于本人的懒惰，并未在影子电梯的指标中加入耗电量的考量。 hw7同步块和锁与第二次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。事实上，这只是我粗浅的理解，让我在互测中身中15刀 [!CAUTION] 事实上，由于我的设计中，DC Reset要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException😭 调度器和调度策略调度器依旧采用**影子电梯**策略，由于这次存在双轿厢电梯，而影子电梯无法模拟换乘，因此在计算电梯结束时间时，对于双轿厢电梯中无法直达的请求，采取惩罚补时，来进行粗略模拟，效果还可以。 双轿厢电梯安全控制在设计这次作业时OS正好在学信号量，事实上，换乘楼层只允许一个轿厢停靠，本质上就是一种信号量操作，而最大值为一的信号量实际上就是一把锁，两轿厢要进入换乘楼层时尝试获得锁，离开换乘楼层时释放锁即可。 具体代码上通过设置 Police类来监管双轿厢： 123456789101112131415161718192021222324252627public class Police { private boolean occupied = false; public synchronized void getAccess(Character type) { tryAccess(type); occupied = true; notifyAll(); } private synchronized void tryAccess(Character type) { notifyAll(); while (occupied) { try { wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } public synchronized void release() { occupied = false; notifyAll(); }} 稳定和易变稳定：稳定的内容主要还是电梯的捎带一直采取 LOOK算法，保证了绝大多数情况下电梯平均性能的优越性。同时在二三次作业中都采取了影子电梯模拟的调度策略，改变不大。 易变：乘客需求，电梯的类型每次作业都在改变，而这些都是通过 Reset指令实现的，如何妥善实现这些指令也正是本单元的设计重点。 结束的条件也随之变化，从每个电梯自己结束，到调度器统一分配结束。 BUG分析hw5第五次作业较为简单，在本地编写代码以及线上测试时都未发现Bug hw6第六次作业在编写时遇到的最主要的Bug在于线程无法安全结束，原因在于与第五次作业不同，在第六次作业中调度器是作为一个线程存在的，因此要确定它和电梯线程结束的顺序就成为了Bug产生的重灾区，最终也是通过不断通过评测机测试得到错误数据再通过 Print大法来查看线程具体结束情况最终解决Bug。 在互测中产生了一个Bug，原因是在五台电梯 Reset时会将所有请求分给一台可以使用的电梯，最终导致 RTLE。只要在只有一台电梯不在 Reset时让调度器等一等就行了，也不会轮询。 hw7第七次作业的Bug堪称最搞笑的一集。 强测中没出现Bug，但在互测中，由于我的设计在DC Rese时要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException，或者造成无法正常 Reset，导致CTLE，最终身中15刀。 解决办法是做 ArrayList&lt;Elevator&gt; elevators $\\to$ CopyOnWriteArrayList&lt;Elevator&gt; elevators的修改即可。 总结毫无疑问，对于多线程编程而言，Debug绝对是最痛苦，最耗时的部分。总结来看，一个好的架构往往能保证较高的Bug复现率。 而对于多线程Bug，除了 Print大法我深感无力，这也导致在强测结果出来前我一直保持着“先质疑，再质疑”的态度，好在最后强测都没出事，也算是万幸。 [!IMPORTANT] 还是那句老话，对于多线程测试，评测机上十万组正确数据都不如一个能稳定复现的Bug来的金贵和安心。 心得体会线程安全从单线程到多线程，性能上的巨大飞跃，必然带来的是设计上的复杂性，数据安全便是这方面的核心，但是更重要的是保证线程安全的同时，提高解决效率，不能长时间占有锁，更不能在 sleep的时候占有锁，要保证原子性，但一定要对同一时间的多条判断语句进行原子锁。 保证线程安全下的提高效率，真正的拉开了与单线程之间的差距，只注重数据的安全的结果往往是死锁，和轮询，这是要极力避免的。 层次化设计好的设计带来的优势在这一单元体现的淋漓尽致。正如前文所言，好的设计能够极大减少性能优化上的工作，以及提高本地测试时的Bug复现率，能够减少代码编写时的时间耗费。 “两天设计，一日编码”。这单元最好的工作流程就是这样，多线程编程设计细节颇多，如果无法在设计上提前规划这些细节，那么只会徒增Bug，白白浪费时间罢了。","link":"/2025/08/13/OO-2/"},{"title":"OO第三单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是一篇 OO Unit3助教当年对于U3的吐槽，现在看实在是回旋镖🪃满天飞啊🤣 测试过程黑箱测试与白箱测试通过查阅资料，我暂且给出黑箱测试与白箱测试的定义和方法。 黑箱测试也称功能测试、数据驱动测试或基于规格说明的测试。测试者只知道程序的输入、输出和系统的功能，这是从使用者的角度针对软件的接口、功能及外部结构进行的测试，不考虑程序内部实现逻辑。 白箱测试也称结构测试、逻辑驱动测试或基于程序本身的测试，测试程序内部结构或运行。在白箱测试时，从程序设计语言的角度来设计测试样例。测试者输入数据并验证数据在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。 了解了黑箱测试和白箱测试的定义后，我认识到虽然之前从未接触过这两个概念，但已经使用类似的方法开始测试了。 首先是白箱测试，从C语言程序设计课开始，我似乎就已经开始使用白箱测试了。对我来说，白箱测试的用处是在写完代码后确定程序中的每一步是否都是按照设想执行的，具体的实现方法往往是在每一行可能改变变量值的代码后都加上 printf()或 System.out.println()语句输出想要查看的变量值。我认为这种方法的效果与单步调试的效果相当，但更加简单直接、更加灵活且可用于多线程情况。 之后是黑箱测试，仅关注在给定功能要求和输入下的输出。这个也不陌生，各种课程组的评测机、自己写的评测机和对拍器以及本单元作业中出现的OKTest都是黑箱测试。 在日常使用中，对代码的测试往往是黑箱和白箱相结合的。以OS上机为例，在自认为完成要求后，我会先使用 make xxxx &amp;&amp; make run跑一下课程组的测试。测试代码往往是单独的一个文件，并在其内调用我写好的函数，通过 assert语句检查函数的返回值是否符合预期，这是黑箱测试。在这测试后，如果出现了问题，便需要具体检查函数的实现。这个过程既需要用人脑模拟代码的执行，又可以在多条关键语句前后加上 printk(), debugf()检查变量值的变化是否符合逻辑预期，碰到不符合预期的地方便是发现bug，可以开始修改了，改完之后便可以使用黑箱测试继续测试最终结果，若结果不对就继续白箱测试…… 单元测试等多种测试手段 单元测试：单元测试是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作，对面向过程的语言来说是测试函数，对面向对象的语言来说是测试类的行为。在第10次作业中，我构造大数据完全图对 qsp, qtvs, qtav, qba, qcs等指令进行了测试，这便是单元测试的应用。 功能测试：通过上面黑箱测试的介绍可知功能测试大概就是黑箱测试，不考虑程序内部结构而仅测试程序执行的结果。 集成测试：集成测试是指把多个程序模块放在一起测试的方法。由于每个模块都正确不一定能保证整个程序正确，在单元测试后把多个单元结合在一起测试的集成测试必不可少。从实际效果上来说，在第三单元的功能不断增加的迭代开发过程中，前一次作业中全面的强测就相当于下一次作业的集成测试。 压力测试：压力测试是针对系统或是组建，为确定其稳定性而特意进行的严格测试。我感觉压力测试的意义在于低压测试对不同情况的覆盖不完全，从而可能检查不出程序的潜藏问题，而高压测试通过大数据、高并发(如果是多线程)，可以尽可能枚举出各种情况，增大发现问题的概率。距离而言，在电梯单元中，自己造出的弱数据不一定能发现像是轮询、死锁之类的问题，而助教出的压力测试强数据以及评测机超多线程同时跑多份代码的情况则几乎可以发现绝大多数问题。 回归测试：回归测试旨在测试软件原有功能在修改后是否保持完整，这也是纪老师在课上多次提到的。举例而言，在OO每个单元的迭代中，在测试完某一次作业后，要保留好自己构造的测试样例，下次迭代开发之后继续使用。 数据构造策略在三次作业中，我尝试写了两种数据生成器，一个是针对各种指令的集成测试数据生成器，一个是针对 qtvs, qbs, qcs等指令的单元测试/压力测试生成器。单元测试生成器的逻辑比较简单，首先通过 ln构建一个完全图，然后加入一定数量的 tag，同时不断 ar, mr并且 qtvs，最后再一直 qtvs总计10000条数据来进行压力测试，考虑到 OO评测机的玄学属性，对于一切本地运行时间超过 1.6s的数据，进行分析，并且对于代码进行相应的优化。对于集成测试数据生成器，我原本想采用全部随机生成的方式，但发现这样生成的数据会有大量的异常，对于各种计数指令几乎起不到测试效果。于是我在生成器中维护了几个 id池以及关系池用来存放已经生成的数据，并在具体生成指令时，通过随机数判断生成会引起异常的指令或是不会引起异常的指令，这样生成的数据效果尚可。 架构与图模型在架构上，由于官方包已经给出了比较多且明确的要求和限制，我并没有做什么突破，不同类之间的层次关系都是按照官方包写的。而对于图模型的设计和维护则是本单元算法考察的重点。下面重点谈谈我在三次作业中的图模型设计。 图使用邻接表，即 Acquaintance构建。对于 qci和 qbs，hw9就涉及删边，故并不采用并查集等算法，在每次 qci时做 BFS，在加边/删边时BFS动态维护 qbs。对于 qts，在加边和删边时动态维护。对于 qba，对每个点开一个 TreeSet，在增/删/修改边权时，动态维护该点的 bestAc；对于 qcs，每次遍历所有点进行统计。 优化的重点在于 Tag中的方法，尤其是 qtvs方法，经过本地压力测试，发现如果不进行动态维护，而是使用 JML描述的直接查询的O($n^2$)的复杂度方法，则会 CTLE，因此必须在每次 att, dft,ar, mr的时候进行动态维护。 规格与实现分离及性能问题规格与实现分离在这个单元中，其实很能体会到规格与实现的分离，因为假如不分离，实现按着 JML来，便会因为性能不佳O($n^2$)甚至O($n^3$)的时间复杂度可不是闹着玩的😅而大把扣分。而为了实现规格与代码的分离，我认为要做以下两步。 第一步是通读 JML规格，把 JML的规格设计转换为自然语言，抽象为一些符合常识的描述。在面对一些复杂方法时，这一步尤为重要，因为 JML只描述规格，而我们写代码一般需要知道某个函数的意义(我认为一般人都没有在不知道意义的情况下直接把一堆通过遍历描述的方法转换为 dijkstra等较优算法的能力)。 第二步是根据抽象出来的自然语言描述选取合适的数据结构和算法，完成需要实现的功能。 实现中的性能问题我的代码在本单元三次作业的强测和互测中均未出现性能问题。究其原因，在于我在每一次阅读 JML时就对其中蕴涵的时间复杂度“陷阱”，在经过压力测试后采用动态维护，最终避免了 CTLE。通过上面规格与实现分离部分的讨论便可看出，规格和实现是可以分离的，而作为程序员，应该追求满足规格下的最优性能实现。但是否能达到很好的效果，则取决于程序员的知识积累与阅历。简单来说，如果知道更好的算法，就有可能写出性能更好的代码，否则仅凭规格就写不出来。 Junit测试Junit测试与充分诠释了“测不准原理”的 OO评测机共同构成了Unit3的两大梦魇，甚至在中测环节，Junit测试带来的压迫感远比程序正确性要大得多。 看着即将见底的提交剩余次数与随时可能测出问题的代码，和随机刷新的Junit测试 WA测试点，大家难免骂骂咧咧😡，汗流浃背😅。 那么，有没有办法系统性的解决这一问题呢，我认为是有的。我们发现，Junit测试重点关注两个部分——覆盖率高的测试数据，以及确保“万无一失”的标程。 构造覆盖率高的数据构造覆盖率高的数据技巧不高，在完成数据构造后，可以运用IDEA中的使用覆盖率运行test来进行分支覆盖率测试，最终不断完善，获得一组对目标方法分支覆盖率100%的测试数据。 撰写标程标程考察的无非以下几个条件： 检查 ensure； 检查 pure/assignable； 检查 invariant/constraint； 等等 在具体了解了这些条件后，我们其实可以借鉴 OKTest的方法来撰写标程，下面以 hw11中的 deleteColdEmoji()的测试为例来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int judge(HashMap&lt;Integer, Integer&gt; beforeEmojis, HashMap&lt;Integer, Integer&gt; beforeMessages, HashMap&lt;Integer, Integer&gt; afterEmojis, HashMap&lt;Integer, Integer&gt; afterMessages, int limit, int result) { for (int eid : beforeEmojis.keySet()) { if (beforeEmojis.get(eid) &gt;= limit &amp;&amp; !afterEmojis.containsKey(eid)) { //System.out.println(eid + &quot; &quot; + beforeEmojis.get(eid)); return 1; } } for (int eid : afterEmojis.keySet()) { if (!beforeEmojis.containsKey(eid) || !beforeEmojis.get(eid).equals(afterEmojis.get(eid))) { return 2; } } int cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeEmojis.entrySet()) { if (entry.getValue() &gt;= limit) { ++cnt; } } if (cnt != afterEmojis.size()) { return 3; } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() != null &amp;&amp; afterEmojis.containsKey(entry.getValue()) &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || !entry.getValue().equals(afterMessages.get(entry.getKey())))) { return 5; } } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || afterMessages.get(entry.getKey()) != null)) { return 6; } } cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null) { ++cnt; } else if (afterEmojis.containsKey(entry.getValue())) { ++cnt; } } if (cnt != afterMessages.size()) { return 7; } return result == afterEmojis.size() ? 0 : 8; } 可以看到，我们针对 JML中的 \\old条件设置了 before*的一系列数据点，同时针对每个 ensure条件依次测试，对于违反条件的情况依次返回不同的错误值，这样也方便 Debug，最后，只要 assertEquals(0, judge(beforeEmojis, beforeMessages, afterEmojis, afterMessages, limit, result));即可完成正确性的判断。 借由 OKTest的思想，我们能够对于每一个 ensure条件都进行测试的撰写，保证了标程的**“万无一失”**。 心得体会收获还是照例先谈谈这一单元的收获吧，在Unit3的学习中，我主要在以下三个方面有所收获： 复习了图论的相关算法，包括 BFS，并查集，Dijkstra等 初步学习了 JML，对于规格化设计有了初步了解。 了解了各种测试方法，并且重新捡起了在电梯单元无暇进行的评测机撰写。 一点吐槽先谈谈对于 JML的感受吧，在进行这一单元学习的同时，我读到了一个有趣的对于语言的吐槽，来自我在北外的学弟。我认为这十分契合我在Unit3的学习体会，决心一定要写进博客作业里。 JML像是在英汉对译的时候，先将中文翻译为法语，再把法语翻译成英文。我中文还好点，英文水平一般，法语则是完全不会。纵使说法语严谨到天花乱坠，对我来讲与鬼画符真没啥区别。谈及JML的优点，我确实无话可说，能与JML相遇是我的缘分，不过我希望这样的缘分越少越好。 当然，JML能够流传下来，传播甚广，一定是有其独到之处的。就像是那个经典的哲学辩题——被误解是不是表达者的宿命，我在想，如果哲学家辩论时能够使用 JML华山论剑，那想必答案已然明了，作为一种**“建模”语言**，JML最大的有点便是尽可能的减少了误解的存在。 但事实是否真的如此呢，JML显然不便于撰写，Unit3横跨五一假期，假期中我最担心的便是指导书和 JML标程的突然修改，因为这很有可能使我的假期泡汤，而这，在这一单元经常发生！！！ 第二则是评测机的“不确定性”，虽说课程组给出的时间限制是10s，但是在实际情况下，一旦本地运行超过1.8s，那么便很有可能发生 CTLE，这实在叫人胆战心惊，每一次点开强测结果都像是开盲盒，非常刺激😊。 最后还是感谢助教的辛勤付出，以上只是我的一点牢骚，我们也很能理解助教频繁修改指导书，JML背后的不易。只是，连助教团队在实际编写过程中都频繁出错的 JML是否有继续推广的价值呢，我认为值得商榷！！！","link":"/2025/08/13/OO-3/"},{"title":"OO第四单元总结暨课程总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z对于OO Unit4和课程总体的总结博客 正向建模与开发先简单介绍一下 正向建模与开发 的定义 正向建模与开发是一种根据给定的需求创建或制作应用程序的方法。正向建模与开发也被称为翻新和回收。正向建模与开发需要高水平的技能，它需要更多的时间来构建或开发应用程序。正向建模与开发是一种创建高层模型或设计的技术，以增加复杂性和低层信息。因此，这种工程在不同的软件和数据库过程中有不同的原则。正向建模与开发应用了所有的软件工程过程，包括软件开发生命周期（SDLC），以重新创建现有的应用程序。它是为了满足用户的新需求而进行重构的。 本单元的主题是 UML，正向建模与开发自然是最重要的一环，我个人也是按照课程组的指导，每次作业先做好建模设计再写代码。具体步骤如下： 通读指导书，记录需求重点和细节，并针对边界情况，各种功能编写各种样例 依据样例，整理项目逻辑，记录各个类的协作关系(类似于顺序图的要求) 依据整理的逻辑进行设计，画出类图草图和协作图草图 编写代码 使用 StarUml 软件参照画 uml 图 其实前几步在其他几个单元的作业中我也会做，毕竟在完全不做设计的情况下写代码是很难的。但是我认为在设计阶段就画仔细的 uml 图其实不太方便，因为 StarUml 细节比较多，要用鼠标点来点去，会分散设计阶段的注意力，但用纸和笔来画草图就很方便，而且还可以自己加各种提示在图中。所以我每次都是先画草图，再在全部写完以后用 StarUml画出最终的 uml 图。 放上一张 Unit1的设计图，也算是有始有终了🥳： ![](OO Unit1架构.jpg) 架构设计和UML模型设计之间的追踪关系本单元架构： 在这几次的作业中，为了做到高内聚，低耦合，我根据指导书的要求对于相应的对象都建了类，让他们各司其职。但是随着需求的增多以及复杂度要求更高，对于低耦合的实现就造成了很大的困难，尤其在 OrderRecord和 BorrowRecord两个类呈现出较大的耦合性。对于一致性方面，流程图以及状态图的实现都较简单，因此一致性较好。 架构设计思维的演进其实我感觉第一单元是架构设计最复杂的单元，因为表达式十分抽象，如果没有 training和实验，我甚至都不知道怎么设计各个类，导致架构设计的难度很高，所以我的架构设计能力基本是在第一单元中养成的。我设计架构以及写代码的核心思想就是追求简单，怎么简单怎么来。因为逻辑简单的代码更好把控，更不容易出 bug，即使真的出问题也很好定位。我在 1，2 单元中都进行了轻微重构，重构的方向都是把原来复杂一些的代码化简，即使这可能会牺牲一些性能或是架构的美观性。其实“面向对象性”和架构简单性的矛盾是我一直在思考的内容。以第四单元举例，如果想秉承模块化等思想，是应该把每个功能处拆成单个类来写的，而不是在图书馆类里面写多个组合函数。但更多的类、更多的包装会导致更多的函数嵌套调用或是对象的嵌套使用，这其实会增加代码逻辑上的复杂度，也可能会增加出问题时 debug 的难度，排查一个问题时可能需要跳转多个函数，且多个函数之间都可能出现问题。这个问题我一直没有一个清晰的答案，在几个单元的作业中，我认为代码逻辑简单更重要，但这种想法也不一定对。这个问题最终的答案我可能也要到后续的代码编写实践中获取了。 测试思维的演进其实在这四个单元中，我的测试思路没有什么变化，都是黑白箱结合的方式。一方面通过阅读代码梳理逻辑等方式进行白箱测试，另一方面编写评测机或者数据生成器进行测试或对拍。这种测试方法的优点是效果尚可，只要生成的数据强度过硬就能测出代码的 bug，同时结合一点编写针对性debug样例的技巧，能够快速地定位bug，便于后续debug。 具体而言： 第一单元，借用递归下降的优势，测试数据的生成，和程序的编写，都可以一同使用，采用了大量的随机数据与少数特殊数据因子相结合的构建方法。 第二单元，DPO😭狠狠的膜了。 第三单元，主要是随机数据，同时考虑查询数据的大量性，保证基本正确性的前提下，构建大量查询边界数据来测试 TLE。另外，还有 Junit测试。 第四单元，鉴于数据有极大的限制，前期边界条件的模糊，在没有保证自己评测会不会正确的前提下，后续参考张鑫和高鹏飞同学的评测机并加以魔改来完成评测。 课程收获 入宝山不要空手而归 其实在上 OO 课之前，我就已经听说过其大名了，知道 OO 很苦很累但是能学到不少东西。但实际体验的收获还是超乎我的想象。我竟然还在一个星期内学会了多线程，这种高效率的学习是我非常喜欢的。在这之前，我也自学过各种东西，但网上的教程总是学起来效率很低，且缺乏在指导下的大规模高效实践，导致学出来只能用来吹没法实干。但 OO 课程却完全解决了这个问题，OO 课通过高压的训练和适当的引导让我很快的发现解决问题所需的重点知识并掌握了它们，在 OO 课程的学习中，我还接触了很多面向对象和 Java 以外的有用的东西，比如 JML 与契约式编程或是非常使用的 UML还有通过python来搭建评测机。这些知识也让我受益匪浅。总而言之，通过 OO 课程的学习，我见识并掌握了很多各种各样的知识，练就了各种各样的能力，收获满满。最后，很感谢老师们和助教们长久以来的付出和对我的帮助，也注 OO 课程越办越好。 还是那句古训，无论艰难困苦，最后结果成功也好，失败也罢，莫以成败论英雄， 入宝山切莫空手而归！！！","link":"/2025/08/13/OO-4/"},{"title":"RooKie_Z challenge-shell实现报告","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 总述先上图，看看我的成品Shell 由于我选择的是Lab6的挑战性任务，整体的子任务数较多，故接下来的介绍顺序完全基于我的实现过程，如有不清楚之处，完全源于本人的能力不足，烦请各位看官海涵。 按照评测测试点，我的实现顺序为 $3 \\to 4 \\to 2 \\to 1 \\to 5$，接下来按照这种顺序介绍。 具体实现实现不带 .b 后缀指令spawn函数与 fork 函数类似，其最终效果都是产生一个子进程，不过与 fork函数不同的是，spawn 函数产生的子进程不再执行与父进程相同的程序，而是装载新的 ELF文件，执行新的程序。 事实上 spawn就是在尝试执行shell里的命令，所以在这里尝试追加执行是最佳位置。即当用户指定的程序路径不存在时，在这里尝试在路径后追加 .b 再打开。 具体代码： 123456789101112131415161718192021// user/lib/spawn.c spawnchar tmp[MAXPATHLEN]; if (prog[0] != '.') { strcpy(tmp, &quot;/&quot;); strcpy(tmp + 1, prog); } else { strcpy(tmp, prog); } int fd; fd = open(tmp, O_RDONLY); if (fd &lt; 0) { int len = strlen(tmp); strcpy(tmp + len, &quot;.b&quot;); fd = open(tmp, O_RDONLY); } if (fd &lt; 0) { return fd; } 实现反引号、注释和历史指令实现反引号实现反引号的思路实际上与引号类似，就是当 parsecmd调用 gettoken读到 `,后，进一步解析其后的字符串，直到另一个反引号位置，获取其中的字符串，直接 runcmd()，具体思路可见下面的示意图： 实际上，上述思路的实现尚不成熟，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142//sh.c gettokenif (*s == '`') { in_quot = !in_quot; }if (in_quot) { *p1 = s; while (*s &amp;&amp; ((in_quot &amp;&amp; !strchr(&quot;`&quot;, *s)) ||!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; } //sh.c parsecmdcase '`': debugf(&quot;clg: use `\\n&quot;); gettoken(0, &amp;t); char s[100]; strcpy(s, t); char ch = gettoken(0, &amp;t); ch = gettoken(0, &amp;t); if (ch == 0 || ch == '\\0') { runcmd(s); } else { if (ch == ';') { int fork1 = 0; fork1 = fork(); if (fork1) { wait(fork1); return parsecmd(argv, rightpipe, 1, job_flag); } else { runcmd(s); } } runcmd(s); } 实际上，在后来处理引号的时候，思路就很清晰了： 12345678910111213//sh.c gettokenif(*s == '`') { // 识别反引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '`')){ s++; } *s++ = 0; *p2 = s; return 'r'; //表示反引号} 实现注释实际上，注释的功能和读取空白符并无区别，较为简单，代码见下： 12345678910111213//sh.c gettoken*p1 = s; while (*s &amp;&amp; (!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; 由于历史指令的实现我使用了追加重定向的功能，故放到下文一并说 实现追加重定向和引号支持实现引号支持与上文反引号思路相同，直接给出代码： 123456789101112131415161718192021222324//sh.c gettokenif(*s == '\\&quot;') { // 识别引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '\\&quot;')){ s++; } *s++ = 0; *p2 = s; return 's'; // it means &quot;string&quot; }//sh.c parsecmdcase 's': if (argc &gt;= MAXARGS) { debugf(&quot;too many arguments\\n&quot;); exit(); } if (need) { argv[argc++] = t; } 实现追加重定向我的思路是添加一个新的写入方式，即追加 APPEND 123456//user/include/lib.h#define O_APPEND 0x0004//user/lib/file.c openif ((mode &amp; O_APPEND) != 0) { fd-&gt;fd_offset = size;} 因为我们的shell原本就支持对于 &gt;&gt;的解析，所以我们只需要在 parsecmd中稍作修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case '&gt;':; int cc; cc = gettoken(0, &amp;t); if (cc == '&gt;') { if (gettoken(0, &amp;t) != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_APPEND | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } else { if (cc != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } //argv[argc++] = t; //user_panic(&quot;&gt; redirection not implemented&quot;); re_alloc = 1; 这里的 re_alloc是一个全局变量，表示指令进行了重定向，在后续一行多指令的实现中起了作用。 实现历史指令由于我们已经实现了追加写入，那么保存命令就简单了： 1234567891011121314//sh.c save_cmdvoid save_cmd(char* cmd) { int r = open(&quot;/.mosh_history&quot;, O_CREAT | O_WRONLY | O_APPEND); if (r &lt; 0) { debugf(&quot;open /.mosh_history failed to save&quot;); return r; } write(r, cmd, strlen(cmd)); write(r, &quot;\\n&quot;, 1); return 0;}//sh.c main save_cmd(buf); 接下来就可以通过 history命令调取历史记录并输出： 1234567891011121314151617181920212223242526272829//sh.c rumcmd 实现内置指令if (strcmp(argv[0], &quot;history&quot;) == 0) { history(); }//sh.c historyvoid history() { int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed\\n&quot;); return; } char buf; int r; int cnt = 0; int newline = 1; while ((r = read(fdnum, &amp;buf, 1)) != 0) { if (newline) { debugf(&quot;%c&quot;, buf); cnt++; newline = 0; } else { debugf(&quot;%c&quot;, buf); } if (buf == '\\n') { newline = 1; } }} 实现指令回显由于这部分在评测中尚未涉及，故不多赘述，简单介绍原理 我们知道 Linux对于上下左右键的编码 上下左右键在linux中会被编码为 上： 27 ‘[’ ‘A’ 下： 27 ‘[’ ‘B’ 右： 27 ‘[’ ‘C’ 左： 27 ‘[’ ‘D’ 所以我们需要在读到27 [Esc]后连续读取两个字符以判断指令的类型,从而分别调用属于左右键和上下键的不同功能。 具体这部分代码部分参考了Charles学长的博客，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180int newDirCmd = 1;int offset; // 0:empty line, -1:last cmd, -2:...int solveDirCmd(char* buf, int type) { // type: 0 means up, 1 means down if (newDirCmd == 1) { offset = 0; } if (type == 0) { offset--; } else if (offset &lt; 0) { offset++; } int x = 0; if (offset == 0) { while (buf[x] != '\\0') { buf[x] = '\\0'; x++; } return -1; } int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed in sloveDir!\\n&quot;); return 0; } struct Fd* fd = num2fd(fdnum); char* c; char* begin = fd2data(fd); char* end = begin + ((struct Filefd*)fd)-&gt;f_file.f_size; c = end - 1; while (((*c) == '\\n' || (*c) == 0) &amp;&amp; (c &gt; begin)) { c--; } if (c == begin) { // no history cmd buf[0] = '\\0'; return 0; } c++; // last \\n or \\0 int i; for (i = 0; i &gt; offset; i--) { while ((*c) != '\\n' &amp;&amp; (*c) != '\\0') { c--; if (c &lt;= begin) { break; } } c--; if (c &lt;= begin) { break; } } offset = i; // avoid offset too bigger than real cmd num if (c &gt; begin) { while (c &gt; begin &amp;&amp; (*c) != '\\n') { c--; } if ((*c) == '\\n') { c++; } } else { c = begin; } int now = 0; while (buf[now] != '\\0') { buf[now] = '\\0'; now++; } now = 0; while ((*c) != '\\n' &amp;&amp; (*c) != '\\0' &amp;&amp; (*c) &lt; end) { buf[now] = *c; now++; c++; } return now;}#define MOVELEFT(y) printf(&quot;\\033[%dD&quot;, (y))#define MOVERIGHT(y) printf(&quot;\\033[%dC&quot;, (y))void readline(char* buf, u_int n) { /* TODO:lab6-challenge */ int r; int off = 0; int len = 0; char op; while (off &lt; n) { if ((r = read(0, &amp;op, 1)) != 1) { if (r &lt; 0) { debugf(&quot;read error: %d\\n&quot;, r); } exit(); } if (op == '\\b' || op == 0x7f) { /* TODO:lab6-challenge */ if (off &gt; 0) { if (off == len) { buf[--off] = 0; printf(&quot;\\033[D \\033[D&quot;); } else { for (int j = off - 1; j &lt; len - 1; j++) { buf[j] = buf[j + 1]; } buf[len - 1] = 0; MOVELEFT(off--); printf(&quot;%s &quot;, buf); MOVELEFT(len - off); } len -= 1; } // } else if (op == '\\r' || op == '\\n') { buf[len] = 0; return; } /* TODO:lab6-challenge */ else if (op == 27) { char tmp; read(0, &amp;tmp, 1); char tmp2; read(0, &amp;tmp2, 1); if (tmp == 91 &amp;&amp; tmp2 == 65) { debugf(&quot;\\x1b[B&quot;); // down to cmd line int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); // left to line head } debugf(&quot;\\x1b[K&quot;); // clean line off = solveDirCmd(buf, 0); len = strlen(buf); debugf(&quot;%s&quot;, buf); } else if (tmp == 91 &amp;&amp; tmp2 == 66) { int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); } debugf(&quot;\\x1b[K&quot;); off = solveDirCmd(buf, 1); len = strlen(buf); debugf(&quot;%s&quot;, buf); } /* TODO:lab6-challenge */ else if (tmp == 91 &amp;&amp; tmp2 == 67) { if (off &lt; len) { off++; } else { MOVELEFT(1); } } else if (tmp == 91 &amp;&amp; tmp2 == 68) { if (off &gt; 0) { off--; } else { MOVERIGHT(1); } } // newDirCmd = 0; } else { newDirCmd = 1; if (off == len) { buf[off++] = op; } else { // i &lt; len for (int j = len; j &gt; off; j--) { buf[j] = buf[j - 1]; } buf[off] = op; buf[len + 1] = 0; MOVELEFT(++off); printf(&quot;%s&quot;, buf); MOVELEFT(len - off + 1); } len += 1; } } debugf(&quot;line too long\\n&quot;); while ((r = read(0, buf, 1)) == 1 &amp;&amp; buf[0] != '\\r' &amp;&amp; buf[0] != '\\n') { ; } buf[0] = 0;} 由于同时监听了左右键，所以同时了实现键入命令时任意位置的修改实现了在当前光标位置进行字符的增加与删除。在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。 实现一行多指令shell的原理是 main 从控制台读取一行后 fork，把这一行命令传递给子进程。子进程执行完毕后退出，父进程调用 wait函数等待子进程执行结束被摧毁。 因为在 user/sh.c中的保留 SYMBOLS 里已经预留有 ; 字符，gettoken 函数本身就能够解析下一个 ; 字符，所以我们只需要将；作为一个特殊的token即可，我们无需改变词法部分，只需改变语法解释部分。 [!CAUTION] 注意，在实现一行多命令的过程中，务必考虑以下重定向样例 echo &quot;aaa&quot; &gt;&gt; file1; cat file1 如果在上条命令执行后未及时重定向回标准输出，则再进行一次 cat file1会发现 file1中写入了两个 aaa 下附代码： 1234567891011121314151617case ';':; if (need == 0) { return parsecmd(argv, rightpipe, 1, job_flag); } else { int child = fork(); // fork出两个进程 if(child) { // 父进程等待子进程执行完再执行';'右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } wait(child); return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行';'左边的命令 return argc; } } 实现更多指令touch没什么好说的，就创建文件就行了，下附代码： 12345678910111213141516171819202122232425#include &lt;lib.h&gt;void usage(void) { debugf(&quot;usage: touch file...\\n&quot;); exit();}int main(int argc, char *argv[]) { int fd; if (argc &lt; 2) { usage(); } for (int i = 1; i &lt; argc; i++) { if ((fd = open(argv[i], O_CREAT)) &gt;= 0) { close(fd); } else { printf(&quot;touch: cannot touch \\'%s\\': No such file or directory\\n&quot;, argv[i]); } } return 0;} rmrm指令需要解析其输入后的参数，如 -r, -f, -rf等等，我采用了全局变量来实现，同时编写了工具函数 isdir来判断要求的文件是不是目录: 123456789101112131415static void init(){ enableForce = 0; // -f enableRecursive = 0; // -r}int isdir(const char* path){ struct Stat st; if (stat(path, &amp;st) &lt; 0) return 0; return st.st_isdir;} 主体实现部分为两个函数 rm 和 _rm分别表示删除文件和目录，原理较为简单，rm调用 remove删除文件，_rm则通过遍历目标目录后不断递归调用自身，来实现对于目标目录的递归删除，下附代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void rm(const char* path){ int ret; struct Stat st; if ((ret = stat(path, &amp;st)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } if (st.st_isdir &amp;&amp; !enableRecursive) { printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); return; } if (st.st_isdir) _rm(path); ret = remove(path); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, path, ret);}static void _rm(const char* path){ char dir[MAXPATHLEN]; // open directory int fd; if ((fd = open(path, O_RDONLY)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } // get number of sub items int size; int ret; int is_dir; struct File file; while ((size = readn(fd, &amp;file, sizeof(struct File))) == sizeof(struct File)) { if (!file.f_name[0]) continue; strcpy(dir, path); strcat_(dir, &quot;/&quot;); strcat_(dir, file.f_name); is_dir = isdir(dir); if (is_dir) { if (!enableRecursive) printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); else _rm(dir); } ret = remove(dir); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, dir, ret); }} mkdirmkdir是这3个指令中最麻烦的一个，考虑到 -p指令的特殊性，为实现这一条指令，新增了不少工具函数： 12345678910111213141516171819202122232425262728293031323334//user/include/fsreq.hstruct Fsreq_create{ char req_path[MAXPATHLEN]; u_int req_omode;}; //表示创建目录//fs/fs.cint file_creat(const char* path, u_int omode, struct File** pfile){ char name[MAXNAMELEN]; struct File* dir; struct File* f; int ret; if ((ret = walk_path(path, &amp;dir, &amp;f, name)) == 0) return -E_FILE_EXISTS; if ((ret != -E_NOT_FOUND) || (dir == NULL)) return ret; if ((ret = dir_alloc_file(dir, &amp;f)) &lt; 0) return ret; strcpy(f-&gt;f_name, name); f-&gt;f_type = (omode &amp; O_MKDIR) ? FTYPE_DIR : FTYPE_REG; if (pfile) *pfile = f; // file_flush(f); return 0;} //创建目录 在 mkdir.c中，思路与 rm类似，同时创建了 access工具函数，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void init(){ enableParents = 0;}//accessint access(const char* path, int type){ char dir[MAXPATHLEN]; struct Stat st; int ret; while (*path &amp;&amp; (*path == ' ')) path++; strcpy_(dir, path); // debugf(&quot;Access: %s\\n&quot;, dir); ret = stat(dir, &amp;st); if (ret &lt; 0) { // debugf(&quot;Acess error: %d\\n&quot;, ret); return 0; } if (type == FTYPE_DIR) return st.st_isdir; else if (type == FTYPE_REG) return !st.st_isdir; return 1;}//mkdirstatic int mkdir(const char* path){ char dir[MAXPATHLEN]; const char* p = path; const char* base = path; while (*p != '\\0') { while (*p &amp;&amp; (*p != '/')) p++; memcpy_(dir, base, p - base); dir[p - base] = '\\0'; while (*p &amp;&amp; (*p == '/')) p++; if (*p) // there are remaining directories to create try(_create(dir, enableParents, 0)); else // the last element try(_create(dir, 1, 1)); } return 0;} 主体 mkdir函数中，通过不断调用 _create函数，来实现目录的递归创建： 12345678910111213141516171819202122232425static int _create(const char* path, int create, int final){ if (access(path, FTYPE_DIR)) { if (!final) return 0; printf(&quot;mkdir: cannot create directory \\'%s\\': File exists\\n&quot;, path); return 11; } // now, there is no such a file if (!create &amp;&amp; !final) { printf(&quot;mkdir: cannot create directory \\'%s\\': No such file or directory\\n&quot;, path); return 13; } // now, it's time to create file int ret = creat(path, O_MKDIR); if (ret &lt; 0) { debugf(&quot;Failed to create '%s': %d\\n&quot;, path, ret); return ret; } return 0;} 实现指令条件执行个人认为这是本次挑战性任务中最难的一个点，在深思熟虑后，我并未采取课程组提供的修改 exit函数的思路 指令返回值获取同时，根据讨论区于恩泽同学的前车之鉴，我新建了专门的 ipc来发送返回值： 12345678910111213141516171819202122232425262728//user/lib/ipc.cvoid ipc_send_cmd(u_int whom, u_int val, const void *srcva, u_int perm) { int r; while ((r = syscall_ipc_try_send_cmd(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) { syscall_yield(); } user_assert(r == 0);}u_int ipc_recv_cmd(u_int *whom, void *dstva, u_int *perm) { int r = syscall_ipc_recv_cmd(dstva); if (r != 0) { user_panic(&quot;syscall_ipc_recv err: %d&quot;, r); } if (whom) { *whom = env-&gt;env_ipc_from; } if (perm) { *perm = env-&gt;env_ipc_perm; } return env-&gt;env_ipc_value;}//env.hu_int env_ipc_recving_cmd; //whether this env is receiving cmd 然后在 libos.c 和 debugf.c中进行修改，使相关函数能够发送返回值： 12345678910111213141516171819202122232425262728//libos.cvoid libmain(int argc, char **argv) { // set env to point at our env structure in envs[]. env = &amp;envs[ENVX(syscall_getenvid())]; // call user main routine int r; r = main(argc, argv); debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); syscall_env_job_done(env-&gt;env_id); // exit gracefully exit();}//debugf.cvoid _user_panic(const char *file, int line, const char *fmt, ...) { debugf(&quot;panic at %s:%d: &quot;, file, line); va_list ap; va_start(ap, fmt); vdebugf(fmt, ap); va_end(ap); debugf(&quot;\\n&quot;); // //ipc_send(env-&gt;env_parent_id, r, 0, 0); ipc_send_cmd(env-&gt;env_parent_id, -1, 0, 0); exit();} 根据返回值条件执行指令同时在 runcmd中进行修改，来获取和发送返回值，同时给 parsecmd添加一个参数，根据上条命令的返回值，来指示当前命令是否执行，同时在 gettoken中添加判断，来解析 &amp;&amp; 和 ||，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//gettokenif (*s == '&amp;') { if (*(s + 1) == '&amp;') { *s++ = 0; flag = 'a'; } } if (*s == '|') { if (*(s + 1) == '|') { *s++ = 0; flag = 'o'; } } //parsecmd case 'a': debugf(&quot;we have &amp;&amp;\\n&quot;); if (need) { forkand = fork(); if (forkand == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); int need_ = (i == 0) ? 1 : 0; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 1, job_flag); }…… case 'o': debugf(&quot;we have ||\\n&quot;); if (need) { forkor = fork(); if (forkor == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); //wait(forkand); int need_ = (i == 0) ? 0 : 1; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 0, job_flag); }//runcmdif (argc == 0) { if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, 0, 0, 0); } return; }int child = spawn(argv[0], argv); close_all(); if (child &gt;= 0) { //debugf(&quot;Begin recv : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); if (job_flag) { syscall_env_save_job(child, tmp); } int r = ipc_recv_cmd(NULL, 0, 0); if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); } 实现前后台任务管理后台任务运行所谓后台运行所需要的任务便是shell 不需要等待此命令执行完毕后再继续执行，即当存在 &amp;时，不进行 wait即可，下附代码： 12345678910111213141516//parsecmdcase '&amp;':; int child_ = fork(); if(child_) { // 父进程执行右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } re_alloc = 0; return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行左边的命令 re_alloc = 0; *job_flag = 1; return argc; } 后台任务管理考虑到如果在用户进程中维护一个任务列表，那么各进程间共享将会非常麻烦，于是进过慎重考虑，我决定在内核维护一个任务列表，通过系统调用来进行操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//env.hstruct Job { int status; // 0表示已经结束，1表示正在运行 int envid; char cmd[200]; };//env.cstatic struct Job jobs[2000];void env_save_job(u_int envid, char *cmd) { jobs[job_cnt].envid = envid; strcpy(jobs[job_cnt].cmd, cmd); jobs[job_cnt].status = 1; job_cnt++;}void env_job_done(u_int envid) { for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].envid == envid) { jobs[i].status = 0; break; } }}int env_get_job(int i) { if (i &gt; job_cnt) { return -1; } return jobs[i - 1].envid;}void env_jobs() { char str[20]; for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].status == 0) { strcpy(str, &quot;Done&quot;); } else { strcpy(str, &quot;Running&quot;); } printk(&quot;[%d] %-10s 0x%08x %s\\n&quot;, i + 1, str, jobs[i].envid, jobs[i].cmd); }}//syscall_all.cvoid sys_env_save_job(u_int envid, char *cmd) { env_save_job(envid, cmd);}void sys_env_job_done(u_int envid) { env_job_done(envid);}int sys_env_get_job(int i) { return env_get_job(i);}void sys_env_jobs() { env_jobs();}//sh.cvoid jobs() { syscall_env_jobs();}void kill(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { syscall_env_destroy(envid); syscall_env_job_done(envid); }}void fg(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { wait(envid); }} fg即 wait该任务完成。 同时，设置全局变量 job_flag，表示该任务是否为后台任务，需要进行管理，在 runcmd中完成内置指令的实现： 12345678910111213141516171819202122232425//sh.c runcmdelse if (strcmp(argv[0], &quot;jobs&quot;) == 0 &amp;&amp; argc == 1) { jobs(); close_all(); } else if (strcmp(argv[0], &quot;kill&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } kill(ret); close_all(); } else if (strcmp(argv[0], &quot;fg&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } syscall_env_job_done(ret); fg(ret); close_all(); } 易错点同时，有几个需要注意的点： 123456789101112//libos.c libmainsyscall_env_job_done(env-&gt;env_id); 在指令结束前将任务设置为Done//syscall_all.cint sys_cgetc(void) { int ch; //while ((ch = scancharc()) == 0) { //} ch = scancharc(); //Shell-Challenge return ch;}删除了造成忙等的死循环 完结撒花！！！至此，挑战性任务的所有功能实现完毕 心路历程从开始到结束，总计135次commit(超过了OO两学期的commit总和)，终于是把Shell做完了，虽然是一个残废版的shell，感谢 yez，zyt，zx几位大佬，以及助教 shk不厌其烦地解答我的疑问，是你们拯救了我羸弱的OS，衷心感谢","link":"/2025/08/14/challenge-shell/"},{"title":"学海伴航——教辅平台系统设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是学海伴航——教辅平台的系统设计文档，源于大三上数据库课程大作业。本项目由RooKie_Z,Galaxy_Jew, LPF三人一同完成，在最终的展示后取得了 满分💯的成绩。 👉 系统实现报告 一、需求分析1.1 需求描述1.1.1 背景调研通过积极调研新生需求，了解学院教学需要，同时与辅导员老师沟通，我们发现传统的微信QQ群学习小组的答疑教辅模式已不再高效。建立功能更丰富，交互更便捷，上手更简单，连接更紧密的教辅平台需求迫在眉睫。 以下为传源书院计划开发的微信答疑小程序： 1.1.2 用户调研对于学生与辅导师的诉求，我们通过联系传源书院的辅导员，获取了他们问卷调查的数据，初步总结需求如下： 学生 辅导师 管理人员 提出问题，并得到及时回答 避免过度同质化的提问 了解同学们的学习情况 获取各科目资料集合，进行自学自测 避免答疑活动对课下生活的打扰 了解同学们的学习诉求 看见其他同学的答疑内容 便于组织模拟考试并加以批改 统计辅导师的工作量 开展模拟考试 发布公告 1.1.3 需求总结对于需要获取学业帮扶的学生他们需要一款产品，能够： 提出课业上的问题，并获得及时准确的回答。 看见其它同学的答疑内容。 获取各科习题资料，包括往年资料。 有条理地获取自己的学习做题记录。 参与模拟测试，并及时获取答题情况。 对于辅导师他们需要一款产品，能够： 避免对日常生活的过度打扰。 避免过度同质化的提问。 获得同学们对回答的反馈。 及时更新题库 发布模拟考试并加以批改 对于学业支持中心/导员他们需要一款产品，能够： 直观了解辅导师工作情况，方便监督。 自动统计辅导师的工作量并换算为志愿时长。 开展模拟考试等集体学习活动，并发布公告。 1.1.4 项目优势通过上述需求分析，可见，学海伴航具有庞大的需求空间，光明的应用前景，具有开发的价值，通过我们的平台，三类目标用户可以在多种场景下获得利好： 从学生的角度 共享学习资料：平台统一整合学习资料，方便同学查阅下载。 共享问题与解答：所有问题均公开共享，同学可以搜索自己困惑的相似的问题，从其他人的已解决问题和回答得到启发。 自主学习：平台组织统一模拟测试，学生获取模拟情况，指导自主学习。 激励学习：可视化自己解决的问题数量，同时在主页获取推荐题目，学习更有动力，更有积极性。 减少微信私聊数量：学生反馈群聊数量过多的问题，一个线下答疑活动需要建立很多的群聊，大群、小组群、互助群，影响日常的消息接收，带来不必要的麻烦。通过平台进行信息整合，交流与信息统一化。 从小导师角度 辅导积极性更高：基于回答问题，上传题目，组织考试，批改试题的次数分配志愿时长，奖励机制更加公平合理，增强辅导师的解答积极性。 在平台统一答疑，避免占用辅导师过多课下私人时间。 从学院组织者角度 活动推进：可视化活动活跃度情况，学生参与度情况，有效推进活动开展。 氛围营造：通过平台统一管理活动，定期发布相关学习公告，营造良好的学习氛围。 1.2 数据流图1.2.1 总体数据流图 1.2.2 用户管理部分数据流图 1.2.3 消息公告部分数据流图 1.2.4 题目题库部分数据流图 1.2.5 模拟考试部分数据流图 1.2.6 讨论区部分数据流图 1.2.7 用户主页部分数据流图 1.3 数据元素表1.3.1 用户管理部分用户表 字段名称 数据类型 可否为空 说明 id int NO 用户id，主键 user_id varchar NO 学号 pass_word varchar NO 密码 mail varchar NO 邮箱 college varchar NO 学院 entryYear varchar NO 入学年份 avatar varchar NO 头像 user_role varchar NO 用户身份（学生/辅导师） 1.3.2 消息部分消息表 字段名称 数据类型 可否为空 说明 id int NO 消息id，主键 sender int NO 外键，发送消息学生编号 sender_avatar varchar NO 发送者头像 sent_at date NO 发送时间 receiver int NO 外键，接收消息学生编号 content varchar NO 消息内容 is_read boolean NO 是否已阅 1.3.3 公告部分公告表 字段名称 数据类型 可否为空 说明 id int NO 公告id，主键 sender int NO 外键，发布者编号 sender_avatar varchar NO 发布者头像 sent_at date NO 发布时间 last_updated date NO 时间 content varchar NO 公告内容 title varchar NO 公告标题 1.3.4 题目部分题目表 字段名称 数据类型 可否为空 说明 id int NO 题目id，主键 type varchar NO 题目类型 content varchar NO 题目内容 subject varchar NO 题目所属科目 added_at date NO 上传时间 source varchar NO 题目来源 tags json YES 题目标签 difficulty int NO 题目难度 added_by int NO 题目添加者id question_banks json YES 外键，题目所属题库 option_count int NO 题目选项数量 题库表 字段名称 数据类型 可否为空 说明 id int NO 题库id，主键 subject varchar NO 题库所属科目 estimated_time date NO 题库预计完成时间 created_at date NO 题库创建时间 creator int NO 题库创建者id description varchar NO 题库描述 question_count int NO 题库题目数量 题目讨论区表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 question int NO 题目id，外键 created_at date NO 题目创建时间 creator int NO 题目创建者id content varchar NO 题目讨论区内容 题目讨论区讨论表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 question int NO 题目id，外键 created_at date NO 题目创建时间 creator int NO 题目创建者id content varchar NO 题目讨论区内容 做题记录表 字段名称 数据类型 可否为空 说明 id int NO 做题记录id，主键 user int NO 做题者用户id，外键 question int NO 题目id，外键 attempted_at date NO 做题时间 is_correct boolean NO 是否做对本题 1.3.5 模拟考试部分考试表 字段名称 数据类型 可否为空 说明 id int NO 模拟考试id，主键 title varchar NO 模拟考试标题 subject varchar NO 题目所属科目 description varchar NO 模拟考试描述 created_at date NO 考试创建时间 start_time date NO 考试开始时间 duration int NO 考试持续时间 end_time date NO 考试结束时间 created_by int NO 考试创建者id，外键 students json YES 外键，模拟考试所有报名学生 questions json NO 外键，模拟考试所有题目 模拟考试作答表 字段名称 数据类型 可否为空 说明 id int NO 做题记录id，主键 exam int NO 作答所属考试id，外键 user int NO 做答用户id，外键 question int NO 作答题目id，外键 submitted_answer varchar NO 最后做答答案 submitted_at date NO 最后做答时间 is_correct boolean NO 是否做对本题 1.3.6 讨论区部分讨论帖表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 title varchar NO 讨论帖标题 content varchar NO 讨论帖内容 publisher int NO 发帖者id，外键 avatar varchar NO 发帖者头像 publish_time date NO 发帖时间 last_updated date NO 讨论帖最后更新时间 tag varchar NO 讨论帖标签 subscribers json YES 订阅者id集合 likes json YES 喜爱者id集合 is_marked boolean NO 帖子是否为精华帖 帖子回复表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 discussion int NO 回帖所属讨论帖id，外键 content varchar NO 回复内容 publisher int NO 回帖者id，外键 avatar varchar NO 回帖者头像 publish_time date NO 回帖时间 last_updated date NO 回帖最后更新时间 likes json YES 回帖喜爱者id集合 ⼆、数据库概念模式设计2.1 系统初步 ER 图2.1.1 实体 ER 图 2.1.2 关系 ER 图 2.2 系统基本 ER 图 [!IMPORTANT]由于实体属性过于复杂，将属性画入ER图内将大大影响图的美观性，故下面ER图内将不包含属性，只指示关系 三、数据库逻辑模式设计与优化3.1 数据库关系模式 [!IMPORTANT] 关系模式可以形式化表示为R(U, D, DOM, F)。U为组成该关系的属性名，D为U中属性所来⾃的域，DOM 指的是属性与域的映射，F指的是属性间的依赖关系集合。以下约定N表示正整数，FLOAT 表示浮点数，S为任意字符组成的字符S，T表示时间，B表示布尔值，J表示json类型。码以下划线标识。 以下是由 E-R 图得到的关系模式。 3.1.1 实体 学生 students({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(id) = DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 辅导师 teachers({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 消息 messages({id，发送者，发送者头像，发送时间，接收者， 消息内容，是否已阅}，D，DOM，F) D = {STR, N, B, T} DOM = {DOM(id) = DOM(发送者) = DOM(接收者) = N， DOM(头像) = DOM(内容) = STR，DOM(发送时间) = T，DOM(是否已阅) = B} F = {id$\\to$其他属性} 公告 broadcasts({id，发布者，发布者头像，发布时间，更新时间，公告内容，公告标题}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = STR，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 题库 quesionbanks({id，科目，预计完成时间，创建时间，创建者，题库描述，题目数量}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(创建者) = DOM(题目数量) = N， DOM(科目) = DOM(题库描述) = STR，DOM(创建时间) = DOM(预计完成时间) = T} F = {id$\\to$其他属性} 题目 questions({id，类型，内容，科目，上传时间，来源，标签，难度，上传者，选项数量，所属题库，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(上传者) = DOM(题目难度) = DOM(选项数量) = DOM(所属题库) = N， DOM(科目) = DOM(类型) = DOM(来源) = DOM(内容) = STR，DOM(标签) = DOM(所属题库) = J，DOM(上传时间) = T} F = {id$\\to$其他属性} 讨论帖 discussions({id，发布者，发布者头像，发布时间，更新时间，帖子内容，帖子标题，帖子标签，订阅者，喜爱者，是否加精}，D，DOM，F) D = {STR, N，T，J，B} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = DOM(标签) = STR，DOM(订阅者) = DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T，DOM(是否加精) = B} F = {id$\\to$其他属性} 回复帖 replies({id，所属讨论帖，发布者，发布者头像，发布时间，更新时间，帖子内容，喜爱者}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(所属讨论帖) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = STR，DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 模拟考试 exams({id，标题，科目，开始时间，持续时间，结束时间，创建时间，创建者，考试描述，考试题目，参考学生}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(创建者) = N， DOM(科目) = DOM(标题) = DOM(考试描述) = STR，DOM(考试试题) = DOM(参考学生) = J，DOM(创建时间) = DOM(持续时间) = DOM(创开始时间) = DOM(结束时间) = T} F = {id$\\to$其他属性} 3.1.2 联系 [!IMPORTANT] 约定以下函数依赖集合省略⾮主属性对码的完全函数依赖。 3.1.2.1 多对多联系 学生——考试 studentExam({student, exam}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(exam) = N} 外码：student 对应学⽣表的主码 student.id, course 对应考试表的主码 course.id 考试——题目 questionExam({question, exam}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(exam) = N} 外码：question 对应题目表的主码 question.id, course 对应考试表的主码 course.id 题库——题目 questionQuestionbank({question, questionbank}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(questionbank) = N} 外码：question 对应题目表的主码 question.id, questionbank 对应题库表的主码 questionbank.id 帖子——订阅 subscibeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id 帖子——喜爱 likeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id 回复——喜爱 likeReply({student, reply}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply 对应回复帖表的主码 reply.id 学生作答题目 studentSubmission({student, question, time, submission, is_correct}, D, DOM, F) D = {STR, N, T, B} DOM = {DOM(submission) = STR,DOM(student) = DOM(question) = N, DOM(time) = T, DOM(is_correct) = B} 外码：student 对应学⽣表的主码 student.id, question 对应题目表的主码 question.id 3.1.2.2 一对多联系 学生——发送消息 sendMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id 学生——接收消息 receiveMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id 学生——接收公告 receiveBroadcast({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(broadcast) = N} 外码：student 对应学⽣表的主码 student.id, broadcast 对应公告表的主码 broadcast.id 教师——发布公告 publishBroadcast({message, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(broadcast) = N} 外码：teacher 对应教师表的主码 teacher.id, broadcast 对应公告表的主码 broadcast.id 教师——题库 teacherQuestionbank({questionbank, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(questionbank) = N} 外码：teacher 对应教师表的主码 teacher.id, questionbank 对应题库表的主码 questionbank.id 教师——题目 teacherQuestion({question, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(question) = N} 外码：teacher 对应教师表的主码 teacher.id, question 对应题库表的主码 question.id 教师——考试 teacherExam({exam, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(exam) = N} 外码：teacher 对应教师表的主码 teacher.id, exam 对应考试表的主码 exam.id 学生——讨论 studentDiscussion({discussion, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion对应讨论表的主码 discussion.id 学生——回复 studentReply({reply, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply对应回复表的主码 reply.id 讨论帖——回复 discussionReply({reply, discussion}, D, DOM, F) D = {N} DOM = {DOM(reply) = DOM(discussion) = N} 外码：discussion对应讨论表的主码 discussion.id, reply对应回复表的主码 reply.id 3.2 关系模式范式等级的判定与规范 [!NOTE] 分别对上述表进⾏范式等级判断，然后将未达到 3NF 的表规范到 3NF。 3.2.1 实体 学生 students({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(id) = DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 对于学生表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以学生表$\\in BCNF$，学生表$\\in 3NF$ 辅导师 teachers({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 对于辅导师表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以辅导师表$\\in BCNF$，辅导师表$\\in 3NF$ 消息 messages({id，发送者，发送者头像，发送时间，接收者， 消息内容，是否已阅}，D，DOM，F) D = {STR, N, B, T} DOM = {DOM(id) = DOM(发送者) = DOM(接收者) = N， DOM(头像) = DOM(内容) = STR，DOM(发送时间) = T，DOM(是否已阅) = B} F = {id$\\to$其他属性} 对于消息表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以消息表$\\in BCNF$，消息表$\\in 3NF$ 公告 broadcasts({id，发布者，发布者头像，发布时间，更新时间，公告内容，公告标题}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = STR，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 对于公告表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以公告表$\\in BCNF$，公告表$\\in 3NF$ 题库 quesionbanks({id，科目，预计完成时间，创建时间，创建者，题库描述，题目数量}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(创建者) = DOM(题目数量) = N， DOM(科目) = DOM(题库描述) = STR，DOM(创建时间) = DOM(预计完成时间) = T} F = {id$\\to$其他属性} 对于题库表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以题库表$\\in BCNF$，题库表$\\in 3NF$ 题目 questions({id，类型，内容，科目，上传时间，来源，标签，难度，上传者，选项数量，所属题库，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(上传者) = DOM(题目难度) = DOM(选项数量) = DOM(所属题库) = N， DOM(科目) = DOM(类型) = DOM(来源) = DOM(内容) = STR，DOM(标签) = DOM(所属题库) = J，DOM(上传时间) = T} F = {id$\\to$其他属性} 对于题目表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以题目表$\\in BCNF$，题目表$\\in 3NF$ 讨论帖 discussions({id，发布者，发布者头像，发布时间，更新时间，帖子内容，帖子标题，帖子标签，订阅者，喜爱者，是否加精}，D，DOM，F) D = {STR, N，T，J，B} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = DOM(标签) = STR，DOM(订阅者) = DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T，DOM(是否加精) = B} F = {id$\\to$其他属性} 对于讨论帖表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以讨论帖表$\\in BCNF$，讨论帖表$\\in 3NF$ 回复帖 replies({id，所属讨论帖，发布者，发布者头像，发布时间，更新时间，帖子内容，喜爱者}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(所属讨论帖) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = STR，DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 对于回复帖表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以回复帖表$\\in BCNF$，回复帖表$\\in 3NF$ 模拟考试 exams({id，标题，科目，开始时间，持续时间，结束时间，创建时间，创建者，考试描述，考试题目，参考学生}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(创建者) = N， DOM(科目) = DOM(标题) = DOM(考试描述) = STR，DOM(考试试题) = DOM(参考学生) = J，DOM(创建时间) = DOM(持续时间) = DOM(创开始时间) = DOM(结束时间) = T} F = {id$\\to$其他属性} 对于模拟考试表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以模拟考试表$\\in BCNF$，模拟考试表$\\in 3NF$ 3.2.2 联系 [!IMPORTANT] 约定以下函数依赖集合省略⾮主属性对码的完全函数依赖。 3.2.2.1 多对多联系 学生——考试 studentExam({student, exam}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(exam) = N} 外码：student 对应学⽣表的主码 student.id, course 对应考试表的主码 course.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 考试——题目 questionExam({question, exam}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(exam) = N} 外码：question 对应题目表的主码 question.id, course 对应考试表的主码 course.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 题库——题目 questionQuestionbank({question, questionbank}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(questionbank) = N} 外码：question 对应题目表的主码 question.id, questionbank 对应题库表的主码 questionbank.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 帖子——订阅 subscibeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id F = {(student, discussion) $\\to$ subscribed} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 帖子——喜爱 likeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id F = {(student, discussion) $\\to$ liked} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 回复——喜爱 likeReply({student, reply}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply 对应回复帖表的主码 reply.id F = {(student, reply) $\\to$ liked} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 学生作答题目 studentSubmission({student, question, time, submission, is_correct}, D, DOM, F) D = {STR, N, T, B} DOM = {DOM(submission) = STR,DOM(student) = DOM(question) = N, DOM(time) = T, DOM(is_correct) = B} 外码：student 对应学⽣表的主码 student.id, question 对应题目表的主码 question.id F = {(student, question ) $\\to$ is_correct, (student, question ) $\\to$ time} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 3.2.2.2 ⼀对多联系 学生——发送消息 sendMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id F = {message $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——接收消息 receiveMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id F = {message $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——接收公告 receiveBroadcast({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(broadcast) = N} 外码：student 对应学⽣表的主码 student.id, broadcast 对应公告表的主码 broadcast.id F = {broadcast $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——发布公告 publishBroadcast({message, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(broadcast) = N} 外码：teacher 对应教师表的主码 teacher.id, broadcast 对应公告表的主码 broadcast.id F = {broadcast $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——题库 teacherQuestionbank({questionbank, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(questionbank) = N} 外码：teacher 对应教师表的主码 teacher.id, questionbank 对应题库表的主码 questionbank.id F = {questionbank $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——题目 teacherQuestion({question, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(question) = N} 外码：teacher 对应教师表的主码 teacher.id, question 对应题库表的主码 question.id F = {question $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——考试 teacherExam({exam, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(exam) = N} 外码：teacher 对应教师表的主码 teacher.id, exam 对应考试表的主码 exam.id F = {exam $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——讨论 studentDiscussion({discussion, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion对应讨论表的主码 discussion.id F = {discussion $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——回复 studentReply({reply, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply对应回复表的主码 reply.id F = {reply $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 讨论帖——回复 discussionReply({reply, discussion}, D, DOM, F) D = {N} DOM = {DOM(reply) = DOM(discussion) = N} 外码：discussion对应讨论表的主码 discussion.id, reply对应回复表的主码 reply.id F = {reply $\\to$ discussion} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 3.3 数据库关系模式优化3.3.1 使⽤外键使⽤外键来保证数据的关联性并提⾼访问速度，同时在使⽤过程中保证数据的参照完整性。在本项⽬的后端数据库中，各表具有完备的外键联系，通过遵循这种外键关系进⾏实际数据库的建⽴，将从逻辑的⻆度保证数据库的设计功能能够完全正确执⾏到位。 3.3.2 优化查询语句可以优化的地⽅有如下⼏点： 能使⽤联表查询的地⽅尽可能使⽤联表查询⽐较⾼效 尽可能不将查询语句放在循环内 使⽤高效的 ORM 框架 3.3.3 合并相同主码的表对于主码相同的表，可以在设计的时候将其合并，例如将题目创建表和题目表合并，直接将题目的上传者和上传时间存⼊题目表，这样做的好处是在同时需要查询两个表中的数据时，减少了⼀次连接操作，提⾼效率。 3.3.4 严格约束加⼊数据库的数据通过建表时添加约束、⽤触发器实现约束等⽅法，严格约束对数据库的增删操作，避免将异常数据插⼊数据表。 建表时可以添加的约束有主键约束、UNIQUE 约束、外码约束等。 四、数据库物理设计4.1 存取方法存储引擎： 选择支持事务和索引优化的存储引擎——支持MySQL 的 GAUSSDB。 理由：GAUSSDB支持事务和外键约束，可以确保数据一致性，同时MySQL针对复杂查询性能较优。 分区策略： 垂直分区 将核心表（如 User、Question 和 QuestionBank）与非核心表（如 QuestionComment 和 QuestionDiscussion）分开存储。 理由：核心表频繁被查询，可以优化存储和查询效率；非核心表如评论和讨论，属于高并发写入的表，可独立优化。 水平分区 针对大数据量表（如 Question 和 UserQuestionRecord），根据字段（如 added_by 或 user_id）进行分片。 理由：便于高并发环境下的数据分布和扩展性。 数据类型选择： 使用合适的数据类型，如 INTEGER、VARCHAR、DATE 等。 对于 JSON 格式数据（如 tags），选择利用字符串存储。 4.2 索引定义为提高查询效率，我们设计索引如下： 1. User 表 主键索引：id（自动创建） 唯一索引：student_id 优点：学生学号唯一，且常用于查询，加快查询速度 索引：user_role 优点：辅导师角色（user_role = 1）在权限检查中频繁使用，加快查询速度 2. Question 表 主键索引：id（自动创建） 索引：added_by 优点：便于根据创建者快速查询 索引：type和 subject 优点：按题目类型和科目分类查询时提升效率 索引：added_at 优点：时间排序查询优化 索引：tags 优点：支持基于关键词的搜索（如 工科数学分析） 3. QuestionBank 表 主键索引：id（自动创建） 索引：subject 优点：按学科分类查询优化 索引：creator 优点：便于按创建者筛选 4. QuestionDiscussion 表 主键索引：id（自动创建） 索引：question_id 优点：按题目快速查询讨论区。 索引：created_by 优点：便于按创建者筛选讨论。 5. QuestionComment 表 主键索引：id（自动创建） 索引：discussion_id 优点：便于按讨论区快速查询评论 索引：created_by 优点：便于按创建者筛选评论 6. UserQuestionRecord 表 主键索引：id（自动创建） 唯一复合索引：(user_id, question_id) 优点：确保每个用户对每道题目只有一个做题记录 索引：user_id 优点：按用户快速筛选做题记录 索引：question_id 优点：按题目快速筛选做题记录 7. ExamRecordRecord 表 主键索引：id（自动创建） 唯一复合索引：(student_id, question_id) 优点：确保每个用户对每道题目只有一个做题记录 索引：student_id 优点：按用户快速筛选做题记录 索引：question_id 优点：按题目快速筛选做题记录 8. Discussion表 主键索引：id（自动创建） 索引：publisher 优点：便于按创建者筛选讨论 9. Reply表 主键索引：id（自动创建） 索引：publisher 优点：便于按创建者筛选讨论 索引：discussion 优点：便于按讨论帖筛选回复 10. Message表 主键索引：id（自动创建） 索引：sender 优点：便于按发送者筛选消息 索引：receiver 优点：便于按接收者筛选消息 11. Broadcast表 主键索引：id（自动创建） 索引：sender 优点：便于按发布者筛选公告 12. 外键约束 为外键字段自动创建索引： QuestionBank.questions $\\to$ Question.id QuestionDiscussion.question $\\to$ Question.id QuestionComment.discussion $\\to$ QuestionDiscussion.id UserQuestionRecord.question $\\to$ Question.id UserQuestionRecord.user $\\to$ User.id","link":"/2025/08/14/database/"},{"title":"RooKie_Z Compiler编译器设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面RooKie_Z Compiler编译器设计文档，本编译器 在最终的竞速中排名第五 Update time: 2024年12月3日 星期二 18时19分15秒 CST “免责声明” 文档撰写要求中要求按照编码前的设计、编码完成之后的修改的顺序完成各部分撰写 而事实上，我向来偏好调研先于实践，设计早于编码的代码撰写理念，而这篇设计文档也完全是本人的有感而发，设计用时相较编码用时极长，故代码重构较少，因此，请允许我不采用推荐的格式，按照我的编译器设计完成的思路完成这篇设计文档，不胜感激！！！ 参考编译器介绍参考了强生学长的 Pansy编译器，这是一个简单的编译SysY语言到Mips的编译器。该编译器设计极为精美，架构相当完整，可拓展性强，我的架构主要也模仿了 Pansy编译器 另外，据强生学长介绍，Pansy还有美人之意，这样一看我的代码也属于是东施效颦了😇 总体结构 接口设计具体的接口层有四层 Tokens -&gt; CST：向前负责，有一个统一的 Parser 用于生成 CST。 CST -&gt; LLVM IR：向后负责，CST 的每个节点实现了相应的 irBuild。 CST -&gt; Errors：向后负责，CST 的每个节点实现了相应的 check。 LLVM IR -&gt; MIR：向前负责，有一个统一的 IrParser 用于生成 MIR。 文件组织 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189.├── Compiler.java├── back│ ├── Backend.java│ ├── README.md│ ├── component│ │ ├── ObjBlock.java│ │ ├── ObjFunction.java│ │ ├── ObjGlobalVariable.java│ │ └── ObjModule.java│ ├── instruction│ │ ├── ObjBinary.java│ │ ├── ObjBranch.java│ │ ├── ObjCall.java│ │ ├── ObjCoMove.java│ │ ├── ObjComment.java│ │ ├── ObjCompare.java│ │ ├── ObjCondType.java│ │ ├── ObjInstr.java│ │ ├── ObjLoad.java│ │ ├── ObjMove.java│ │ ├── ObjRet.java│ │ ├── ObjShift.java│ │ └── ObjStore.java│ ├── operand│ │ ├── ObjImm.java│ │ ├── ObjLabel.java│ │ ├── ObjOperand.java│ │ ├── ObjPhyReg.java│ │ ├── ObjReg.java│ │ └── ObjVirReg.java│ └── process│ ├── BlockLiveInfo.java│ ├── IrParser.java│ ├── Peephole.java│ └── RegAllocator.java├── check│ ├── CheckDataType.java│ ├── Checker.java│ ├── ErrorType.java│ ├── FuncInfo.java│ ├── PansyException.java│ ├── README.md│ ├── SymbolInfo.java│ ├── SymbolTable.java│ └── VarInfo.java├── driver│ ├── Config.java│ └── Driver.java├── ir│ ├── IrBuilder.java│ ├── IrSymbolTable.java│ ├── README.md│ ├── types│ │ ├── ArrayType.java│ │ ├── DataType.java│ │ ├── FunctionType.java│ │ ├── IntType.java│ │ ├── LabelType.java│ │ ├── PointerType.java│ │ ├── ValueType.java│ │ └── VoidType.java│ └── values│ ├── Argument.java│ ├── BasicBlock.java│ ├── Function.java│ ├── GlobalVariable.java│ ├── Module.java│ ├── User.java│ ├── Value.java│ ├── constants│ │ ├── ConstArray.java│ │ ├── ConstInt.java│ │ ├── ConstStr.java│ │ ├── Constant.java│ │ └── ZeroInitializer.java│ └── instructions│ ├── Add.java│ ├── Alloca.java│ ├── BinInstruction.java│ ├── Br.java│ ├── Call.java│ ├── GetElementPtr.java│ ├── Icmp.java│ ├── Instruction.java│ ├── Load.java│ ├── MemInstruction.java│ ├── Mul.java│ ├── Phi.java│ ├── Ret.java│ ├── Sdiv.java│ ├── Srem.java│ ├── Store.java│ ├── Sub.java│ ├── TerInstruction.java│ └── Zext.java├── lexer│ ├── Lexer.java│ ├── README.md│ └── token│ ├── Comment.java│ ├── Delimiter.java│ ├── EOFToken.java│ ├── FormString.java│ ├── Identifier.java│ ├── IntConst.java│ ├── Reserved.java│ ├── SyntaxType.java│ └── Token.java├── parser│ ├── ParseSupporter.java│ ├── Parser.java│ ├── README.md│ ├── SysY.g4│ └── cst│ ├── AddExpNode.java│ ├── AssignStmtNode.java│ ├── BTypeNode.java│ ├── BlockItemNode.java│ ├── BlockNode.java│ ├── BreakStmtNode.java│ ├── CSTNode.java│ ├── CalleeNode.java│ ├── CondNode.java│ ├── ConditionStmtNode.java│ ├── ConstDeclNode.java│ ├── ConstDefNode.java│ ├── ConstExpNode.java│ ├── ConstInitValNode.java│ ├── ContinueStmtNode.java│ ├── DeclNode.java│ ├── EqExpNode.java│ ├── ExpNode.java│ ├── ExpStmtNode.java│ ├── FuncDefNode.java│ ├── FuncFParamNode.java│ ├── FuncFParamsNode.java│ ├── FuncRParamsNode.java│ ├── FuncTypeNode.java│ ├── InStmtNode.java│ ├── InitValNode.java│ ├── LAndExpNode.java│ ├── LOrExpNode.java│ ├── LValNode.java│ ├── MainFuncDefNode.java│ ├── MulExpNode.java│ ├── NumberNode.java│ ├── OutStmtNode.java│ ├── PrimaryExpNode.java│ ├── RelExpNode.java│ ├── ReturnStmtNode.java│ ├── RootNode.java│ ├── StmtNode.java│ ├── TokenNode.java│ ├── UnaryExpNode.java│ ├── UnaryOpNode.java│ ├── VarDeclNode.java│ ├── VarDefNode.java│ └── WhileStmtNode.java├── pass│ ├── Pass.java│ ├── PassManager.java│ ├── README.md│ ├── analyze│ │ ├── BuildCFG.java│ │ ├── DomInfo.java│ │ ├── Loop.java│ │ ├── LoopInfo.java│ │ ├── LoopInfoAnalysis.java│ │ └── SideEffectAnalysis.java│ └── refactor│ ├── BranchOpt.java│ ├── DeadCodeEmit.java│ ├── FunctionClone.java│ ├── GCM.java│ ├── GVN.java│ ├── GlobalVariableLocalize.java│ ├── InlineFunction.java│ ├── InstructionSimplify.java│ ├── Mem2reg.java│ └── UselessRetEmit.java└── util ├── MyCompare.java ├── MyIO.java ├── MyList.java ├── MyMath.java ├── MyPair.java └── MyPrintf.java 编译器总体设计总体结构通过理论课的学习可以知道，我们通常将编译过程分为如下阶段： 词法分析，语法分析，语义分析，llvm生成，llvm优化，mips生成及优化，其中错误处理贯穿整个前端过程。 前端 词法分析：构建了贪心简化的 DFA，输入源程序，输出 token序列。 语法分析：通过递归下降子程序，进行最左推导。其中采用了 扩充的BNF范式解决左递归问题，并通过 预读FIRST集的方式来尽可能避免回溯并完成错误处理。 语义分析：通过遍历语法分析得到的语法树，构建符号表。 错误处理：在词法分析、语法分析中进行语法错误处理，在语义分析中进行语义错误处理。 中端(llvm优化) 中端实现了 Mem2reg，重构并生成了带有 phi函数的中间代码。 构建控制流图(CFG)，求解支配者与支配边界。 重构SSA，phi指令的插入与变量重命名。 副作用分析 GVL DCE（死代码删除） 后端(mips代码生成及优化) 非 phi指令中间代码的翻译，phi指令的翻译。至此为止分配的都是虚拟寄存器。 图着色寄存器分配。 少量窥孔优化。 接口设计类似于 Pansy： 具体的接口层有四层 Tokens -&gt; AST：向前负责，有一个统一的 Parser 用于生成 AST。 AST -&gt; Symbol：向后负责，AST 的每个节点实现了相应的 visit方法。 AST -&gt; Errors：向后负责，AST 的每个节点实现了相应的 visit方法在其中完成错误处理。 AST -&gt; LLVM IR：向后负责，AST 的每个节点实现了相应的 BuildIr方法。 LLVM IR -&gt; MIPS：向前负责，有一个统一的 MipsBuilder用于生成 MIPS。 文件组织123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170.├── Compiler.java├── backend│ ├── MipsBuilder.java│ ├── MipsFactory.java│ ├── components│ │ ├── MipsBlock.java│ │ ├── MipsFunction.java│ │ ├── MipsGlobalVariable.java│ │ └── MipsModule.java│ ├── instructions│ │ ├── MipsBinary.java│ │ ├── MipsBranch.java│ │ ├── MipsCall.java│ │ ├── MipsComment.java│ │ ├── MipsCompare.java│ │ ├── MipsCondType.java│ │ ├── MipsInstruction.java│ │ ├── MipsLoad.java│ │ ├── MipsMacro.java│ │ ├── MipsMove.java│ │ ├── MipsMoveHI.java│ │ ├── MipsRet.java│ │ ├── MipsShift.java│ │ └── MipsStore.java│ ├── operands│ │ ├── MipsImm.java│ │ ├── MipsLabel.java│ │ ├── MipsOperand.java│ │ ├── MipsRealReg.java│ │ ├── MipsVirtualReg.java│ │ └── RegType.java│ ├── reg│ │ ├── BlockLiveVarInfo.java│ │ └── RegAllocator.java│ └── utils│ ├── MipsMathOpt.java│ ├── MipsUtil.java│ ├── Pair.java│ └── Triple.java├── compiler.zip├── config.json├── error│ ├── Error.java│ ├── ErrorHandler.java│ ├── ErrorType.java│ └── ErrorUtil.java├── exception│ └── LexerException.java├── frontend│ ├── Lexer.java│ ├── Parser.java│ └── Visitor.java├── ir│ ├── IrBuilder.java│ ├── IrFactory.java│ ├── IrSymbolTable.java│ ├── IrSymbolTableStack.java│ ├── IrUtil.java│ ├── types│ │ ├── ArrayType.java│ │ ├── CharType.java│ │ ├── FuncType.java│ │ ├── IntType.java│ │ ├── LabelType.java│ │ ├── PointerType.java│ │ ├── ValueType.java│ │ └── VoidType.java│ └── values│ ├── BasicBlock.java│ ├── Function.java│ ├── GlobalVariable.java│ ├── Module.java│ ├── User.java│ ├── Value.java│ ├── constants│ │ ├── ConstArray.java│ │ ├── ConstChar.java│ │ ├── ConstInt.java│ │ ├── ConstString.java│ │ ├── Constant.java│ │ └── ZeroInitializer.java│ ├── instructions│ │ ├── Add.java│ │ ├── Alloca.java│ │ ├── ArithmeticInstruction.java│ │ ├── Br.java│ │ ├── Call.java│ │ ├── GetElementPtr.java│ │ ├── Icmp.java│ │ ├── Instruction.java│ │ ├── Load.java│ │ ├── Mul.java│ │ ├── Phi.java│ │ ├── Ret.java│ │ ├── Sdiv.java│ │ ├── Srem.java│ │ ├── Store.java│ │ ├── Sub.java│ │ ├── Trunc.java│ │ └── Zext.java│ └── pass│ ├── AggressiveDeadCodeEmit.java│ ├── BuildCFG.java│ ├── DeadCodeEmit.java│ ├── DomInfo.java│ ├── GVL.java│ ├── Loop.java│ ├── LoopInfo.java│ ├── Mem2Reg.java│ ├── SideEffectAnalysis.java│ └── UselessRetEmit.java├── node│ ├── AddExpNode.java│ ├── BTypeNode.java│ ├── BlockItemNode.java│ ├── BlockNode.java│ ├── CharacterNode.java│ ├── CompUnitNode.java│ ├── CondNode.java│ ├── ConstDeclNode.java│ ├── ConstDefNode.java│ ├── ConstExpNode.java│ ├── ConstInitValNode.java│ ├── DeclNode.java│ ├── EqExpNode.java│ ├── ExpNode.java│ ├── ForStmtNode.java│ ├── FuncDefNode.java│ ├── FuncFParamNode.java│ ├── FuncFParamsNode.java│ ├── FuncRParamsNode.java│ ├── FuncTypeNode.java│ ├── InitValNode.java│ ├── LAndExpNode.java│ ├── LOrExpNode.java│ ├── LValNode.java│ ├── MainFuncDefNode.java│ ├── MulExpNode.java│ ├── Node.java│ ├── NodeType.java│ ├── NumberNode.java│ ├── PrimaryExpNode.java│ ├── RelExpNode.java│ ├── StmtNode.java│ ├── StmtType.java│ ├── UnaryExpNode.java│ ├── UnaryOpNode.java│ ├── VarDeclNode.java│ └── VarDefNode.java├── opt│ └── Peephole.java├── symbol│ ├── CharSymbol.java│ ├── FuncSymbol.java│ ├── NumSymbol.java│ ├── Symbol.java│ ├── SymbolTable.java│ ├── SymbolTableStack.java│ └── SymbolType.java├── test│ └── testReg.java├── token│ ├── Token.java│ └── TokenType.java├── utils│ ├── Config.java│ ├── IO.java│ └── Phases.java└── 设计文档.md 词法分析大体思路词法分析部分的主要任务是顺序遍历源程序代码，将其按照文法转化为token序列。 词法分析可以通过正则表达式匹配或者贪心简化过的DFA实现，我完成了正则表达式的撰写，但由于我是正则苦手﫠，最终我选择了后者。 DFA的设计DFA通过 fronted/Lexer.java实现，我们的单词大致分为四类，分别是保留字、 字符串常量、标识符、分界符。通过贪心匹配不同类别的FIRST集合，即可根据当前字符，确定下面将要处理的单词的大致种类。 调用 next()方法即可读取下一个token，大致框架如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public Token next() throws LexerException { currentToken = null; do { skipWhite(); } while (skipComment()); if (pos &gt; maxLength) { return null; } char nowChar = inputText.charAt(pos); if (Character.isDigit(nowChar)) { int endPos = pos + 1; while (endPos &lt;= maxLength &amp;&amp; Character.isDigit(inputText.charAt(endPos))) { endPos++; } String str = inputText.substring(pos, endPos); // 更新pos pos = endPos; currentToken = new Token(str, lineNum, TokenType.INTCON); } else if (isIdentifierNondigit(nowChar)) { int endPos = pos + 1; while (endPos &lt;= maxLength &amp;&amp; isIdentifierDigit(inputText.charAt(endPos))) { endPos++; } String str = inputText.substring(pos, endPos); // 更新pos pos = endPos; // 判断是否为保留字 TokenType type = TokenType.isReserved(str); currentToken = new Token(str, lineNum, Objects.requireNonNullElse(type, TokenType.IDENFR)); } else if (nowChar == '\\'') { int endPos = pos + 1; boolean backslashFlag = false; while (endPos &lt;= maxLength &amp;&amp; (inputText.charAt(endPos) != '\\'' || (inputText.charAt(endPos) == '\\'' &amp;&amp; backslashFlag))) { backslashFlag = inputText.charAt(endPos) == '\\\\' &amp;&amp; !backslashFlag; endPos++; } // 检查'是否匹配 if (endPos &gt; maxLength) { throw new LexerException(lineNum); } endPos++; String str = inputText.substring(pos, endPos); pos = endPos; currentToken = new Token(str, lineNum, TokenType.CHRCON); } else if (nowChar == '\\&quot;') { int endPos = pos + 1; boolean backslashFlag = false; while (endPos &lt;= maxLength &amp;&amp; (inputText.charAt(endPos) != '\\&quot;' || inputText.charAt(endPos) == '\\&quot;' &amp;&amp; backslashFlag)) { backslashFlag = inputText.charAt(endPos) == '\\\\' &amp;&amp; !backslashFlag; endPos++; } // 检查&quot;是否匹配 if (endPos &gt; maxLength) { throw new LexerException(lineNum); } endPos++; String str = inputText.substring(pos, endPos); pos = endPos; currentToken = new Token(str, lineNum, TokenType.STRCON); } else { TokenType tokenType = null; int tokenLength = 0; String str = &quot;&quot;; if (TokenType.singleCharList.contains(nowChar)) { tokenType = TokenType.getTokenType((str = inputText.substring(pos, pos + 1))); tokenLength = 1; } if (pos &lt; maxLength &amp;&amp; TokenType.doubleCharList.contains(nowChar)) { TokenType t = TokenType.getTokenType(inputText.substring(pos, pos + 2)); if (t != null) { tokenType = t; tokenLength = 2; str = inputText.substring(pos, pos + 2); } else if (isErrorA(inputText.charAt(pos))) { System.out.println(inputText.charAt(pos) + &quot; &quot; + &quot;我做了错饭&quot;); ErrorHandler.addError(new Error(ErrorType.a, lineNum)); tokenType = (inputText.charAt(pos) == '&amp;') ? TokenType.AND : TokenType.OR; str = (inputText.charAt(pos) == '&amp;') ? &quot;&amp;&amp;&quot; : &quot;||&quot;; tokenLength = 1; } } if (tokenType != null) { currentToken = new Token(str, lineNum, tokenType); pos += tokenLength; } } if (currentToken != null) { tokenResult.add(currentToken); } return currentToken; } Token类为了进行可能的语法拓展，我对于各种 token进行了抽象，建立Token类，该类记录了 Token的原字符串，token的类型，以及其所在行号（供错误处理使用） 12345public Token(String content, int lineNum, TokenType type) { this.content = content; this.lineNum = lineNum; this.type = type; } 有关文法设定部分位于 token/TokenType.java 对于所有 Token标识符，我都加以枚举，定义在枚举类 TokenType里。 此外，为了便于状态机读取当前字符后的进一步状态转移，对于文法中规定的 保留字、以及 单/双分界符$ ==, \\ne, \\le, \\ge, \\gt, \\lt, !, &amp;, |$，进行建表与划分。 以上两种信息均为“文法给出的设定”，因此在设计上理应放入一个类中，这使得我们的 Lexer类并不会把文法写死在代码里，便于后续期中期末考试修改文法时，快速完成词法分析部分的修改。 语法分析大体思路语法分析的任务是是读入 token序列，并分析确定其语法结构，最终生成语法树的过程。 [!NOTE]通过理论课我们知道，我们可以使用递归下降分析法来实现语法分析，而由于递归下降子程序本质上是在进行最左推导，因此可能会遇到左递归和回溯的问题。 具体来说: 我为每个非终结符编写一个递归子程序，以完成该非终结符所对应的语法成分的分析与识别任务，若正确识别，则可以退出该非终结符号的子程序，返回到上一级的子程序继续分析；若发生错误，即源程序不符合文法，则要进行相应的错误信息报告以及错误处理。 nextSym()的实现 [!NOTE] 通过理论课的学习我们知道，法分析的推进，本质上是终结符识别进度的推进，因此 nextSym的调用时机应当是成功识别一个终结符后。 事实上，在理论课提供的 Pascal语言编译器的语法分析部分，对于 nextSym的设计太过简单，导致示例程序低内聚，高耦合，考虑到在语法分析部分就有进行错误处理的需要，我对于 nextSym()程序进行了改写。 具体思路为：将识别终结符，nextSym，以及后续可能的错误处理整合进一个函数当中。 左递归的处理涉及到左递归的文法主要是关于 Exp系列的非终结符。 1AddExp -&gt; MulExp | AddExp ('+' | '−') MulExp [!NOTE] 通过理论课的学习我们知道，对于左递归文法，一般有2种处理方式——右递归改写 or 采用扩充的BNF范式 右递归改写例如： 1AddExp -&gt; MulExp | MulExp ('+' | '−') AddExp 但如此处理是存在潜在风险的，因为修改了文法 扩充的BNF范式还有一种处理方式是采用BNF范式，修改了文法，直接丢掉 AddExp。 1AddExp -&gt; MulExp {'+' MulExp} 这种处理方式依然存在风险，因为后续的所有编译环节都要相应地使用修改后的文法。 处理方式 [!IMPORTANT] 经过上述分析，考虑到未来 期中期末考试可能涉及的潜在的文法修改与更新，通过参考学长编译器的设计，我决定采用一种更符合实际编译器撰写的方法进行处理，即： 对于上述例子，在扩充的BNF范式的基础上再进一步，把刚刚拆出来的所有 MulExp全部手动组装回左递归的形态。我们利用 java的面向对象特性，将解析出的 MulExp重新组装为 AddExp。 此时左递归对于后续的编译部分不再有影响，因为我们的信息已经全部存储在编译器中，不再受到最左推导的限制。 代码示例： 12345678910111213// AddExp → MulExp | AddExp ('+' | '−') MulExp public AddExpNode AddExp() { AddExpNode addExpNode = null; Token opToken = null; MulExpNode mulExpNode = MulExp(); while (currentToken.type == TokenType.PLUS || currentToken.type == TokenType.MINU) { addExpNode = new AddExpNode(addExpNode, opToken, mulExpNode); opToken = matchToken(currentToken.type); mulExpNode = MulExp(); } return new AddExpNode(addExpNode, opToken, mulExpNode); } 回溯法对于一般的产生式，我们采用FIRST集来判别即可，但是也有一些不那么友好的产生式，我们难以判别： 选择哪个产生式。 产生式中 {xxx}的重复部分，到底应该何时结束。 重复部分啥时候结束？看看 )，]不就好了？事实上，我们在后续错误处理中采取的，补全的错误局部化策略，迫使我们的程序在 )，]缺失时依然要正常工作。为解决这个问题，我们只得以循环部的FIRST集来判别。 回到我们的回溯问题来。 回溯，即FIRST也失灵的情况下，我们被迫跳过某个非终结符，对后面的标志性符号进行分析，从而判断选取的产生式分支的手段。 回溯只产生在 Stmt的左值与 Exp判别上： 1234plaintextStmt -&gt; LVal '=' Exp ';'Stmt -&gt; [Exp] ';'Stmt -&gt; LVal '=' 'getint''('')'';' 在这里，Exp当然可以透过 PrimaryExp推出左值 LVal，FIRST集失灵。 为此，我们要处理掉碍事的 LVal，暴露出后面的 =和 getint。 回溯主要是采用 pinToken()和 reflow()来记录、复原当前游标在token序列的位置。详细代码及注释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647default -&gt; { // 最喜欢的一集 // 余下四种情况： // LVal '=' Exp ';' // [Exp] ';' // LVal '=' 'getint''('')'';' // LVal '=' 'getchar''('')'';' if (currentToken.type == TokenType.SEMICN) { //直接匹配，最喜欢的一集 tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.EXP; } else { pinToken(); LValNode lValNode = LVal(); if (currentToken.type == TokenType.ASSIGN) { nodes.add(lValNode); tokens.add(matchToken(TokenType.ASSIGN)); // LVal '=' 'getint''('')'';' // LVal '=' 'getchar''('')'';' if (currentToken.type == TokenType.GETINTTK) { tokens.add(matchToken(TokenType.GETINTTK)); tokens.add(matchToken(TokenType.LPARENT)); tokens.add(matchToken(TokenType.RPARENT)); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALGETINT; } else if (currentToken.type == TokenType.GETCHARTK) { tokens.add(matchToken(TokenType.GETCHARTK)); tokens.add(matchToken(TokenType.LPARENT)); tokens.add(matchToken(TokenType.RPARENT)); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALGETCHR; } else { // LVal '=' Exp ';' nodes.add(Exp()); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALASSIGN; } } else { reflow(); ExpNode expNode = Exp(); nodes.add(expNode); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.EXP; } } } Node类——前端🔗中端的关键node类是语法分析中，语法树的结点，记录了语法分析的结果。是贯穿了语法分析、错误处理、中间代码生成的重要类。 对于每一个非终结符，都建立一个 node类。所有 node类都继承了抽象父类 Node。 Node规定了所有 node类都要实现的三个方法，用于在遍历语法树时执行相应的动作（即递归下降时的动作符号）： print()方法，透过遍历语法树，输出语法分析结果至文件。 visit()方法，透过遍历语法树，检查错误并记录。 buildIr()方法，透过遍历语法树，生成 llvm代码。 语义分析&amp;&amp;错误处理在当前前端阶段，我们要求生成的符号表还是过于简易，实际上，只对于错误处理有指导意义，可以说，我们的初步语义分析，就是为了错误处理准备的。 错误总论语法&amp;&amp;词法错误并不是所有的错误都是语义错误，常见的语义错误有“变量重命名，变量未定义”等，这些错误是可以通过词法分析和语法分析的，不会造成语法分析的错误。但是有些错误，是没有办法通过词法分析和语法分析的，有如下这些类 编号 类型 原因 a 非法符号 无法通过词法分析 i 缺少分号 无法通过语法分析 j 缺少右小括号 无法通过语法分析 k 缺少右中括号 无法通过语法分析 对于 A类错误，此类错误直接处理也不会导致语法，语义分析无法进行，故直接处理： 1234ErrorHandler.addError(new Error(ErrorType.a, lineNum)); tokenType = (inputText.charAt(pos) == '&amp;') ? TokenType.AND : TokenType.OR; str = (inputText.charAt(pos) == '&amp;') ? &quot;&amp;&amp;&quot; : &quot;||&quot;; tokenLength = 1; 而对于 i，j，k这些导致语法分析进行不下去的错误一定需要被“包容”，否则就坚持不到错误处理流程了。这种包容设置还有一种“补充”的意味在里面。但是最难的其实是缺失符号对于正常语法解析的影响，缺失符号会让原本就很困难的语法分析变得更加困难，这是因为语法分析本就需要依靠符号确定解析的分支，缺少符号会让这个过程变得模糊不清，这也是像 i, j, k 这类错误并不太多的原因，因为一旦多了，就会导致解析困难。 在三种缺失中，以缺少右中括号最为好处理，中括号意味着维度信息，只要有左中括号，那么右中括号一定是可以补上的，基本上无脑就可以了。 但是对于缺失分号和小括号，有可能造成解析分支的判断不当。所以需要进行回退处理（如果不回退的话就要改写文法，而且文法改的毫无语义意义）。 对于缺失分号，有无法区分赋值语句和表达式的问题。 1234567// 缺失前i + 1;a = b + c;// 缺失后i + 1a = b + c; 这就意味着没法通过前瞻（即“在分号前有一个等于号“）来确定是否是赋值语句。所以只能通过“尝试解析-判断 LAST”的方法进行。 对于 return 语句，可能也有这种现象，虽然应该被语义约束了 1234567// 缺失前return;a;// 缺失后return a; 对于 Callee 语句，也是这样（应该也被约束了），这里应该是同时缺失了小括号和分号 1234567// 缺失前f();a;// 缺失后f(a; 具体来看，我们结合前文 Parser中 nextSym的实现，统一处理： 12345678910111213141516171819//通过依次匹配理想语法成分来避免回溯 public Token matchToken(TokenType tokenType) { if (currentToken.type == tokenType) { Token tmp = currentToken; if (pos &lt; maxLength) { pos++; currentToken = tokens.get(pos); } return tmp; } else if (tokenType == TokenType.SEMICN || tokenType == TokenType.RPARENT || tokenType == TokenType.RBRACK) { int lineNum = tokens.get(pos - 1).lineNum; String str = tokenType.getStr(); ErrorType errorType = mismatchErrors.get(tokenType); ErrorHandler.addError(new Error(errorType, lineNum)); return new Token(str, lineNum, tokenType); } return null; } 语义错误处理 &amp;&amp; 语义分析错误处理的各个语义错误类型是相对独立的，彼此之间仅存在一定的联系，可以分别对每一种错误进行处理。在进行错误处理的过程中，我建立了栈式符号表。 符号Symbol我将符号的类型分为函数符号 FuncSymbol和变量符号 NumSymbol, CharSymbol，二者都继承一个父类 Symbol。 对于函数符号，我们额外记录其返回值类型以及形参的Symbol： 12345678public class FuncSymbol extends Symbol{ public enum FuncReturnType{ INT, VOID, CHAR; } private FuncReturnType returnType; private ArrayList&lt;NumSymbol&gt; params; // 参数符号列表 ...} 对于变量符号，由于其只可能是 int char 或者int char数组类型，因此我们只需要额外记录其维数。 1234567891011javapublic class NumSymbol extends Symbol{ private int dim; // 数组维数 0 1 private String ifArray;}public class CharSymbol extends Symbol { private int dim; // 数组维数 0 1 private String ifArray;} 符号表SymbolTable对于符号表，我使用栈式符号表。在设计之初，我是想要保留一个双向的类似树结构（其实也确实实现了，但是ir生成时没有采用该符号表），在使用栈式符号表后保留根节点，这样就可以留下该符号表。具体来说是把下图中的单向边换成双向边： 每个符号表中，都由 TreeMap来存储具体信息，fatherSymbolTable和 sonSymbolTables维护父子间的关系。 1234567891011121314public class SymbolTable { private final TreeMap&lt;String, Symbol&gt; symbolMap; //TreeMap提高检索速度 private final SymbolTable fatherSymbolTable; // 所属的父符号表 private final ArrayList&lt;SymbolTable&gt; sonSymbolTables; // 所有子符号表 private final Node node; // 由此语法树成分开始新建此符号表 private Integer regionIndex; public SymbolTable(SymbolTable fatherSymbolTable, Node node, Integer regionIndex) { this.symbolMap = new TreeMap&lt;&gt;(); this.fatherSymbolTable = fatherSymbolTable; this.sonSymbolTables = new ArrayList&lt;&gt;(); this.node = node; this.regionIndex = regionIndex; }} 符号表栈SymbolTableStack该类内封装有构建符号表、查符号表的各种方法，以及一个符号表栈 Stack。 该类内还有为 continue，break，return等对应错误而设置的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class SymbolTableStack { private Stack&lt;SymbolTable&gt; stack; private static TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; visitResults = new TreeMap&lt;&gt;(); private static Integer regionIndex = 1; private SymbolTableStack() { this.stack = new Stack&lt;&gt;(); } private static SymbolTableStack instance = new SymbolTableStack(); public static SymbolTableStack getInstance() { return instance; } // ====================== 栈操作======================= public static SymbolTable peek() { if (instance.stack.empty()) { return null; } return instance.stack.peek(); } public static void stackPush(SymbolTable symbolTable) { if (!instance.stack.empty()) { peek().addSon(symbolTable); } instance.stack.push(symbolTable); } public static void nodePush(Node node) { regionIndex++; stackPush(new SymbolTable(peek(), node, regionIndex)); } public static void pop() { instance.stack.pop(); } public static void addSymbolToPeek(Symbol symbol) { peek().addSymbol(symbol); Integer index = peek().getRegionIndex(); if (!visitResults.containsKey(index)) { ArrayList&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;(); symbols.add(symbol); visitResults.put(index, symbols); //System.out.println(&quot;成功向符号表中添加元素 &quot; + index + &quot; &quot; + symbol); } else { visitResults.get(index).add(symbol); //System.out.println(&quot;成功向符号表中添加元素 &quot; + index + &quot; &quot; + symbol); } } public static TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; getVisitResults() { return visitResults; } public static void outputResult() { for (Map.Entry&lt;Integer, ArrayList&lt;Symbol&gt;&gt; entry : visitResults.entrySet()) { Integer key = entry.getKey(); ArrayList&lt;Symbol&gt; symbols = entry.getValue(); for (Symbol symbol : symbols) { System.out.println(key + &quot; - &quot; + symbol); } } } // ================= 栈查找 ================= // 检测栈顶符号表是否包含指定名称的元素 public static boolean peekHasSymbol(String name) { return peek().hasSymbol(name); } // 在整个栈内查找并返回第一个指定名称指定类型的元素 public static Symbol getSymbol(String name, SymbolType symbolType) { Symbol symbol; for (int i = instance.stack.size() - 1; i &gt;= 0; i--) { symbol = instance.stack.get(i).getSymbol(name, symbolType); if (symbol != null) { return symbol; } } return null; } // 检查整个栈内是否包含指定名称的元素 public static boolean stackHasSymbol(String name) { for (SymbolTable symbolTable : instance.stack) { if (symbolTable.hasSymbol(name)) { return true; } } return false; } public static boolean stackHasSymbolSameType(String name, SymbolType symbolType) { for (int i = instance.stack.size() - 1; i &gt;= 0; i--) { Symbol symbol = instance.stack.get(i).getSymbol(name, null); if (symbol != null) { if (symbolType == SymbolType.Const) { return symbol.type.isConst(); } else { return symbol.type == symbolType; } } } return false; } // ================= 循环工具 ================= // 记录当前所在的循环深度 private int loopDepth = 0; public static boolean inLoop() { return instance.loopDepth &gt; 0; } public static void enterLoop() { instance.loopDepth++; } public static void exitLoop() { instance.loopDepth = instance.loopDepth &gt; 0 ? instance.loopDepth - 1 : 0; } // ================= 函数工具 ================= // 记录当前是否在一个无返回值的函数内部 private boolean noReturn = false; public static boolean ifNoReturn() { return instance.noReturn; } public static void setIfReturn(boolean inVoidFunc) { instance.noReturn = inVoidFunc; }} 入栈新符号表的时机在遍历语法树的过程中，于 MainFuncDef，FuncDef以及 Stmt的 StmtType.BLOCK场合下，调用 SymbolTableStack中封装好的方法即可入栈新的符号表，例如： 1234567891011121314if (type == StmtType.BLOCK) { SymbolTableStack.nodePush(this); } public static void stackPush(SymbolTable symbolTable) { if (!instance.stack.empty()) { peek().addSon(symbolTable); } instance.stack.push(symbolTable); } public static void nodePush(Node node) { regionIndex++; stackPush(new SymbolTable(peek(), node, regionIndex)); } 添加新符号的时机在遍历语法树的过程中，于 MainFuncDef，FuncDef以及 Stmt的 StmtType.BLOCK场合下，读取到新符号（变量、常量、函数）时调用 SymbolTableStack中封装好的方法即可。 12FuncSymbol funcSymbol = new FuncSymbol(identToken.content, identToken.lineNum, this, returnType, params); SymbolTableStack.addSymbolToPeek(funcSymbol); 错误处理的逻辑错误记录方法在 error/ErrorUtil.java内封装有检查当前语境下错误并记录的方法。在遍历到语法树的特定位置时直接调用，即可进行错误处理。 记录错误的接口我将所有能够生成并记录错误的方法都统一放置在了 error/ErrorUtil.java里，调用其中的方法便可（判断并）记录错误，便于后期修改。例如： 12345678910111213/** * @param token 当前终结符 * @return noDuplicateError */ // 重定义 public static boolean checkDuplicateError(Token token) { boolean noDuplicateError = true; if (SymbolTableStack.peekHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.b, token.lineNum)); noDuplicateError = false; } return noDuplicateError; } 具体错误的处理方法 b 类错误 - 名字重定义 对于出现错误的四条文法，读取到 ident的创建时，调用： 12345678public static boolean checkDuplicateError(Token token) { boolean noDuplicateError = true; if (SymbolTableStack.peekHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.b, token.lineNum)); noDuplicateError = false; } return noDuplicateError; } c 类错误 - 未定义的名字 对于出现错误的三条文法，读取到 ident的引用时，调用： 123456789// 未定义 public static boolean checkUndefinedError(Token token) { boolean noUndefinedError = true; if (!SymbolTableStack.stackHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.c, token.lineNum)); noUndefinedError = false; } return noUndefinedError; } d 类错误 - 函数参数个数不匹配 对于题目给出的文法，当 UnaryExp需要进行函数调用时，从符号表得到其形参个数，再读取其子节点的 funcRParamsNode的 expNodes的 size()，两者比较，如果不同，那就报错。 123456789101112131415else if (identToken != null) { if (ErrorUtil.checkUndefinedError(identToken)) { FuncSymbol symbol = (FuncSymbol) SymbolTableStack.getSymbol(identToken.content, SymbolType.Func); if (symbol == null) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (symbol.getParams().size() != getParaSize()) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (!checkParamsIllegal(symbol)) { ErrorHandler.addError(new Error(ErrorType.e, identToken.lineNum)); } } if (funcRParamsNode != null) { funcRParamsNode.visit(); } } e 类错误 - 函数参数类型不匹配 我们的变量类型只有2种：整型、一维数组。 123456789101112131415else if (identToken != null) { if (ErrorUtil.checkUndefinedError(identToken)) { FuncSymbol symbol = (FuncSymbol) SymbolTableStack.getSymbol(identToken.content, SymbolType.Func); if (symbol == null) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (symbol.getParams().size() != getParaSize()) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (!checkParamsIllegal(symbol)) { ErrorHandler.addError(new Error(ErrorType.e, identToken.lineNum)); } } if (funcRParamsNode != null) { funcRParamsNode.visit(); } } f 类错误 - 无返回值的函数存在不匹配的 return语句；g 类错误 - 有返回值的函数缺少 return语句 在 stmt的类型是 Return时，如果在函数当中但 expNode != null就报错。 h 类错误 - 不能改变常量的值 判断 &lt;LVal&gt;当中的 &lt;ident&gt;是否是常量即可。 m 类错误 - 在非循环块中使用 break 和 continue 语句 我们在符号表栈内维护了 loopCount，初始为 0，每次进入循环就加一，退出循环就减一。 在 stmt 的类型是 Break 或者 Continue 时，判断当前的 loopCount 是否为零即可，如果是，那就报错。 语义分析结果输出12345678910public void print() { TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; visitResults = SymbolTableStack.getVisitResults(); for (Map.Entry&lt;Integer, ArrayList&lt;Symbol&gt;&gt; entry : visitResults.entrySet()) { Integer key = entry.getKey(); ArrayList&lt;Symbol&gt; symbols = entry.getValue(); for (Symbol symbol : symbols) { IO.write(IO.IOType.VISITOR, (key + &quot; &quot; + symbol), true, true); } } } LLVM IR生成LLVM简介LLVM是一种三地址码，即一条LLVM语句可以表示为如下形式： 1&lt;运算结果&gt; = &lt;指令类型&gt; &lt;操作数1&gt;, &lt;操作数2&gt; 观察这种指令可以发现，一条语句主要由三个要素组成： （1）操作数（2）指令类型（3）运算结果 现在我们需要将LLVM的这种语言特性，使用Java的类设计来表达： 在Java代码中，使用具体的类对象，来表示语句中的各个元素。（就像语法分析中使用各种 node类来表达各种语法元素一样） 具体措施是，通过遍历之前语法分析的语法树，透过结合属性翻译文法的递归下降的方式，来生成llvm的语法树。 对LLVM的简单理解我们将 llvm采用树的形式存储，根节点为 Module。 一个 module 中可以拥有两种顶层实体： Function 和 GlobalVariable 每个 Function 下都有若干基本块 BasicBlock 每个 BasicBlock下都有若干指令 instruction 在以上结构中，关键节点类的设计如下： 空心粗箭头表示类继承关系（User和Value类也是继承关系，图应该是画错了）。 实心细箭头表示聚合关系，从而形成树结构（例如每一个基本块 BasicBlock里有一条条指令 Instruction）。 1&lt;运算结果&gt; = &lt;指令类型&gt; &lt;操作数1&gt;, &lt;操作数2&gt; 操作数 Value类将操作数表示为一个类：Value，它表示能够作为操作数的对象。 例如如下乘法语句中： 1%2 = mul i32 %1, 2 按照上面的设计，%1和 2都是Value，在Java代码中都以Value类的形式存在。 操作数使用者 User类将指令的运算结果表示为一个类：User，它表示能够作为运算结果的对象，或者说是操作数的使用者。 例如如下乘法语句中： 1%2 = mul i32 %1, 2 按照上面的设计，%2是User，它 use了 %1和 2。%2在Java代码中以User类的形式存在。 User类继承Value类观察如下语句： 12%2 = mul i32 %1, 2%3 = add i32 %2, 3 乘法产生的 %2运算结果在下一条加法语句中作为了操作数。User类应该继承 Value类，这样后面的运算才能用到前面的结果。 指令 Instruction类为每一种指令类型都创建一个 Instruction指令类，这个指令类继承 User，既用来表示运算结果，也用来表示这一条指令。 如何理解”既用来表示运算结果，也用来表示这一条指令”？ 回到 User类的例子 1%2 = mul i32 %1, 2 在代码实现当中，%2是一个 Mul指令类对象。 它既表示 %2这个运算结果：Mul extends User，这意味着这个 Mul类对象可以表示运算结果；User extends Value，这意味着这个 Mul类对象还可以作为操作数。 又表示这条语句本身：Mul类是llvm语法树中，挂在BasicBlock下的一个节点，通过遍历语法树，并调用 toString()方法，即可从这个Mul类中取出目标代码 1234567891011public class Mul extends ArithmeticInstruction { public Mul(String name, BasicBlock parent, Value op1, Value op2) { super(name, parent, op1, op2); } @Override public String toString() { return getArithmeticString(&quot;mul&quot;); }} 再例如，如下中间代码，将其翻译为Java代码，可以是： 123456%1 = mul i32 1, 2%2 = mul i32 %1, %1// IrBuilder.buildxxx是封装了具体操作的工厂模式方法，// 其参数是操作数Value类，返回结果是计算结果Instruction类Mul mul1 = IrBuilder.buildMulInstruction(new ConstInt(1), new ConstInt(1))Mul mul2 = IrBuilder.buildMulInstruction(mul2, mul2) 常用的llvm指令罗列如下： LLVM IR 使用方法 简介 add &lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / sub &lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / mul &lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / sdiv &lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 有符号除法 srem &lt;result&gt; = srem &lt;type&gt; &lt;op1&gt;, &lt;op2&gt; 有符号取余 icmp &lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 比较指令 and &lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 按位与 or &lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 按位或 call &lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;) 函数调用 alloca &lt;result&gt; = alloca &lt;type&gt; 分配内存 load &lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt; 读取内存 store store &lt;ty&gt; &lt;value&gt;, ptr &lt;pointer&gt; 写内存 getelementptr &lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt;{, &lt;ty&gt; &lt;idx&gt;}* 计算目标元素的位置（数组部分会单独详细说明） phi &lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ... / zext..to &lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt; 将 ty 的 value 的 type 扩充为 ty2（zero extend） trunc..to &lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt; 将 ty 的 value 的 type 缩减为 ty2（truncate） br br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt; br label &lt;dest&gt; 改变控制流 ret ret &lt;type&gt; &lt;value&gt; , ret void 退出当前函数，并返回值 我在 LLVM IR 当中，给每条指令都写了一个类（Binary 指的是诸如 add sub mul 这样的二元指令），为了方便我对每种类型的指令进行管理和输出。 特殊的Value类：Function和BasicBlock类Function和 BasicBlock类也可以作为操作数。 例如调用指令：&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;fnptrval&gt;(&lt;function args&gt;)的实现上，我们直接将function作为了一个操作数，用来构建Call指令。 1234567891011Function function = (Function) IrSymbolTableStack.getSymbol(identToken.content); assert function != null; ArrayList&lt;Value&gt; argRValues = new ArrayList&lt;&gt;(); // 实参列表IrFactory.synValue = IrBuilder.buildCallInstruction(function, argRValues, IrFactory.curBlock); if (IrFactory.synValue.getType() instanceof CharType) { if (IrFactory.synValue instanceof ConstChar) { IrFactory.synValue = new ConstInt(32, ((ConstChar) IrFactory.synValue).getValue()); } else { IrFactory.synValue = IrBuilder.buildZextInstruction(IrFactory.synValue, IrFactory.curBlock); } } 根节点：Module类如同编译单元一样的存在，LLVM IR 文件的基本单位称为 module，我们的实验只有单 module。 内存 SSAllvm 是 SSA 形式的，但是在没有经过 mem2reg 的时候，SSA 是内存形式的，也就是说，对于每个变量，只要在定义他的时候，为他在内存中划分空间存入，在使用他的时候在取出来，这样就可以达到 SSA 的效果。这是因为 SSA 只要求我们不能改变一个已经定义的值，改变内存的内容显然并不违法 SSA。 这会导致当我们提到（也就是查询）一个局部变量的时候，其实是从符号表中取出来的是它的指针，这个过程一般发生在 LVal。一般我们会对变量干两件事情，读变量和写变量和做实参。对于读变量，一般发生在 LVal 作为 PrimaryExp 的时候发生，此时需要在 PrimaryExp 中对其进行 Load，而写变量一般发生在 LVal 在 AssignStmt 和 InStmt 中，只需要用 Store 将其写入即可。做实参要单独挑出来讲，是因为它的逻辑是与 C 需要保持一致的，他是有指针类型的，这就要求我们对他进行单独的处理。这就是内存式 SSA 的基本逻辑。 符号表正如前面所述，因为 LLVM IR 是 SSA 形式的，所以符号表中存的内容也和 C 中理解并不相同，比如说对于 1234f(){ int a = 2;} 在 C 中，我们会认为 a 在符号表中是一个 int，但是在 llvm 中，为了满足 SSA ，所以在符号表中，a 中对应的是一个指向 int 的指针，如果想要获得 a 中的内容，那么就需要使用一个 load 指令 。这就造成了某种逻辑的不一致性。更可悲的是，C 中还有 const 的概念。 12345f(){ const a = 3; int b[a] = {1, 2, 3};} 是不是可以直接也用一个指针去存他，然后用一个 load 访存呢？大概是不行的，因为下面那个语句会用到 alloca，虽然我不确定 alloca 是否可以动态分配，但是如果是下面这种，就肯定不行了 123456const a = 3;int b[a] = {1, 2, 3};f(){ } 在全局部分是没有办法使用 load 指令的，尤其是我们一般面对上面的情况，会要求求出 b 的维度信息，如果维度信息不是 3 ，而是一个 load，显然就无法求出了，这就导致面对这种情况，我们必须存一个常量到符号表中，这就更要求我们在解析的时候，知道我么你啥时候存的是常量，啥时候存的是指针，这需要额外的继承属性（也是最重要的继承属性）canCalValueDown ，其实这个属性意味着一种**“常量读”**。 符号的定义符号的定义本质是填写符号表和定义，我本来打算总结起来再写，但是感觉太冗杂了，很难理出一个头绪，所以就变成了罗列。 全局单常量如果是一个单常量，那么只需要把 ConstInitVal 求解出来，会得到一个 int ，然后在符号表中，只需要存储一个 ConstInt 就可以了。 局部单常量与全局单常量相同，依然是将 ConstInt 存入到符号表中，并没有任何问题。 全局常量数组对于常量数组的初始值，我们要求是可以在编译器求值的，所以它的每个元素的初始值一定是可以被求值的，当我们求出来它的值以后，没有办法直接在符号表中存入它的值，这是因为我们会进行类似于变量的访问： 12345678const int a[2] = {1, 2};int main(){ int i = 2; a[i]; return 0;} 这样我们是没有办法在编译时就求出 a[i] 的，所以 a 必须提供变量访问形式，这就要求他必须被当成一个全局变量，所以他确实是一个全局变量，我们在符号表中存入的其实是一个全局变量，因为在 llvm 中，全局变量本质是一个指向其内容的指针，所以其实符号表中存入的是一个指针。但是也需要注意的是，其实符号表中 a 这个东西对应了两个 Value ，一个是 GlobalVariable ，另一个是 GlobalVariable.getInitValue() 获得的 ConstArray ，这样是极其有必要的，因为对于这种情况 12345678const int a[2] = {1, 2};const int b = a[1];int main(){ int i = 2; a[i]; return 0;} b 的初始值没法使用 load 访问，所以只能用常量形式获得，所以依然是需要 ConstArray 的。 局部常量数组局部常量数组与全局常量数组类似，因为它也具有“变量”的访问形式，所以也不能仅仅在符号表中存入一个 ConstArray，而是需要利用 Alloca 分配一块内存，然后利用 gep, store （这么看比全局常量数组还有麻烦一些）将这片内存填写成正确的值。同时依然需要注意，就是我们还是需要在 Alloca 里面存入一个 ConstArray 的，这是因为我们依然需要像一个“常量”一样读取这个局部常量数组，比如说在一些常量初始化或者维度信息方面，所以还是需要存入 ConstArray 的。 全局单变量需要当成一个 GlobalVariable 处理，这是因为必须给这个单变量开辟空间，这是因为我们有可能修改这个值。 全局变量数组也需要当成一个 GlobalVariable 处理，似乎这里保证了初始值一定是常量。 全局变量声明中指定的初值表达式必须是常量表达式。 局部单变量用 Alloca 处理，最后在符号表中存入的是一个指针。 局部变量数组用 Alloca 处理，但是此时的 Alloca 是不需要像局部常量数组一样在里面存储一个 ConstArray 的，这是因为第一没有意义，第二不一定能办到。 符号的使用写变量写一个变量一般都是对于 LVal 进行操作，并不是可以写内存中的所有东西，这是因为常量是不允许写操作的，所以对于 LVal 获得的东西一定是一个指针（LVal 的本质就是在符号表中按照符号查询出对应的 Value ），然后利用 Store 指令就可以将内容写入，“写变量”这个过程本身十分简单。 比较复杂的是如何处理 LVal ，首先需要明白，对于 LVal.builIr 可以将其分为两类，一类是 canCalValue ，也就是常量形式的读（显然没有常量写），另外就是没有办法常量读的 build，对于第二种情况，除了在符号表中找到找到指针，对于数组指针，还涉及一些 gep 操作以找到正确的数组元素。 读变量读变量用于表达式当一个 LVal 用于表达式的时候（也就是参与运算的时候），可以分成两个情况讨论，如果是一个常量，那么就直接用就行了；如果是一个指针，那么就需要将其 Load 出来使用。 读变量用于实参实参和表达式计算不同在于，他可能是一个指针。而因为 C 的指针与 llvm 是不同的，比如说同样一个一维数组 a[2] ，在 C 中为 int* ，而在 llvm 中，却是 [2 x i32]* 。而当参数为 int a[] 的时候，又要求 llvm 划为 int*，这就说需要控制 gep 的数量进行降维，同时对于为指针的变量，也不能一味的 load，这样有可能将原本的指针实参给 Load 出一个整型来。 短路求值对于短路求值，并不是一件可有可无的事情，因为对于 1if (1 == 2 &amp;&amp; f()) 如果没有短路求值，那么 f() 就会被指令，如果 f() 是一个有副作用的函数（也就是对内存写了），那么就会导致 bug 的出现，所以短路求值是必要的。 实现短路求值就是将 1if (cond1 &amp;&amp; cond2) 变成 12if (cond1) if (cond2) 这样的结构，将 1if (cond1 || cond2) 变成 123456789if (cond1) { // then-block} else { if (cond2) { // then-block } else { // else-block }} 对于多个条件，只要确定好优先级，递归处理即可。 控制结构控制结构就是通过制造 BasicBlock 来对数据流进行控制。 分支ConditionNode 有两种可能，有无 else 决定了到底是 2 个 BasicBlock 或者是 3 个 BasicBlock。对于没有 else 的分支结构，只用一个三参数的 Br 就可以解决，对于有 else 的结构，只需要将 Br 的 falseBlock 调整为 else 对应的块即可。 循环需要制作出 3 个块，分别为 condBlock, bodyBlock, nextBlock ，其中 condBlock 选择跳转到 bodyBlock 或者是 nextBlock （这个部分由 LOrExp, LAndExp 自动完成 ），bodyBlock 会无条件跳转到 condBlock。 Break &amp; Continue &amp; Return这些指令面对的最大问题是为了满足基本块的定义，与这些指令所处同一基本块并位于这些指令之后的指令不应该得到翻译。我们可以直接做一个新的块，让其后的指令都依附与这个块，而入口块并没有到达这个块的方式，这样就完成了对其后指令的忽略。 此外，break, continue 都需要确定跳转的目标，break 会跳转到 nextBlock ，而 continue 会跳转到 condBlock ，但是因为循环存在嵌套结构，所以不同层的 break, continue 需要跳转到不同的层。所以在全局用一个栈维护该结构，如下所示 1234567891011/** * 处理多重循环中的continue， * 栈顶的loopEndBlock即是当前层Continue跳转的对象 */ public static Stack&lt;BasicBlock&gt; loopEndBlockStack = new Stack&lt;&gt;(); /** * 处理多次循环中的break * 栈顶的endBlock即是当前层break跳转的对象 */ public static Stack&lt;BasicBlock&gt; endBlockStack = new Stack&lt;&gt;(); 在循环的时候，进行出入栈操作 12345678IrFactory.loopEndBlockStack.push(loopEndBlock); IrFactory.endBlockStack.push(endBlock); // 解析Stmt ((StmtNode) nodes.get(nodePos)).setStmtReturnType(this.stmtReturnType); nodes.get(nodePos).buildIr(); // 完成当前解析，弹栈 IrFactory.loopEndBlockStack.pop(); IrFactory.endBlockStack.pop(); 在 break 中： 12// 强制跳转至endBlock IrBuilder.buildBrInstruction(IrFactory.endBlockStack.peek(), IrFactory.curBlock); 在 continue 中 12// 强制跳转至endLoopBlock IrBuilder.buildBrInstruction(IrFactory.loopEndBlockStack.peek(), IrFactory.curBlock); 具体架构设计IrBuilder类：指令的工厂IrBuilder类是中间代码的入口，同时也封装有构建 llvm元素的工厂模式方法。 举例来说，我们现在正要取出一个指针类型变量所指空间中的内容，可以构建一条 Load指令（当然如果是数组就需要GEP指令了），并将其插入当前所处的基本块。可以如此做： 1234567891011121314151617181920212223242526272829303132// LValNode.java，其对应文法LVal → Ident {'[' Exp ']'}，是指针的发祥地Value fParamValue = IrBuilder.buildLoadInstruction(lvalValue, IrFactory.curBlock); if (expNode == null) { IrFactory.synValue = fParamValue; } else { expNode.buildIr(); if (IrFactory.synValue.getType() instanceof CharType) { if (IrFactory.synValue instanceof ConstChar) { IrFactory.synValue = new ConstInt(32, ((ConstChar) IrFactory.synValue).getValue()); } else { IrFactory.synValue = IrBuilder.buildZextInstruction(IrFactory.synValue, IrFactory.curBlock); } } Value indexValue = IrFactory.synValue; Value ptrVal = IrBuilder.buildGetElementPtrInstruction(fParamValue, indexValue, IrFactory.curBlock); if (IrUtil.getPointingTypeOfPointer(fParamValue) instanceof ArrayType) { // System.out.println(&quot;can't delete&quot;); ptrVal = IrBuilder.buildRankDownInstruction(ptrVal, IrFactory.curBlock); } IrFactory.synValue = ptrVal;// IrBuilder.java/** * 构建加载指令 * @param pointer 要加载的地址，从这个地址处读取操作数 * @return 完成加载的Value */ public static Load buildLoadInstruction(Value pointer, BasicBlock parent) { Load load = new Load(getName(), parent, pointer); parent.addInstruction(load); return load; } IrFactory：递归下降的上下文信息刚刚我们提到，要进行基于属性翻译文法的递归下降。既然是属性翻译文法，势必涉及到综合属性（synthesized attribute)的向上传递，以及继承属性（inherited attribute）的向下传递。 得益于递归下降的方法，我们可以直接在 node类内，通过父子 node间直接调用对方的相关 setter或者 getter来粗暴地实现信息传递。 但如果我们传递的链条很长呢？譬如我们在一个 LVal内的信息，要经过好长好长的路，才能抵达真正需要该信息的 ConstExp，这时候如果还要写那么多 setter，未免也过于笨。 考虑到只有综合属性会出现这种长线的传递，我们可以在 Irc里直接记录全局的，正在传递的综合属性（们）： 12345678910111213//=========================== 综合属性 =================================/** * Value类型列表的综合属性 up向上传递 */public static ArrayList&lt;Value&gt; synValueArray = null;/** * Value类型的综合属性 up向上传递 */public static Value synValue = null;/** * int类型的综合属性 up向上传递 */public static int synInt = -114514; 中间代码的构建过程，是字面意义上拆东墙建西墙的过程，即在根据文法递归下降 扫描语法分析结果的同时，在另一边逐步（用动作符号）搭建起另一个 llvm的体系。 既然是同步在扫描两个体系，就应当有两组指针来记录扫描进度。语法分析的扫描进度（由递归下降保证外，还有当前是否在扫描常量表达式，是否在扫描函数实参，是否正在经历循环），llvm的构建进度（即当前在搭建哪个函数，哪个基本块，）都应当得到记录： 1234567891011121314151617181920212223242526272829303132/** * 当前所在基本块 */ public static BasicBlock curBlock = null; /** * 当前所在函数 */ public static Function curFunction = null; /** * 当前是否正在计算 无变量常数表达式 * 如果是，那么综合属性只需要传递synInt，且计算情况有所减少 */ public static boolean isBuildingConstExp = false; /** * 当前是否在进行全局变量的初始化 */ public static boolean isBuildingGlobalInit = false; /** * 当前是否正在构建一个int类型的实参 * 如果是，但是当前解析到的却是int*类型，那么需要load */ public static boolean isBuildingPointerRParam = false; /** * 处理多重循环中的continue， * 栈顶的loopEndBlock即是当前层Continue跳转的对象 */ public static Stack&lt;BasicBlock&gt; loopEndBlockStack = new Stack&lt;&gt;(); /** * 处理多次循环中的break * 栈顶的endBlock即是当前层break跳转的对象 */ public static Stack&lt;BasicBlock&gt; endBlockStack = new Stack&lt;&gt;(); llvm元素llvm元素主要放置在 ir/values内。 该类主要存储了 llvm体系下，该元素的要素及其相应的 getter和 setter。 此外，所有 llvm元素都实现了 buildMips()方法（及辅助方法），用于后续构建 mips体系。 因此，llvm元素类是贯穿了 llvm初步生成，中端的 mem2reg重构，mips初步生成的重要类。 举例来说，我们在基本块 BasicBlock类内，会记录这样的一些信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 前驱与后继块 */ private final HashSet&lt;BasicBlock&gt; preBlocks = new HashSet&lt;&gt;(); private final HashSet&lt;BasicBlock&gt; sucBlocks = new HashSet&lt;&gt;();// ==================支配分析==================== /** * 支配者块 */ private final ArrayList&lt;BasicBlock&gt; domers = new ArrayList&lt;&gt;(); /** * 直接支配的基本块 */ private final ArrayList&lt;BasicBlock&gt; idomees = new ArrayList&lt;&gt;(); /** * 直接支配基本块 */ private BasicBlock Idomer; /** * 在支配树中的深度 */ private int domLevel; /** * 支配边际，即刚好不被当前基本块支配的基本块 */ private final HashSet&lt;BasicBlock&gt; dominanceFrontier = new HashSet&lt;&gt;(); public ArrayList&lt;BasicBlock&gt; getDomers() { return domers; } /** * 当前块是否是另一个块的支配者 */ public boolean isDominating(BasicBlock other) { return other.domers.contains(this); } public ArrayList&lt;BasicBlock&gt; getIdomees() { return idomees; } public void setIdomer(BasicBlock idomer) { Idomer = idomer; } public void setDomLevel(int domLevel) { this.domLevel = domLevel; } public int getDomLevel() { return domLevel; } public HashSet&lt;BasicBlock&gt; getDominanceFrontier() { return dominanceFrontier; } public BasicBlock getIdomer() { return Idomer; } // =================== 循环分析 ====================== /** * 当前块直属的循环 */ private Loop loop = null; /** * 获得循环深度 * 如果不在循环中，则深度为 1 * * @return 循环深度 */ public int getLoopDepth() { if (loop == null) { return 0; } return loop.getLoopDepth(); } public void setLoop(Loop loop) { this.loop = loop; } public Loop getLoop() { return loop; } 再议 SSA现在再看回SSA： 当涉及到分支语句时，SSA会遇到一些问题，以下面这个循环为例： 1234567891011int main(){ int i = 0; i = getint(); int a = 1; a = getint(); for(; i &lt; 10; i = i + 1){ i = i + 2; a = a + 3; } return 0;} 我们会发现，对于循环的归纳变量，其注定会有两处赋值。因此同样对于 i和 a，我们需要再来一个 i1和 a1来放置这第二个赋值。 那么问题来了，在 i1和 a1的汇聚点，到底该采取哪个赋值？这时候就必须用到 phi指令。 phi 指令这个指令能够根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值。 1&lt;result&gt; = phi &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], [&lt;val1&gt;, &lt;label1&gt;] ... 有了 phi，我们就可以写出代码： 1234567891011121314151617181920define dso_local i32 @main() {b0: %i3 = call i32 @getint() %i7 = call i32 @getint() br label %b9b9: %p25 = phi i32 [ %i3, %b0 ], [ %i16, %b11 ] %p24 = phi i32 [ %i7, %b0 ], [ %i19, %b11 ] %i14 = icmp slt i32 %p25, 10 br i1 %i14, label %b10, label %b12b10: %i19 = add i32 %p24, 2 %i22 = add i32 %p25, 3 br label %b11b11: %i16 = add i32 %i22, 1 br label %b9b12: ret i32 0} 但实际上，phi指令的构建有亿点点复杂，这也太难写了！如果有一个能够摆脱SSA限制的办法就好了。 这就要用到我们之前提到的内存SSA： 这种生成存取内存的 llvm有四个特点： 每个局部变量都变为了栈上分配的空间（变量在符号表中存的其实是其 alloca 指令） 每次对局部变量的读都变成了从内存空间中的一次读（在 LValNode中实现，这也是为什么这里是指针的故乡之一！） 每次对局部变量的写都变成了对内存的一次写（每次更新一个变量的值都变成了通过 store 对变量所在内存的写） 获取局部变量的地址等价于获取内存的地址 需要进行的主要操作有： 局部变量定义时： alloca（分配变量的栈空间，返回指向该空间的指针） 将 alloca记录进入符号表。 store（给变量赋值，即向指针所指空间内进行写） 局部变量使用时： LVal: 查符号表获得指定局部变量或形参的 alloca指针 PrimaryExp: 对于LVal传上来的 alloca指针，进行 load处理 函数形参接收时： 特别地，函数的形参也类似于局部变量，我们也要将其处理为SSA形式，在栈上分配空间并赋值以代之，否则还是会遇到我们上一节分析出来的问题！ FuncFParamNode：读取形参的类型、名称，创建形参的Value FuncFParamsNode： 对于每一个形参，都进行 alloca，store，其中 store的内容就是刚创建的形参的Value。符号表中存入的也是 alloca对应的value ConstExp的处理与“后门”常量传播在我们的文法当中，有这样的声明： 常量表达式 ConstExp ConstExp -&gt; AddExp 中使用的 ident 必须是常量 何为常量？即能够在编译阶段就确定值的量，包括了常量标识符与立即数。对于常量，我们可以在编译阶段就计算出常量表达式的值，以及将常量标识符替换为其值。 为此，我们在 IrFactory里设置有字段，在 Exp系的 buildIr内，构建常量时的分类讨论的方式有所不同，且由于能够计算出int类型具体值，我们只需要进行 synInt综合属性的传递。 常量分为数组常量和非数组常量，其行为有所不同： int常量 数组常量 是否在llvm代码中显式声明 否 与普通数组变量一致，采用alloca,store 在 ConstExp下 直接求出int, char值 直接求出指定元素的int值 非 ConstExp下 直接求出int, char值 与普通数组变量一致，采用gep，load Mips 生成在llvm中，我们已经将源代码转换成了很接近中间代码的形式了：我们划分并生成了基本块，生成了几乎能一等一转化为mips的llvm指令。因此在目标代码的初步生成的过程中，我们的关注点主要在于存储管理、指令的等价翻译。 MipsBuilder：指令的工厂类在MipsBuilder中封装有构建各种指令、构建操作数的工厂模式方法。 例如构建一条 add指令并加入指定的 MipsBlock： 12345678910/** * 构建双操作数指令 * * @param type 指令类型 */ public static MipsBinary buildBinary(MipsBinary.BinaryType type, MipsOperand dst, MipsOperand src1, MipsOperand src2, BasicBlock irBlock) { MipsBinary binary = new MipsBinary(type, dst, src1, src2); MipsFactory.irBlock2MipsBlock(irBlock).addInstruction(binary); return binary; } MipsFactory：记录 llvm成分到 mips成分的映射我们是在llvm的成分类中进行的mips生成，因此需要将llvm成分与mips成分进行映射。 1234567891011121314151617181920212223242526272829/** * 获取ir函数对象 对应的 mips函数对象 * * @param irFunction ir函数对象 * @return mips函数对象 */ public static MipsFunction irFunction2MipsFunction(Function irFunction) { return functionMap.get(irFunction); } /** * 获取ir基本块对象 对应的 mips基本块对象 * * @param irBlock ir基本块对象 * @return mips基本块对象 */ public static MipsBlock irBlock2MipsBlock(BasicBlock irBlock) { return blockMap.get(irBlock); } /** * 获取ir Value对象 对应的 mipsOperand对象 * * @param irValue ir Value对象 * @return mipsOperand对象 */ public static MipsOperand irValue2MipsOp(Value irValue) { return opMap.get(irValue); } llvm的成分类：mips生成的主要场所通过遍历 llvm的树形结构来生成 mips，遍历在 ir/values下的各个value类进行，他们都实现了父类 Value的 buildMips()方法。 backend/instructions: Mips指令类指令类都继承了 MipsInstruction类，该类内有 src操作数和 dst操作数的相应管理方法，包括 use，def的记录，用于活跃变量分析，以及后续寄存器分配时，对虚拟寄存器进行查询、替换。 backend/operands: 操作数类该包内的类均可以作为 mips指令的操作数，具体来说有立即数、虚拟寄存器、物理寄存器、标签。 物理寄存器的相关配置在 RegType枚举类中，记录了物理寄存器的编号、名称、何者需要在函数调用时保存、何者能够作为全局寄存器分配等信息。 构建流程带有虚拟寄存器的mips的总体构建流程如下： 构建.data段构建.data段主要是在翻译 llvm的全局变量元素 GlobalVariable。 先前在 llvm生成过程中，我们将需要 printf输出的字符串重新分配为了全局常量字符串，因此这里全局变量共有三类：字符串、int变量、int数组。依次构建 mipsGlobalVariable，然后加入 MipsModule即可。 123456789101112131415161718192021222324252627282930313233343536373839404142@Override public void buildMips() { MipsGlobalVariable mipsGlobalVariable = null; // 无初始值错误 if (initValue == null) { System.out.println(&quot;[buildMips] GlobalVariable：initValue == null&quot;); } // 未初始化的全局数组 else if (initValue instanceof ZeroInitializer) { mipsGlobalVariable = new MipsGlobalVariable(getName(), initValue.getType().getSize()); } // 常量字符串 else if (initValue instanceof ConstString) { mipsGlobalVariable = new MipsGlobalVariable(getName(), ((ConstString) initValue).getContent()); } // int变量 else if (initValue instanceof ConstInt) { mipsGlobalVariable = new MipsGlobalVariable(getName(), new ArrayList&lt;&gt;() {{ add(((ConstInt) initValue).getValue()); }}, MipsGlobalVariable.GVType.Int); } else if (initValue instanceof ConstChar) { mipsGlobalVariable = new MipsGlobalVariable(getName(), new ArrayList&lt;&gt;() {{ add(((ConstChar) initValue).getValue()); }}, MipsGlobalVariable.GVType.Char); } // int | Char数组 else if (initValue instanceof ConstArray) { ArrayList&lt;Integer&gt; inits = new ArrayList&lt;&gt;(); if (((ConstArray) initValue).getElements().get(0).getType() instanceof IntType) { for (Constant element : ((ConstArray) initValue).getElements()) { inits.add(((ConstInt) element).getValue()); } mipsGlobalVariable = new MipsGlobalVariable(getName(), inits, MipsGlobalVariable.GVType.Int); } else { for (Constant element : ((ConstArray) initValue).getElements()) { inits.add(((ConstChar) element).getValue()); } mipsGlobalVariable = new MipsGlobalVariable(getName(), inits, MipsGlobalVariable.GVType.Char); } } MipsModule.addGlobalVariable(mipsGlobalVariable); } 为所有Block和Function创建Mips对象，并映射到llvm的相应对象没有太多可说的，作用主要是方便在后续遍历语句时，能够方便地引用函数和基本块（用于call、br等llvm指令的翻译） 123456789101112131415161718192021222324252627282930/** * 将中间代码的函数和基本块对象: * 1.构建mips里的相应对象 * 2.加入Module * 3.信息存储到mips对象里 */ private void mapFunctionBlockIr2Mips() { // 遍历所有函数 for (Function irFunction : functions) { // 构建函数对象 MipsFunction mipsFunction = new MipsFunction(irFunction.getName(), irFunction.isLibFunc()); MipsFactory.addFunctionMapping(irFunction, mipsFunction); MipsModule.addFunction(mipsFunction); // 构建基本块对象 ArrayList&lt;BasicBlock&gt; blocks = irFunction.getBasicBlocks(); for (BasicBlock irBlock : blocks) { MipsBlock mipsBlock = new MipsBlock(irBlock.getName(), irBlock.getLoopDepth()); MipsFactory.addBlockMapping(irBlock, mipsBlock); } // 记录mipsBlock的前驱块信息, 前驱块当然也是mipsBlock for (BasicBlock irBlock : blocks) { MipsBlock mipsBlock = MipsFactory.irBlock2MipsBlock(irBlock); for (BasicBlock irPreBlock : irBlock.getPreBlocks()) { mipsBlock.addPreBlock(MipsFactory.irBlock2MipsBlock(irPreBlock)); } } } } 遍历 llvm的树形结构依序遍历 llvm的所有函数、所有基本块、所有指令，进行翻译。 具体构建难点实际上，将 LLVM指令挨个翻译成 MIPS指令并不困难，我们重点讲一下翻译成 Mips时函数调用的部分，这是一大难点，至于寄存器分配则放到优化部分详述。 Call：参数传递Call的作用是调用函数，理所当然地，在mips中需要我们手动进行实参的传递，同时记录 MipsCall指令对于寄存器的修改（即def）。 对于前四个参数，保存在 a0-a3里即可。对于更多的参数，需要保存在栈上。 调用函数在调用者处的准备工作，都由Call进行翻译。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Override public void buildMips() { MipsBuilder.buildComment(this.toString(), getParent()); MipsBlock mipsBlock = MipsFactory.irBlock2MipsBlock(getParent()); MipsFunction mipsFunction = MipsFactory.irFunction2MipsFunction(function); // 先构建出call指令，后续要记录该指令用到的A寄存器 // ！这也是唯一一次使用野生未封装的new MipsInstruction MipsInstruction call; // 内建函数，需要宏调用 if (function.isLibFunc()) { call = new MipsMacro(mipsFunction.getName()); // 系统调用必然改变 v0, v0加入def call.addDefReg(MipsRealReg.V0); // TODO: addDefReg 双参数修改为单参数 } // 非内建函数，直接构建jal指令即可 else { call = new MipsCall(mipsFunction); } // 进行传参, 遍历所有irValue参数 int argc = getArgs().size(); for (int i = 0; i &lt; argc; i++) { Value irArg = getArgs().get(i); MipsOperand src; // 前四个参数存储在a0-3内 if (i &lt; 4) { src = MipsBuilder.buildOperand(irArg, true, MipsFactory.curIrFunction, getParent()); MipsMove move = MipsBuilder.buildMove(new MipsRealReg(&quot;a&quot; + i), src, getParent()); // 加入use，保护寄存器分配时不消除move call.addUseReg(move.getDst()); } // 后面的参数先存进寄存器里，再store进内存 else { boolean isByte = irArg.getType() instanceof CharType; // 要求存入寄存器 src = MipsBuilder.buildOperand(irArg, false, MipsFactory.curIrFunction, getParent()); // 存入 SP - 4 * nowNum 处 MipsImm offsetOperand = new MipsImm(-(argc - i) * 4); MipsBuilder.buildStore(src, MipsRealReg.SP, offsetOperand, getParent(), isByte); } } // 栈的生长 if (argc &gt; 4) { // 向下生长4 * allNum: SP = SP - 4 * allNum MipsOperand offsetOperand = MipsBuilder.buildImmOperand(4 * (argc - 4), true, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildBinary(MipsBinary.BinaryType.SUBU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent()); } // 参数准备妥当后，再执行jal指令 mipsBlock.addInstruction(call); // 这条语句执行完成的场合，恰是从函数中返回 // 栈的恢复 与生长相反，做加法即可 if (argc &gt; 4) { MipsOperand offsetOperand = MipsBuilder.buildImmOperand(4 * (argc - 4), true, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildBinary(MipsBinary.BinaryType.ADDU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent()); } // 因为寄存器分配是以函数为单位的，所以相当于 call 指令只需要考虑在调用者函数中的影响 // 那么 call 对应的 bl 指令会修改 lr 和 r0 (如果有返回值的话) // 此外，r0 - r3 是调用者保存的寄存器，这会导致可能需要额外的操作 mov ，所以这边考虑全部弄成被调用者保存 for (int i = 0; i &lt; 4; i++) { call.addDefReg(new MipsRealReg(&quot;a&quot; + i)); } // 非内建函数需要保存返回地址 ra if (!function.isLibFunc()) { call.addDefReg(MipsRealReg.RA); } // 处理返回值 // 调用者应当保存 v0，无论有没有返回值 ValueType returnType = function.getReturnType(); call.addDefReg(MipsRealReg.V0); // 带有返回值，则需要记录该返回值 if (!(returnType instanceof VoidType)) { MipsOperand dst = MipsBuilder.buildOperand(this, false, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildMove(dst, MipsRealReg.V0, getParent()); } } MipsFunction：保存现场MipsFunction是Mips函数对象。 在与Call的关系中，MipsFunction是被调用的一方，由MipsFunction负责保存现场。 如下方法能够记录在本函数内有改动（def）的寄存器，同时计算栈帧大小。这些寄存器在返回调用者后可能有改变，需要保存在栈帧内。 1234567891011121314151617181920212223242526272829303132333435363738/** * 栈上的空间从上到下依次为： * 1.调用者保存的寄存器 * 2.其他alloca * 3.参数alloca */ public void rebuildStack() { // 遍历下属所有语句，记录所有用过的寄存器，作为函数调用前要保存的现场 for (MipsBlock block : blocks) { for (MipsInstruction instruction : block.getInstructions()) { // 保存写过的寄存器(的类型) for (MipsOperand defReg : instruction.getDefRegs()) { if (defReg instanceof MipsRealReg) { RegType regType = ((MipsRealReg) defReg).getType(); if (RegType.regsNeedProtection.contains(regType)) { regsNeedSaving.add(regType); } } else { System.out.println(&quot;[MipsFunction] defReg中混入了非物理寄存器！&quot;); } } } } // 需要分配的用于保存现场的空间 int stackRegSize = 4 * regsNeedSaving.size(); System.out.println(stackRegSize); for (RegType regType : regsNeedSaving) { System.out.println(regType); } // 总的空间大小：alloca空间 + 保存现场的空间 totalStackSize = stackRegSize + allocaSize; // 更新先前记录的 保存在栈上的参数 的位移 for (MipsImm argOffset : argOffsets) { int newOffset = argOffset.getValue() + totalStackSize; argOffset.setValue(newOffset); }// System.out.println(&quot;重建函数栈&quot; + getName() + &quot;, stackRegSize:&quot; + stackRegSize + &quot;, allocaSize:&quot; + allocaSize); } 保存现场的具体代码则直接放在了 MipsFunction的打印处，实际上没有加入指令序列。 123456789101112131415161718192021222324252627282930313233343536373839/** * 需要输出： * 函数 label * 保存被调用者寄存器 * 移动栈指针 sp * 基本块的mips代码 */ @Override public String toString() { if (isLibFunc) { return &quot;&quot;; } StringBuilder sb = new StringBuilder(); sb.append(name).append(&quot;:\\n&quot;); // 非主函数需要保存寄存器 if (!name.equals(&quot;main&quot;)) { // 保存现场 int stackOffset = -4; for (RegType regType : regsNeedSaving) { // 保存位置：-stackOffset($SP) sb.append(&quot;\\t&quot;).append(&quot;sw\\t&quot;).append(regType).append(&quot;,\\t&quot;) .append(stackOffset).append(&quot;($sp)\\n&quot;); // 继续向下生长 stackOffset -= 4; } } // $SP = $SP - totalStackSize if (totalStackSize != 0) { sb.append(&quot;\\taddiu\\t$sp,\\t$sp,\\t&quot;).append(-totalStackSize).append(&quot;\\n&quot;); }// System.out.println(blocks); // 生成基本块的mips for (MipsBlock block : blocks) { sb.append(block); } return sb.toString(); } MipsRet：恢复现场MipsRet是Mips的返回指令对象，由llvm的Ret指令直接翻译而来。 Ret对象会记录其所属的MipsFunction，以方便地取用寄存器的保存信息。 同样地，恢复现场的具体代码则直接放在了 MipsRet的打印处，实际上没有加入指令序列。 123456789101112131415161718192021222324252627@Override public String toString() { StringBuilder sb = new StringBuilder(); int stackSize = function.getTotalStackSize(); // 返回前将SP复位 if (stackSize != 0) { sb.append(&quot;addiu\\t$sp, \\t$sp,\\t&quot;).append(stackSize).append(&quot;\\n&quot;); } // 主函数直接结束运行 if (function.getName().equals(&quot;main&quot;)) { sb.append(&quot;\\tli\\t$v0,\\t10\\n&quot;); sb.append(&quot;\\tsyscall\\n\\n&quot;); } // 非主函数，需要恢复现场 else { // 在返回之前回复寄存器寄存器 int stackOffset = -4; for (RegType regType : function.getRegsNeedSaving()) { sb.append(&quot;\\t&quot;).append(&quot;lw\\t&quot;).append(regType).append(&quot;,\\t&quot;).append(stackOffset).append(&quot;($sp)\\n&quot;); stackOffset -= 4; } // 跳转返回 sb.append(&quot;\\tjr\\t$ra\\n&quot;); } return sb.toString(); } 代码优化总论优化分为两类，一类是分析型优化，这种类型的优化并不会改变 llvm ir 的结构，所以也不会有实际的优化效果，但是它们分析出来的信息，会去指导加工型优化的进行。另一种是加工型优化，这种优化会真正改变 llvm ir &amp; mips 的结构，达到优化的目的。 控制流图构建在构建控制流图之前，我们先进行简单的死代码删除： 该部分会删除所有 ret指令后的代码。 这其实是为了解决在debug时发现的一个严重错误：为了确保在构建控制流图时，不会产生奇怪的后继，从而导致控制流图构建错误、phi指令报错。 在遇到 ret指令后，删除所有指令即可。 123456789101112public static void deadCodeEmit(BasicBlock block) { LinkedList&lt;Instruction&gt; instructions = new LinkedList&lt;&gt;(block.getInstructions()); boolean flag = false; for (Instruction instruction : instructions) { if (flag) { instruction.dropAllOperands(); instruction.eraseFromParent(); } else if (instruction instanceof Ret || instruction instanceof Br) { flag = true; } } } 支配分析 [!IMPORTANT] 在进行很多分析之前，都需要进行支配分析，这是因为支配树会提供很多的支配流信息，尤其是数据是怎样在数据块中流动，哪些数据必然从这个块流入另一个块，可以说，支配信息是对于 CFG 图的一种高度凝练的表达。 在求解支配树的时候，分为两步，第一步首先支配者和被支配者，这是一个不动点问题，利用的公式是 $$temp = {index} \\cup (\\bigcap_{j \\in preds(index)} domer(j) )$$ [!IMPORTANT] 需要一直求解到不发生变化为止。 第二步是计算支配边界，构造支配树，支配树是比原来的支配图更加直观而且“强”的条件，我们在优化中一般也是使用支配树的信息条件。所谓支配边界，就是恰好不被支配的一个块。 需要强调，支配树不仅应用在编译领域，这是一个很常见的图论算法，所以可以在网上找到详实的资料，所以对于算法问题就不赘述。 支配分析基于 CFG图会被用在 LoopInfoAnalyze， mem2reg，所以只要 CFG 发生改变，就会需要重新分析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 计算支配信息 * * @param function 待分析的函数 */ public static void passDominanceInfo(Function function) { // 入口块 BasicBlock entryBlock = function.getHeadBlock(); // 基本块的数目 int blockNum = function.getBasicBlocks().size(); // 每个基本块都有一个 bitSet，用于表示这个块的 domer ArrayList&lt;BitSet&gt; domers = new ArrayList&lt;&gt;(blockNum); ArrayList&lt;BasicBlock&gt; blocks = function.getBasicBlocks(); // 作为 block 的索引 int index = 0; for (BasicBlock block : blocks) { domers.add(new BitSet()); // 入口块的支配者是自己 if (block == entryBlock) { domers.get(index).set(index); } else { domers.get(index).set(0, blockNum); } index++; } // 不动点算法 计算domer boolean changed = true; while (changed) { changed = false; index = 0; // 遍历基本块 for (BasicBlock curBlock : blocks) { // 对于非入口块 if (curBlock != entryBlock) { // temp 初始全置1 BitSet temp = new BitSet(); temp.set(0, blockNum); // 就是下面的公式 // temp &lt;- {index} \\cup (\\BigCap_{j \\in preds(index)} domer(j) ) for (BasicBlock preBlock : curBlock.getPreBlocks()) { int preIndex = blocks.indexOf(preBlock); temp.and(domers.get(preIndex)); } // 自己也是自己的domer temp.set(index); // 若temp更新，则temp 赋给domer if (!temp.equals(domers.get(index))) { domers.get(index).clear(); domers.get(index).or(temp); changed = true; } } index++; } } // 将domer信息存入所有基本块 for (int i = 0; i &lt; blockNum; i++) { BasicBlock curBlock = blocks.get(i); BitSet domerInfo = domers.get(i); // 遍历bitset，找到并记录每一个支配者 for (int domerIndex = domerInfo.nextSetBit(0); domerIndex &gt;= 0; domerIndex = domerInfo.nextSetBit(domerIndex + 1)) { BasicBlock domerBlock = blocks.get(domerIndex); curBlock.getDomers().add(domerBlock); } } // 计算所有基本块的：直接支配者 直接被支配者 for (BasicBlock curBlock : blocks) { // 遍历当前块的支配者 for (BasicBlock maybeIdomerBlock : curBlock.getDomers()) { // 排除自身 if (maybeIdomerBlock != curBlock) { boolean isIdom = true; for (BasicBlock domerBlock : curBlock.getDomers()) { // maybeIdomerBlock支配了domerBlock，domerBlock支配curBlock，表明并不是直接的支配者 if (domerBlock != curBlock &amp;&amp; domerBlock != maybeIdomerBlock &amp;&amp; domerBlock.getDomers().contains(maybeIdomerBlock)) { isIdom = false; break; } } // 是直接支配块，则双方都要互相登记 if (isIdom) { curBlock.setIdomer(maybeIdomerBlock); maybeIdomerBlock.getIdomees().add(curBlock); break; } } } } // calculate dom level passDominanceLevel(entryBlock, 0); } 函数调用分析 [!IMPORTANT] 如果在调用者和被调用者之间构建一条有向边，那么就可以构建一个函数调用图，函数调用关系主要是为了后面的副作用分析，无用函数删除做准备。在实际应用中，一般不会单独作为一个 pass ，这是因为这个用的很多，基本上是随用随做。 因为 SysY并不支持函数声明，所以其实不会出现循环递归或者其他的阴间情况，这无疑对后面是一个好消息。 副作用分析 [!IMPORTANT] 所谓的副作用（SideEffect），其实没有一个明确的概念，大概就是我们不喜欢的作用，就会被叫做副作用。在中端的副作用，指的是某个指令或者函数，会不会对内存或者 IO 造成影响，如果不会，那么就是没有副作用的。 没有副作用的东西很良好，因为他们造成的唯一影响只能通过返回值，所以如果返回值没有用到，那么这个东西就可以去掉了。不仅仅是去掉这么暴力，如果没有副作用，相当于有了一个很“强”的条件保证，我们对于某些优化的进行会变得更加自信，比如说一个函数如果没有副作用，我们就可以直接把他当成一条指令处理，对于 12%i1 = call i32 f(%a1);%i2 = call i32 f(%a1); [!IMPORTANT] 我们可以直接判断 i1 == i2 是很好的东西。 进行副作用分析的时候，需要先构建一个函数调用关系图，这是因为有的函数本身并不会造成副作用，但是他调用的函数就会有副作用，导致调用这个函数也会有副作用。 我们一般认为这几个东西有副作用 store 指令 call 内联函数 call 有副作用的函数 副作用分析会被用在 AggressiveDeadCodeEmit 中。 Mem2Reg在 LLVM生成部分中，我们已经了解了SSA的两种形式：走访存后门的SSA，和真正能提高效率的采取 phi的真SSA 。 在这一步，我们将进行如下两项工作以重构llvm代码： 后门SSA中，繁复 alloca,store,load三件套的彻底铲除优化。 phi指令的插入与变量的重命名。 [!IMPORTANT] 一个基本块的开始需要插入一个变量的 phi 节点的条件，是这个基本块是这个变量某个定义的支配边界。这个操作需要迭代，事实上就只需要建立一个队列，每次取出队首，计算其支配边界，并把新算出的支配边界插入到队列的末尾。 注意，这时的 phi 节点还是空的，即只有左值没有右值。 简单的运算强度削弱即对于 a * 0, 0 / a, a % 1, a / a这一类指令提前完成优化，避免繁复计算 Aggressive Dead Code Emit [!IMPORTANT] 在这一步中我们认为的死代码，就是不会对程序造成影响的代码，我们可以用与“副作用分析”类似的眼光去看，所有的访存指令，return 指令，call 一个有副作用的函数，分支指令，这些东西都是有用的，我们不能删除，那么这些指令使用到的指令，同样也是不能删除的，以此类推，这样求出一个有用指令的闭包，所有不在这个指令闭包内的指令，都是死代码，是可以删除的。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * DFS求解闭包 */ private void findUsefulClosure(Instruction instruction) { if (!usefulInstrClosure.contains(instruction)) { // 记录所有用到的指令 usefulInstrClosure.add(instruction); for (Value operand : instruction.getOperands()) { if (operand instanceof Instruction) { findUsefulClosure((Instruction) operand); } } } } private void deleteDeadInstructions(Function curFunction) { usefulInstrClosure.clear(); for (BasicBlock basicBlock : curFunction.getBasicBlocks()) { for (Instruction instruction : basicBlock.getInstructions()) { if (isUseful(instruction)) { findUsefulClosure(instruction); } } } // 删除不在闭包内的指令 for (BasicBlock basicBlock : curFunction.getBasicBlocks()) { LinkedList&lt;Instruction&gt; newInstructions = new LinkedList&lt;&gt;(); for (Instruction instruction : basicBlock.getInstructions()) { boolean delete = false; if (!usefulInstrClosure.contains(instruction)) { instruction.dropAllOperands(); delete = true; //instruction.eraseFromParent(); } if (!delete) { newInstructions.add(instruction); } } basicBlock.setInstructions(newInstructions); } } 全局变量局部化 [!IMPORTANT] 因为全局变量的访问需要在 llvm 中访存，比较低效，所以考虑对于只被一个函数使用了的全局变量（这就没有意义是全局的了），将其移入成局部变量。 乘除法优化对于处理器来说，执行乘除法的代价要远大于执行其他指令，而执行除法的代价又远大于乘法的代价，所以我们理想的情况是通过算术运算将除常数转化为乘法和移位指令，将乘常数转化为移位和其他指令。 乘法优化乘法可以被优化成加法和移位操作，因为乘法的代价是 4，所以加法和移位操作最多有 3 条，那么考虑“移位-加法-移位”的组合，那么也就是可以拆出两条移位指令，那么可以枚举 32 位内由上述组合可以达到的组合，然后记录下来。在乘法运算的时候，可以按照事先准备的进行操作。 除法优化对于任何处理器，进行除法计算所需要的时间都远远高于乘法和移位运算（当然这两者也不在一个量级上），所以我们有一种想法，就是把除法转换成乘法和移位操作，也就是 $$\\tt{quotient = \\frac{dividend}{divisor} = (dividend \\times multiplier) &gt;&gt; shift}$$ 具体实现则参考了教程所给论文：Division by Invariant Integers using Multiplication。 图着色寄存器分配首先以函数为单位，对其所有基本块进行活跃变量分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 对一个函数以块为单位进行活跃变量分析 * * @return 一个每个 block 都对应的一个 info 的 map */ public static HashMap&lt;MipsBlock, BlockLiveVarInfo&gt; liveAnalysis(MipsFunction func) { HashMap&lt;MipsBlock, BlockLiveVarInfo&gt; liveInfoMap = new HashMap&lt;&gt;(); // 开始遍历每一个 block for (MipsBlock block : func.getMipsBlocks()) { BlockLiveVarInfo blockLiveInfo = new BlockLiveVarInfo(); liveInfoMap.put(block, blockLiveInfo); // 开始遍历 block 中的指令, 跟定义中的一模一样 for (MipsInstruction instruction : block.getInstructions()) { // 还没定义就被使用，这里是正确的 instruction.getUseRegs().stream() .filter(MipsOperand::needsColor) .filter(use -&gt; !blockLiveInfo.liveDef.contains(use)) .forEach(blockLiveInfo.liveUse::add); // 还没使用就被定义，这里应该是错误的，因为定义就是定义，就是杀死，不会因为使用而不杀死 instruction.getDefRegs().stream() .filter(MipsOperand::needsColor) .forEach(blockLiveInfo.liveDef::add); } // 这里应该是没有问题的 blockLiveInfo.liveIn.addAll(blockLiveInfo.liveUse); } // 不动点 boolean changed = true; while (changed) { changed = false; // 开始遍历 func 中的 block for (MipsBlock block : func.getMipsBlocks()) { BlockLiveVarInfo blockLiveInfo = liveInfoMap.get(block); HashSet&lt;MipsOperand&gt; newLiveOut = new HashSet&lt;&gt;(); // 下面是加入两个后继,这里是正确的，LiveOut 就是 LiveIn 的并集 if (block.getTrueSucBlock() != null) { BlockLiveVarInfo sucBlockInfo = liveInfoMap.get(block.getTrueSucBlock()); newLiveOut.addAll(sucBlockInfo.liveIn); } if (block.getFalseSucBlock() != null) { BlockLiveVarInfo sucBlockInfo = liveInfoMap.get(block.getFalseSucBlock()); newLiveOut.addAll(sucBlockInfo.liveIn); } // 第一次的时候应该是没有办法 equal 的，这是因为之前 liveOut 并没有被赋值 if (!newLiveOut.equals(blockLiveInfo.liveOut)) { changed = true; blockLiveInfo.liveOut = newLiveOut; // 这里模拟的是 LiveUse blockLiveInfo.liveIn = new HashSet&lt;&gt;(blockLiveInfo.liveUse); // liveIn = liveUse + liveOut - liveDef blockLiveInfo.liveOut.stream() .filter(objOperand -&gt; !blockLiveInfo.liveDef.contains(objOperand)) .forEach(blockLiveInfo.liveIn::add); } } } return liveInfoMap; } 基于活跃变量分析的结果，我们就可以开始图着色算法了： 主要流程如下，遍历所有函数，对于每个函数，进行活跃变量分析直至不再变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 进行寄存器分配 * 入口方法 */ public void buildRegs() { // 遍历所有函数 for (MipsFunction function : mipsModule.getFunctions()) { if (function.isLibFunc()) { continue; } curFunction = function; // 对于每个函数，进行活跃变量分析直至不再变化 boolean finished = false; while (!finished) { initStatus(); buildConflictGraph(); buildWorklist(); do { if (!simplifyList.isEmpty()) { doSimplify(); } if (!mergableMoves.isEmpty()) { coalesce(); } if (!freezeList.isEmpty()) { doFreeze(); } if (!spillList.isEmpty()) { doSelectSpill(); } } while (!(simplifyList.isEmpty() &amp;&amp; mergableMoves.isEmpty() &amp;&amp; freezeList.isEmpty() &amp;&amp; spillList.isEmpty())); assignColors(function); // 实际溢出的节点 if (spilledNodes.isEmpty()) { finished = true; } // 存在实际溢出的点 else { try { rewriteProgram(function); } catch (Exception e) { System.out.println(&quot;[RewriteProgramException] &quot; + e + &quot;, function: &quot; + function.getName()); } } } } // 因为在 color 的时候，会把 isAllocated 设置成 true，这个函数的功能就是设置成 false // 应该是为了避免物理寄存器在判定 equals 时的错误 resetRealRegState(); for (MipsFunction function1 : mipsModule.getFunctions()) { if (function1.isLibFunc()) { continue; } function1.rebuildStack(); } } 构造冲突图(build)本阶段的主要任务是通过数据流分析方法，计算在每条指令执行时同时活跃的临时变量，该集合的每一对临时变量两两形成一条边加入冲突图中， 构造阶段的主要工作是进行数据流分析，分为两个阶段：基本块的数据流分析，指令间的数据流分析，得到冲突图，指令冲突的条件是在变量定义处所有出口活跃的变量和定义的变量是互相冲突的，以及同一条指令的出口变量互相之间是冲突的。 简化（simplify）进行启发式图着色，删除度数小于K（通用寄存器个数）的节点，简化冲突图，产生更多图着色机会。 具体的做法是对于一个节点m，如果它的度数小于K，那么将它从冲突图当中删除，并且将其压入栈中，以便进行后续的着色。 这样进行启发式删除之后，都会减少其他结点的度数，从而产生更多的简化的机会，并且也为之后的合并提供更多机会，这要求在这个阶段不会简化非冻结指令。 合并（coalesce）进行保守的合并，减少最终代码的move指令。 对于move指令（例如 move $2, $3），源操作数和目的操作数实际上相同，这种情况下可以将两个节点合并，减少一条move指令的代价，但是，合并两个结点之后，两个节点的活跃范围会增加，其邻接结点的集合实际上是原来两个集合的并集，这种情况下可能会导致一些能够着色的节点变为被溢出的结点，这样就得不偿失了，因此我们给出的一种策略是在合并的时候进行判断，保证合并之后高度数（度数&gt;=K）的结点不会增加。通过简化之后，冲突图很多节点的度数已经降低，所以这个时候合并的机会可能多于原有的冲突图。 合并的效果通常决定了整个图着色算法的质量，另外由于在进行指令选择之前需要消PHI，会在这个时候产生很多冗余的move指令，通过图着色的时候进行合并能够极大的减少冗余的move指令，这对程序性能的提升非常大。 冻结（freeze）在进行简化和合并之后，有一些变量无法进行合并，并且可以进行简化，这个时候需要将其标记为传送冻结的结点，重新开始简化阶段。 溢出（spill）简化和合并完成之后，冲突图中只剩下高度数（度数&gt;=K）的节点，这个时候我们需要在图中选择一个高度数的结点，将它存入内存当中，然后将它压入栈中。这个时候其他结点的度数降低，可以继续进行简化。 选择（select）对虚拟寄存器指派颜色，即分配真实的寄存器。具体做法是以一个空图开始，从栈中弹出一个节点，加入到冲突图中，并且为他指派一种颜色，该节点必须是可着色的，可着色的条件是其邻接结点使用的颜色小于真实的寄存器数K，对于简化阶段入栈的变量显然一定能够着色，对于溢出阶段入栈的变量，通过合并之后，邻接点中有一些变量的颜色相同，最后邻接点的颜色小于K种，能够进行着色，可以将其加入冲突图中，否则将其加入无法进行着色的集合中。 重新开始(restart)如果无法进行着色的集合不为空，那么则需要改写程序，为这些变量在内存当中分配空间，并且在每次使用需要将其从内存当中取出，每次修改需要存进内存当中，这种情况下，溢出的临时变量会转变为几个活跃范围很小的新的临时变量，这个时候需要重新进行活跃分析、寄存器分配，直到没有溢出和简化为止（通常只需要迭代一两次）。 窥孔优化对于相邻的部分少量指令进行优化。 处理无意义的加减法 旧指令 新指令 add/sub r0, r0, 0 删除 add/sub r0, r1, 0 move r0, r1 处理无意义的mov 旧指令 新指令 move r0, r0 删除 处理对同一个dst的连续mov 旧指令 新指令 move r0, r1 move r0, r2 … move r0, rk move r0, rk 处理向相邻块或者无意义块的跳转 旧指令 新指令 j next_block Move r0, rk 处理向同一个地址的存储+加载的store+load对 旧指令 新指令 store a, memory load b, sameMemory move b, a","link":"/2025/08/14/compiler/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/08/13/hello-world/"}],"tags":[{"name":"OO","slug":"OO","link":"/tags/OO/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"compiler","slug":"compiler","link":"/tags/compiler/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"大二下课上","slug":"大二下课上","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E4%B8%8A/"},{"name":"大三上课上","slug":"大三上课上","link":"/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E4%B8%8A/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}],"pages":[{"title":"About Me","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 👋 你好，我是 RooKie_Z🎓 个人简介我是一名北京航空航天大学的计算机科学与技术专业的本科生，对人工智能、软件工程、编译器技术等方向有着浓厚兴趣。在学习过程中，我注重理论与实践结合，参与过多项课程项目与科研实习，积累了扎实的编程能力和项目管理经验。 🚀 技术栈 编程语言: C++, Java, Python, JavaScript, Go 开发工具: IntelliJ IDEA, CLion, PyCharm, GoLand, VS Code 框架与技术: Django, Qt, Vue.js, Pytorch, Hexo 数据库: MySQL 操作系统: Linux, macOS, Windows 📚 学习与实践 面向对象设计与构造 (OO): 担任课程助教与高阶助教，负责命题与指导学生项目实现。 科研实习: 参与大语言模型越狱攻击研究，积累了人工智能安全方向的实验与分析经验。 软件工程项目: 担任“科研文献助手”项目经理及AI功能负责人，带领团队完成从需求分析到功能实现的全流程，并与导师合作推进项目迭代。 🏆 荣誉与奖项 多次获得校级奖学金与学科竞赛奖项 全国大学生英语竞赛北京市二等奖 全国大学生数学竞赛北京市一等奖 美国大学生数学建模竞赛 Meritorious Winner 互联网+北京赛区三等奖 🌟 兴趣爱好 算法与编程竞赛 开源项目贡献 技术写作与分享 阅读与探索新技术 💌 联系方式 GitHub: RooKie_Z 邮箱：RooKie_Z 博客: RooKie_Z的小窝 💡 座右铭 “Ever tried, Ever failed, No matter. Try again, Fail again, Fail better.” —— 塞缪尔·贝克特 感谢访问我的博客！如果你对我的项目或技术文章有任何问题或建议，欢迎随时交流。","link":"/about.html"},{"title":"MathJax 数学公式测试","text":"🧮 MathJax 数学公式测试页面1. 行内公式测试这是一个行内公式：$E = mc^2$，爱因斯坦的质能方程。 另一个行内公式：$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$，高斯积分。 2. 块级公式测试二次方程求根公式： $$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ 欧拉公式： $$e^{i\\pi} + 1 = 0$$ 傅里叶变换： $$F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$$ 3. 复杂公式测试矩阵乘法： $$\\begin{pmatrix}a &amp; b \\c &amp; d\\end{pmatrix}\\begin{pmatrix}e &amp; f \\g &amp; h\\end{pmatrix} =\\begin{pmatrix}ae+bg &amp; af+bh \\ce+dg &amp; cf+dh\\end{pmatrix}$$ 积分方程： $$\\int_{0}^{1} \\frac{x^n}{1+x} dx = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{n+k+1}$$ 极限公式： $$\\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n = e$$ 4. 中文混合公式测试当 $x \\to 0$ 时，$\\sin x \\approx x$，这是正弦函数在原点附近的线性近似。 对于任意实数 $a$ 和 $b$，都有：$(a+b)^2 = a^2 + 2ab + b^2$ 5. 特殊符号测试希腊字母： $\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\zeta, \\eta, \\theta$ 数学符号： $\\sum, \\prod, \\int, \\oint, \\nabla, \\partial, \\infty$ 关系符号： $\\leq, \\geq, \\neq, \\approx, \\equiv, \\propto$ 如果上面的数学公式都能正确显示和居中，说明 MathJax 配置成功！","link":"/math-test.html"},{"title":"功能测试页面","text":"🧪 功能测试页面 /* 内联样式测试 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background:rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"success\"] { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"warning\"] { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 内联JavaScript测试 document.addEventListener('DOMContentLoaded', function() { console.log('内联JavaScript加载成功！'); // 处理警告框 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; console.log('处理警告框:', calloutType); } } }); }); 1. 颜色类测试这是CadetBlue颜色的文本 这是蓝色文本 这是绿色文本 这是红色文本 这是橙色文本 这是紫色文本 2. 警告框测试 [!IMPORTANT]这是一个重要的警告框测试 [!CAUTION]这是一个注意提示框测试 [!NOTE]这是一个提示信息框测试 [!SUCCESS]这是一个成功信息框测试 [!WARNING]这是一个警告信息框测试 3. 强调文本测试这是强调文本 这是警告文本 这是成功文本 这是错误文本 如果上面的样式都正常显示，说明内联样式和JavaScript工作正常！","link":"/test.html"},{"title":"","text":"","link":"/theme-test.html"},{"title":"","text":"/* 自定义颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #7835dc !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-pink { color: #e83e8c !important; } .text-gray { color: #6c757d !important; } .text-dark { color: #343a40 !important; } /* 强调文本 */ .text-emphasis { color: #007bff; font-weight: bold; } /* 警告文本 */ .text-warning { color: #ffc107; font-weight: bold; } /* 成功文本 */ .text-success { color: #28a745; font-weight: bold; } /* 错误文本 */ .text-danger { color: #7835dc; font-weight: bold; } /* 文章摘要样式 */ .article-excerpt { background: #f8f9fa; border-left: 4px solid #007bff; padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0; } .article-excerpt p { margin: 0; color: #6c757d; font-style: italic; } /* 封面图片样式 */ .article-cover { width: 100%; max-height: 300px; object-fit: cover; border-radius: 8px; margin-bottom: 20px; } /* 阅读更多按钮样式 */ .read-more { display: inline-block; background: #007bff; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; margin-top: 10px; transition: background-color 0.3s; } .read-more:hover { background: #0056b3; color: white; text-decoration: none; } /* 文章底部标签和分类样式 */ .article-tags, .article-categories { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff; } .article-tags h4, .article-categories h4 { margin: 0 0 10px 0; color: #495057; font-size: 16px; font-weight: 600; } .article-tags .tag, .article-categories .category { display: inline-block; background: #007bff; color: white; padding: 4px 12px; margin: 2px 4px 2px 0; border-radius: 20px; font-size: 12px; text-decoration: none; transition: all 0.3s ease; } .article-tags .tag:hover, .article-categories .category:hover { background: #0056b3; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); } .article-categories .category { background: #28a745; } .article-categories .category:hover { background: #1e7e34; } /* 文章元信息样式 */ .article-meta { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #6c757d; } .article-meta .meta-item { display: flex; align-items: center; gap: 5px; } .article-meta .meta-item i { color: #007bff; width: 16px; } /* Giscus评论系统样式 */ #giscus-comments { margin-top: 40px; padding: 20px; background: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #eaecef; } #giscus-comments h3 { margin: 0 0 20px 0; color: #24292e; font-size: 20px; font-weight: 600; text-align: center; } /* 评论加载状态 */ .giscus-loading { text-align: center; padding: 40px; color: #6a737d; } .giscus-loading::before { content: \"🔄 正在加载评论...\"; font-size: 16px; } /* 评论区域响应式设计 */ @media (max-width: 768px) { #giscus-comments { margin: 20px 10px; padding: 15px; } #giscus-comments h3 { font-size: 18px; } } /* Callout 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } /* IMPORTANT 警告框 */ blockquote[data-callout=\"important\"], blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\")) { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before, blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\"))::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* CAUTION 警告框 */ blockquote[data-callout=\"caution\"], blockquote:has(> p:first-child:contains(\"[!CAUTION]\")) { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before, blockquote:has(> p:first-child:contains(\"[!CAUTION]\"))::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* NOTE 提示框 */ blockquote[data-callout=\"note\"], blockquote:has(> p:first-child:contains(\"[!NOTE]\")) { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before, blockquote:has(> p:first-child:contains(\"[!NOTE]\"))::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* SUCCESS 成功框 */ blockquote[data-callout=\"success\"], blockquote:has(> p:first-child:contains(\"[!SUCCESS]\")) { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before, blockquote:has(> p:first-child:contains(\"[!SUCCESS]\"))::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* WARNING 警告框 */ blockquote[data-callout=\"warning\"], blockquote:has(> p:first-child:contains(\"[!WARNING]\")) { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before, blockquote:has(> p:first-child:contains(\"[!WARNING]\"))::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* 移除第一个段落的 [!TYPE] 标记 */ blockquote p:first-child { margin-top: 0; } /* 响应式设计 */ @media (max-width: 768px) { blockquote { margin: 15px 10px; padding: 12px 16px; } blockquote::before { font-size: 12px; } } /* MathJax 样式优化 */ .MathJax_Display { text-align: center !important; margin: 1em auto !important; } .MathJax { outline: none; } /* 行内公式样式 */ .MathJax_Display .MathJax { text-align: center !important; } /* 块级公式容器 */ .MathJax_Display { display: block !important; text-align: center !important; margin: 1em auto !important; } /* 确保公式不被截断 */ .MathJax_Display .MathJax { overflow-x: auto; overflow-y: hidden; } /* 响应式设计 */ @media (max-width: 768px) { .MathJax_Display { margin: 0.5em auto !important; } } mjx-container[display=\"true\"] { display: block !important; text-align: center !important; margin: 1em auto !important; } mjx-container[display=\"false\"] { display: inline-block !important; } /* 列表页/首页摘要中的警告框覆盖 */ article.media .media-content .content blockquote, .article-excerpt .content blockquote { background: rgba(2, 215, 242, 0.15) !important; /* 蓝色半透明背景，符合 cyberpunk */ border: .5px solid #02d7f2 !important; border-left: 5px solid #02d7f2 !important; } /* 文字颜色提亮，避免被通用文字色覆盖 */ article.media .media-content .content blockquote, article.media .media-content .content blockquote p, article.media .media-content .content blockquote * , .article-excerpt .content blockquote, .article-excerpt .content blockquote p, .article-excerpt .content blockquote * { color: #ffffff !important; font-weight: 500 !important; text-shadow: 0 0 2px rgba(0,0,0,.6) !important; } /* 分类型：IMPORTANT / CAUTION / NOTE */ article.media .media-content .content blockquote[data-callout=\"important\"], .article-excerpt .content blockquote[data-callout=\"important\"] { background: rgba(149,97,210,.22) !important; /* 紫色半透明 */ border-left-color: #02d7f2 !important; } article.media .media-content .content blockquote[data-callout=\"caution\"], .article-excerpt .content blockquote[data-callout=\"caution\"] { background: rgba(255,142,60,.22) !important; /* 橙色半透明 */ border-left-color: #ff8e3c !important; } article.media .media-content .content blockquote[data-callout=\"note\"], .article-excerpt .content blockquote[data-callout=\"note\"] { background: rgba(2,215,242,.20) !important; /* 蓝色半透明 */ border-left-color: #02d7f2 !important; } /* 标题行（::before）提亮 */ article.media .media-content .content blockquote[data-callout]::before, .article-excerpt .content blockquote[data-callout]::before { color: #02d7f2 !important; text-shadow: 0 0 4px rgba(2,215,242,.6) !important; }","link":"/css/custom.css"},{"title":"","text":"/* FontAwesome 6.5.2 CDN */ @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css'); /* 确保 FontAwesome 6.5.2 优先级最高 */ .fab.fa-x::before { content: \"\\f1e3\" !important; } .fab.fa-x-twitter::before { content: \"\\f1e3\" !important; } /* 覆盖主题默认的 FontAwesome 版本 */ .fab.fa-twitter::before { content: \"\\f099\" !important; }","link":"/css/fontawesome-6.5.2.css"},{"title":"","text":"// Callout 警告框增强器 (function() { function enhanceCallouts() { // 查找所有 blockquote 元素 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { // 检查第一个段落是否包含 callout 标记 const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; // 匹配 [!TYPE] 格式 const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); // 添加 data-callout 属性 blockquote.setAttribute('data-callout', calloutType); // 移除第一个段落中的 [!TYPE] 标记 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; // 添加图标和标题 const calloutHeader = document.createElement('div'); calloutHeader.className = 'callout-header'; calloutHeader.style.cssText = ` display: block; font-weight: bold; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; `; // 根据类型设置样式 const calloutConfig = { important: { icon: '⚠️', text: '重要', color: '#7835dc' }, caution: { icon: '⚠️', text: '注意', color: '#b8860b' }, note: { icon: 'ℹ️', text: '提示', color: '#17a2b8' }, success: { icon: '✅', text: '成功', color: '#28a745' }, warning: { icon: '🚨', text: '警告', color: '#fd7e14' } }; const config = calloutConfig[calloutType]; if (config) { calloutHeader.innerHTML = `${config.icon} ${config.text}`; calloutHeader.style.color = config.color; // 在第一个段落之前插入标题 firstParagraph.parentNode.insertBefore(calloutHeader, firstParagraph); } } } }); } // 页面加载完成后执行 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', enhanceCallouts); } else { enhanceCallouts(); } // 如果页面使用了PJAX，需要重新执行 if (window.pjax) { document.addEventListener('pjax:end', enhanceCallouts); } // 监听动态内容变化 const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if (mutation.type === 'childList' && mutation.addedNodes.length > 0) { enhanceCallouts(); } }); }); // 开始观察 observer.observe(document.body, { childList: true, subtree: true }); })();","link":"/js/callout-enhancer.js"},{"title":"","text":"// Giscus评论系统加载脚本 (function() { // 等待页面完全加载 function initGiscus() { // 检查是否在文章页面 const isArticlePage = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || window.location.pathname.includes('/2025/'); if (isArticlePage) { console.log('检测到文章页面，正在加载Giscus评论系统...'); // 检查是否已经加载过评论 if (document.getElementById('giscus-comments')) { console.log('评论系统已存在，跳过重复加载'); return; } // 创建Giscus容器 const giscusContainer = document.createElement('div'); giscusContainer.id = 'giscus-comments'; giscusContainer.style.marginTop = '40px'; giscusContainer.style.padding = '20px'; giscusContainer.style.borderTop = '1px solid #eaecef'; giscusContainer.style.background = '#ffffff'; giscusContainer.style.borderRadius = '8px'; giscusContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)'; // 添加加载状态 giscusContainer.innerHTML = ` 💬 评论 🔄 正在加载评论... `; // 查找文章内容区域并插入评论框 const articleContent = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || document.querySelector('main') || document.querySelector('article'); if (articleContent) { articleContent.appendChild(giscusContainer); // 延迟加载Giscus脚本，确保页面完全渲染 setTimeout(function() { try { // 加载Giscus脚本 const script = document.createElement('script'); script.src = 'https://giscus.app/client.js'; script.setAttribute('data-repo', 'rookie-zgy1513/rookie-zgy1513.github.io'); script.setAttribute('data-repo-id', 'R_kgDOKRlxNA'); script.setAttribute('data-category', 'General'); script.setAttribute('data-category-id', 'DIC_kwDOKRlxNM4CuKH8'); script.setAttribute('data-mapping', 'pathname'); script.setAttribute('data-strict', '0'); script.setAttribute('data-reactions-enabled', '1'); script.setAttribute('data-emit-metadata', '0'); script.setAttribute('data-input-position', 'bottom'); script.setAttribute('data-theme', 'preferred_color_scheme'); script.setAttribute('data-lang', 'zh-CN'); script.crossOrigin = 'anonymous'; script.async = true; // 脚本加载成功后的处理 script.onload = function() { console.log('Giscus脚本加载成功'); // 移除加载状态 const loadingElement = giscusContainer.querySelector('.giscus-loading'); if (loadingElement) { loadingElement.remove(); } }; // 脚本加载失败的处理 script.onerror = function() { console.error('Giscus脚本加载失败'); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败，请刷新页面重试 `; }; giscusContainer.appendChild(script); } catch (error) { console.error('加载Giscus时发生错误:', error); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败: ${error.message} `; } }, 1500); // 延迟1.5秒加载 } else { console.warn('未找到文章内容区域，无法加载评论系统'); } } else { console.log('非文章页面，跳过评论系统加载'); } } // 多重检查确保页面加载完成 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGiscus); } else { // 如果DOM已经加载完成，等待一小段时间再执行 setTimeout(initGiscus, 100); } // 额外检查，确保在Icarus主题完全加载后执行 window.addEventListener('load', function() { setTimeout(initGiscus, 500); }); // 如果页面使用了PJAX，需要重新初始化 if (window.pjax) { document.addEventListener('pjax:end', function() { setTimeout(initGiscus, 300); }); } })();","link":"/js/giscus.js"}]}