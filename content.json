{"posts":[{"title":"RooKie_Z的CO理论作业合集","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是 RooKie_Z 的CO理论作业合集,记录了 2023秋肖利民老师班 所有的CO理论作业和 RooKie_Z 对应的作答. 👉 作业题目合集 👉 作答合集","link":"/2025/08/10/CO-Theory/"},{"title":"OO第一单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 前言复杂度分析使用IDEA的 MetricsReloaded插件 代码规模分析利用IDEA的 static插件 UML类图使用IDEA绘图，再自行调整 任务概览作业要求 作业1：根据形式化定义解析输入的表达式，输出恒等变形展开括号后的表达式。 作业2：形式化定义加入指数函数和自定义函数。 作业3：支持自定义函数嵌套并加入求导算子。 第一次作业第一次作业为对包含幂函数与常数的表达式进行化简，涉及相对简单的嵌套，UML类图如下所示。 架构分析通过分析 Expr与 Term的结构。我们不难发现，一个基本的 Expr可以看成又一个个基元构成，即 $$Expr = \\sum a \\times x ^ b$$ 数据存储上，依照形式化表达设计为 Expr-&gt;Term-&gt;Factor。Parser和 Lexer作为工具类，分别承担句法分析和词法分析的功能。 值得注意的是，架构中事实上没有区分 Num和 Power，而是将其统一为 Unit类，存储一个形如$a \\times x ^ b$的因子。 在读取和存储过程中，Parser和 Lexer合作，构建了一棵多叉表达式树。 Factor接口为因子类的公共接口，所有的因子都实现了这个接口，所有的非 Unit类通过 Poly，即多项式类进行运算，最后通过 Poly类调用 Unit类的 toString方法实现输出。 下图展示了这种读取和存储的过程的一个例子： 具体而言，获得答案的计算过程是和读取解析相解耦合的。在调用顶层 Expr对象的 extend()方法后，逐层向下调用 extend()方法，得到展开式。这其中，得益于 Unit类的统一性，每一层向上返回的都是一个 Unit对象的集合，达到了形式上和接口的统一。 复杂度分析本次作业部分方法复杂度如下图，其余方法复杂度较低，未在图中体现。 可以看到，Parser中的 parseFactor()方法复杂度较高，分析原因知，设计该方法时对于常数和幂函数的解析都全部列在其中，没有分别抽象为分别的方法；Unit中的 toString()方法复杂度较高，为了优化输出的长度导致特判较多，复杂度较高。 Method CogC ev(G) iv(G) v(G) Parser.parseFactor() 14 1 8 8 Parser.parseExpr() 8 1 6 6 expr.Unit.toString() 7 1 6 7 Lexer.next() 6 2 4 6 expr.Expr.extend() 6 2 6 6 expr.Poly.toString() 5 4 3 5 expr.Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 expr.Poly.multiUnit(Unit) 4 1 3 3 expr.Poly.Merge() 3 1 3 3 expr.Poly.adjustUnit() 3 3 2 3 expr.Poly.multiExpr(Poly) 3 1 3 3 Lexer.getNumber() 2 1 3 3 Parser.getExp() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 expr.Poly.Negate() 1 1 2 2 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Main.main(String[]) 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 expr.Expr.Negate() 0 1 1 1 expr.Expr.addTerm(Term) 0 1 1 1 expr.Expr.equals(Expr) 0 1 1 1 expr.Expr.setExp(BigInteger) 0 1 1 1 expr.Poly.Poly() 0 1 1 1 expr.Poly.add(Poly) 0 1 1 1 expr.Poly.createOne() 0 1 1 1 expr.Poly.unitMulti(Unit, Unit) 0 1 1 1 expr.Term.Negate() 0 1 1 1 expr.Term.addFactor(Factor) 0 1 1 1 expr.Unit.Negate() 0 1 1 1 expr.Unit.Unit(BigInteger) 0 1 1 1 expr.Unit.Unit(Type) 0 1 1 1 expr.Unit.canMerge(Unit) 0 1 1 1 expr.Unit.compareTo(Unit) 0 1 1 1 expr.Unit.getCoff() 0 1 1 1 expr.Unit.getExp() 0 1 1 1 expr.Unit.getType() 0 1 1 1 expr.Unit.merge(Unit) 0 1 1 1 expr.Unit.multiUnit(Unit) 0 1 1 1 expr.Unit.setCoff(BigInteger) 0 1 1 1 expr.Unit.setExp(BigInteger) 0 1 1 1 Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是没有处理$0$的输出；另一个是没有妥善处理表达式里的 \\t和空格。 同时，我在此次作业中设计并实现了一个自动化评测机，这对检验程序的正确性有不小的帮助，也帮助我实现了hack，详细的分析将在评测部分介绍。 总结“工欲善其事，必先利其器” 在写本次作业之初，我设计过很多架构，在设计阶段就推倒重来若干次。尽管在Pre中的冒险者游戏中已经我初步领会了面向对象的思想，但是面对较为抽象的表达式解析仍然显得捉襟见肘。 尽管如此，得益于 training部分提供的 Parser和 Lexer思路，我最终得以确定这个较为面向对象的设计。但是，这个架构依然存在相当的不足，在后面的迭代开发介绍中将会着重介绍。 第二次作业相比于第一次作业，第二次作业新增了自定义函数与指数函数相关的内容，同时支持嵌套括号的解析。 相比第一次作业，增加了 Func类处理自定义函数，同时增加了 Exp类处理指数函数，UML类图如下： 架构分析相较于上一次作业以及未来的第三次作业，本次作业的工作量无疑是最大的，也难怪纪一鹏老师说这次作业很有可能会是本学期OO的难度巅峰。 对于本次作业的两个新增要求，我先完成了自定义函数的实现，再完成了指数函数的部分。 自定义函数部分自定义函数分为两个部分，一是读入，二是调用。 有关读入，由于函数定义式依然符合我们的多项式语意，且定义式内不允许循环定义，故而直接沿用上一次的 Lexer和 Parser来解析。 有关调用，我在读入表达式时，就建立了参数与实参的Map，在解析时利用Map中的Map.Entry接口进行替换，效果不错，但是相较正则表达式替换的方法，虽然正确性上有保障，但是时间复杂度较高。 指数函数部分通过分析本次式子可知，本次基元有所更新 $$Expr = \\sum a \\times x ^ b \\times exp(Factor) ^ c$$ 由于指数函数的特殊性，故我直接在初始化指数函数时直接将基元变形成如下式子，便于后续计算： $$Expr = \\sum a \\times x ^ b \\times exp(Factor \\times c)$$ 同样，我利用Poly类的 toString方法和String类的equals方法判断exp内的Factor是否相等，来进行后续合并。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 19 1 12 12 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Unit.setExp(BigInteger) 10 1 4 8 Lexer.next() 9 2 5 7 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Poly.unitMulti(Unit, Unit) 4 1 5 5 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Poly.adjustUnit() 3 3 2 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Main.main(String[]) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.clone() 0 1 1 1 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 可以看出，本次架构在Term类中实现自定义函数的替换部分的 replace方法复杂度极高，在Debug过程中，也同样是这个方法耗去了我大量的时间，可见越复杂，越易错！！！ Bug分析本次作业没有出现bug。 在对room内其他同学互测时，发现两个bug：一个是对于exp的括号化简出错；另一个是自定义函数中exp函数替换出错。 在本次hack过程中，我着重查看了同屋同学代码架构的复杂程度进行了分析，对于明显架构复杂的代码进行hack，都得到了成功。 具体的hack方法则是利用cxc同学的评测机，对于可疑代码进行评测，得到错误输出后针对数据进行化简使其符合互测数据限制，最终hack成功。 总结第二次作业是我在第一单元中花费时间最长的一次，尤其是指数函数的引入与化简合并，在Debug时给我造成了不小的困难，由于在完成本次作业时流感发烧，因此我在优化方面仅仅做了合并同类项和去exp函数的多余括号，但性能分上取得了 97.5分，可以说是十分侥幸的。同时，由于储存基元时采用了ArrayList，因此在合并同类项与Unit运算时被迫使用深克隆，而由于身体状态不佳，处于正确性考虑，我大量使用克隆，这也使我的程序运行时间大大增长。 第三次作业本次作业引入了求导因子。本以为是最痛苦的一集，没想到成了最速的一集。UML类图如下所示： 架构分析与第二次作业相比，本次作业架构几乎没有发生变化，没有引入新的类。对于求导操作，与求字符串相似，在每一个相关的类中引入getDerivative()方法，返回Poly多项式类。对于带函数的求导，采用将自定义函数完全展开后再进行求导的方法。 复杂度分析 Method CogC ev(G) iv(G) v(G) Term.replace(HashMap&lt;Type, Factor&gt;) 30 1 8 8 Parser.parseFactor() 20 1 13 13 Unit.isSimple() 11 7 9 15 Unit.toString() 11 1 9 10 Lexer.next() 10 2 6 8 Unit.setExp(BigInteger) 10 1 4 8 Parser.parseExpr() 8 1 6 6 Unit.compareTo(Unit) 8 7 7 8 Exp.ifOne() 7 5 2 5 Expr.extend() 6 2 6 6 Poly.Merge() 6 1 5 5 Func.invoke(List &lt;Factor&gt;) 5 1 2 4 Main.main(String[]) 5 3 4 5 Poly.toString() 5 4 3 5 Term.extend() 5 1 4 4 Parser.parseTerm() 4 1 4 4 Poly.multiUnit(Unit) 4 1 3 3 Unit.multiUnit(Unit) 4 1 4 5 Unit.wipeExp() 4 4 1 5 Exp.Exp(Factor) 3 1 3 4 Exp.toString() 3 1 3 3 Parser.parseDerivative() 3 1 4 4 Poly.adjustUnit() 3 3 2 3 Poly.compareTo(Poly) 3 3 3 3 Poly.multiExpr(Poly) 3 1 3 3 Unit.Unit(Type) 3 1 1 4 Unit.replace(HashMap&lt;Type, Factor&gt;) 3 3 3 4 Exp.clone() 2 1 1 2 Exp.replace(HashMap&lt;Type, Factor&gt;) 2 1 2 2 Lexer.getNumber() 2 1 3 3 Parser.parseFuncDef() 2 1 3 3 Poly.isSimple() 2 3 1 3 Unit.clone() 2 1 3 3 Unit.getDerivative(Type) 2 1 3 3 Exp.getDerivative(Type) 1 2 1 2 Expr.clone() 1 1 2 2 Expr.pow(BigInteger) 1 1 2 2 Expr.replace(HashMap&lt;Type, Factor&gt;) 1 1 2 2 Parser.getExp() 1 1 2 2 Parser.parseFunc() 1 1 2 2 Poly.Negate() 1 1 2 2 Poly.clone() 1 1 2 2 Poly.getDerivative(Type) 1 1 2 2 Poly.pow(BigInteger) 1 1 2 2 Poly.toTerms() 1 1 2 2 Processor.treatPlusMinus() 1 1 2 2 Term.clone() 1 1 2 2 Exp.compareTo(Exp) 0 1 1 1 Exp.equals(Exp) 0 1 1 1 Exp.getExponent() 0 1 1 1 Exp.isSimple() 0 1 1 1 Exp.multExp(Exp) 0 1 1 1 Exp.pow(BigInteger) 0 1 1 1 Exp.setExponent(BigInteger) 0 1 1 1 Expr.Expr() 0 1 1 1 Expr.Expr(Poly) 0 1 1 1 Expr.Negate() 0 1 1 1 Expr.addExpr(Expr) 0 1 1 1 Expr.addTerm(Term) 0 1 1 1 Expr.equals(Expr) 0 1 1 1 Expr.getDerivative(Type) 0 1 1 1 Expr.setExp(BigInteger) 0 1 1 1 Func.Func(String, Character[]) 0 1 1 1 Lexer.Lexer(String) 0 1 1 1 Lexer.peek() 0 1 1 1 Parser.Parser(Lexer) 0 1 1 1 Poly.Poly() 0 1 1 1 Poly.add(Poly) 0 1 1 1 Poly.addUnit(Unit) 0 1 1 1 Poly.createOne() 0 1 1 1 Poly.isEmpty() 0 1 1 1 Poly.unitMulti(Unit, Unit) 0 1 1 1 Processor.adjustSign() 0 1 1 1 Processor.consumeBlank() 0 1 1 1 Processor.getString(String) 0 1 1 1 Processor.newInput(String) 0 1 1 1 Processor.outputString() 0 1 1 1 Processor.replaceDoubleStar() 0 1 1 1 Term.Negate() 0 1 1 1 Term.addFactor(Factor) 0 1 1 1 Term.pow(BigInteger) 0 1 1 1 Unit.Negate() 0 1 1 1 Unit.Unit(BigInteger) 0 1 1 1 Unit.Unit(Type, Factor) 0 1 1 1 Unit.canMerge(Unit) 0 1 1 1 Unit.getCoff() 0 1 1 1 Unit.getExp() 0 1 1 1 Unit.getExpFunc() 0 1 1 1 Unit.getType() 0 1 1 1 Unit.merge(Unit) 0 1 1 1 Unit.pow(BigInteger) 0 1 1 1 Unit.setCoff(BigInteger) 0 1 1 1 Unit.setExpFunc(Exp) 0 1 1 1 Unit.setType(Type) 0 1 1 1 Unit.simpleClone() 0 1 1 1 与第二次作业中复杂度较高的方法相同，原因一致。 Bug分析本次作业在强测中未出现Bug，但是在互测中由于TLE中刀，原因正如我在第二次作业总结中写的那样——无脑克隆，而克隆方法本身需要递归，导致最终超时，这也是由于我个人的侥幸心理，认为互测数据不强，在明知有超时风险时，选择写OS作业，未进行优化。虽然强测侥幸过关，但是在互测中还是漏了马脚，果然还是这个道理。 She was still too young to know that life never gives anything for nothing, and that a price is always exacted for what fate bestows. 那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。 ——茨威格 总结第三次作业不仅没有想象中可怕，还是三次作业中耗时最少的一次。得益于层次化结构的设计，新增求导运算的升级过程非常顺利，唯一的注意点是数学上的求导法则，需要在编码时严格遵守。只是可惜我的侥幸心理导致互测中刀，现在想来仍然感到深深可惜！！！ 测试本单元由于身体状况与个人时间的关系，只在第一次作业搭建了评测机，后续使用了cxc同学的评测机，这里再次感谢cxc同学！！！ 在个人搭建评测机的过程中，我主要还是使用模拟递归下降的过程构建测试数据，并利用 Python中的 Sympy包来达到化简表达式并判断正误的效果，唯一的缺点是速度太慢。同时，我在构建评测数据时特意加入了诸如 x-x,+00000等数据，来保证随机生成数据的特殊性，但是只是可惜评测机hack效果不佳，更多还是靠手动构建数据。 心得体会第一单元就这样痛并快乐地坚持了过去，但是和同学们投入的时间相比，我好像完成得还算轻松（?） 通过表达式解析的练习，我深刻体会了面向对象的设计思想，了解了递归下降的解析方法，初步尝试了层次化的类设计，这也为OS的Lab1提供了一些帮助。 最后还是感慨：设计为先，一个好的设计能为后续的编码工作省去不少麻烦；就比如，每次作业前，我都要花上一天半来进行设计，而不是基于上手编码，否则代码必然是漏洞百出。此外，还必须注重可扩展性，即在当前设计中打一个提前量，给未来可能引入的设计提前预留一些空间。 打个比方，我的程序在第一次就支持括号嵌套，第二次就支持自定义函数嵌套，现在第三次作业的程序还支持多变量运算与求导等等。 未来方向总体而言，我认为课程组对于第一单元的设置已相对完备，但是第三次作业相较前两次明显过于轻松，我认为可以加入多变量运算与求导等要求。同样，我认为强测应该设置专门数据来卡时间复杂度，这样就能狠狠整治向我这样心存侥幸的同学！！！","link":"/2025/08/13/OO-1/"},{"title":"OO第二单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 如果要让我对这充满坎坷的“电梯月”做一个总结，我认为贝克特的这一句名言无疑是最贴切的： [!IMPORTANT] Ever tried,Ever failed,No matter.Try again,Fail again,Fail better. –塞缪尔·贝克特 事实上，如果你碰巧是一名文学爱好者，那么你可能很难相信以荒诞文学闻名的贝克特会说出这样励志的名言。正如在真正完成这一单元之前，我也不会想到自己会在面对多线程层出不穷的Bug时，依然坚持”Fail again, fail better”。 前言第二单元我们要实现的是基于共享数据的，多线程电梯调度问题，在这一过程中，要迭代出电梯重置，双轿电梯等功能。相比第一单元，在第二单元的设计工作中，我深刻感受到了设计架构的重要性，以及多线程并行计算的优势。 整体架构图UML图由于是迭代开发，在这张UML图上我们可以看到这一路的过程。 白色的部分代表第一次作业。 绿色的部分代表第二次作业的增添。 紫色的部分代表第三次作业的增添。 时序图 设计架构开发历程 [!CAUTION] 第二单元的架构开发，我想多介绍一些， 对比第一单元作业，性能不在是实实在在的需求，而是相对虚无缥缈的东西。在保证正确性的前提下，不进行任何性能优化，也能有不错的性能分，因此架构占据了绝对的主导作用。 关于方法的复杂度就放在最后一起分析了。 作业要求：第二单元的任务为模拟群控电梯调度，重点在于多线程并发的设计。以下是任务的迭代：· hw5模拟了6部电梯的调度，乘客的请求会指定特定电梯· hw6的乘客可以自由分配给任意一部电梯，电梯需要输出已接收信号。同时增加了电梯参数的重置，重置时会暂停并处于静默状态· hw7增加了分裂为双轿厢的重置模式，需要在换乘层进行协调 hw5同步块和锁第一次作业，同时也是首次进行多线程编程，完成作业的大部分时间都放在了理解什么是多线程，以及什么是同步块上。 那么什么是同步块呢？简单来说就是，随便找点什么，多个类共用（指的是多个线程在同一时刻共同访问），套上 synchronized关键字。同步块的效果是什么？套上 synchronized关键字之后，在每一个时刻只能有一个线程访问。什么是锁？锁是当多个线程竞争同一个共享数据的时候，不让其他线程访问的重要武器。在 synchronized之外，还可以通过重入锁，读写锁等方式实现灵活的上锁。 由于第一次作业要求实在太过简单，六台电梯分别有自己对应的乘客，因此只需将总请求池上锁即可，同时在电梯需要进行 sleep()时给电梯上锁，确保其状态不受改变就可以保证线程安全，具体细节上采用 ReentrantLock即可实现，无需多言。 调度器和调度策略由于第一次不涉及“电梯抢人”的问题，所以无需设计调度器以及调度策略。 电梯运行算法采用的是 LOOK运行算法，也是日常生活中的电梯算法，即顺带接人运行策略，略微不同的地方是，现实中，在乘客进入电梯前，我们是不知道乘客的目的地的。但在本单元的作业中，人不是线程而是一个 Object，不仅方便了调度器的分配，而且降低了复杂度。 hw6同步块和锁与第一次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。 调度器和调度策略调度器采用 影子电梯 策略，即算出局部最优解分配给6个线程。具体做法是对电梯和该电梯的处理队列进行深克隆，调用克隆后的 shadowElevator.move()实现模拟推进时间，遍历6个电梯，找出能够使得新请求加入后整体运行时间结束最早的那一种加入请求算法。 为方便说明，举例如下图所示：绿色方块为电梯原有请求完成需要花费时间，每一列为一种分配策略对应各个电梯用时（共六种，即把新请求分配给六个电梯，分别遍历），找出该策略下用时最久的电梯为该策略对应的全局任务完成时间，再将六个策略的时间找出最短的，就获得了局部最优解。下图的情况即为将新请求加入3号电梯是局部最优解。 注：示例图片来自武彬煦学长的博客 这样，调度器成为了线程，调度器和输入线程之间，调度器和各个电梯之间，通过一个等待队列连接。 这样的策略可以做到局部时间最优，由于本人的懒惰，并未在影子电梯的指标中加入耗电量的考量。 hw7同步块和锁与第二次作业类似，实际上，由于我们的分配操作是将一个个请求添加到每个电梯各自的请求的请求队列中，还是要将请求池，电梯各自的请求队列以及电梯自身设为共享对象，并围绕他们构建同步块，进行上锁。事实上，这只是我粗浅的理解，让我在互测中身中15刀 [!CAUTION] 事实上，由于我的设计中，DC Reset要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException😭 调度器和调度策略调度器依旧采用 影子电梯 策略，由于这次存在双轿厢电梯，而影子电梯无法模拟换乘，因此在计算电梯结束时间时，对于双轿厢电梯中无法直达的请求，采取惩罚补时，来进行粗略模拟，效果还可以。 双轿厢电梯安全控制在设计这次作业时OS正好在学信号量，事实上，换乘楼层只允许一个轿厢停靠，本质上就是一种信号量操作，而最大值为一的信号量实际上就是一把锁，两轿厢要进入换乘楼层时尝试获得锁，离开换乘楼层时释放锁即可。 具体代码上通过设置 Police类来监管双轿厢： 123456789101112131415161718192021222324252627public class Police { private boolean occupied = false; public synchronized void getAccess(Character type) { tryAccess(type); occupied = true; notifyAll(); } private synchronized void tryAccess(Character type) { notifyAll(); while (occupied) { try { wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } public synchronized void release() { occupied = false; notifyAll(); }} 稳定和易变稳定：稳定的内容主要还是电梯的捎带一直采取 LOOK算法，保证了绝大多数情况下电梯平均性能的优越性。同时在二三次作业中都采取了影子电梯模拟的调度策略，改变不大。 易变：乘客需求，电梯的类型每次作业都在改变，而这些都是通过 Reset指令实现的，如何妥善实现这些指令也正是本单元的设计重点。 结束的条件也随之变化，从每个电梯自己结束，到调度器统一分配结束。 BUG分析hw5第五次作业较为简单，在本地编写代码以及线上测试时都未发现Bug hw6第六次作业在编写时遇到的最主要的Bug在于线程无法安全结束，原因在于与第五次作业不同，在第六次作业中调度器是作为一个线程存在的，因此要确定它和电梯线程结束的顺序就成为了Bug产生的重灾区，最终也是通过不断通过评测机测试得到错误数据再通过 Print大法来查看线程具体结束情况最终解决Bug。 在互测中产生了一个Bug，原因是在五台电梯 Reset时会将所有请求分给一台可以使用的电梯，最终导致 RTLE。只要在只有一台电梯不在 Reset时让调度器等一等就行了，也不会轮询。 hw7第七次作业的Bug堪称最搞笑的一集。 强测中没出现Bug，但在互测中，由于我的设计在DC Rese时要往调度器类中的电梯队列里添加电梯，而在判断调度器线程是否结束时要遍历电梯队列，而我未对电梯队列上锁，这样会报错 ConcurrentModificationException，或者造成无法正常 Reset，导致CTLE，最终身中15刀。 解决办法是做 ArrayList&lt;Elevator&gt; elevators $\\to$ CopyOnWriteArrayList&lt;Elevator&gt; elevators的修改即可。 总结毫无疑问，对于多线程编程而言，Debug绝对是最痛苦，最耗时的部分。总结来看，一个好的架构往往能保证较高的Bug复现率。 而对于多线程Bug，除了 Print大法我深感无力，这也导致在强测结果出来前我一直保持着“先质疑，再质疑”的态度，好在最后强测都没出事，也算是万幸。 [!IMPORTANT] 还是那句老话，对于多线程测试，评测机上十万组正确数据都不如一个能稳定复现的Bug来的金贵和安心。 心得体会线程安全从单线程到多线程，性能上的巨大飞跃，必然带来的是设计上的复杂性，数据安全便是这方面的核心，但是更重要的是保证线程安全的同时，提高解决效率，不能长时间占有锁，更不能在 sleep的时候占有锁，要保证原子性，但一定要对同一时间的多条判断语句进行原子锁。 保证线程安全下的提高效率，真正的拉开了与单线程之间的差距，只注重数据的安全的结果往往是死锁，和轮询，这是要极力避免的。 层次化设计好的设计带来的优势在这一单元体现的淋漓尽致。正如前文所言，好的设计能够极大减少性能优化上的工作，以及提高本地测试时的Bug复现率，能够减少代码编写时的时间耗费。 “两天设计，一日编码”。这单元最好的工作流程就是这样，多线程编程设计细节颇多，如果无法在设计上提前规划这些细节，那么只会徒增Bug，白白浪费时间罢了。","link":"/2025/08/13/OO-2/"},{"title":"OO第三单元总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是一篇 OO Unit3助教当年对于U3的吐槽，现在看实在是回旋镖🪃满天飞啊🤣 测试过程黑箱测试与白箱测试通过查阅资料，我暂且给出黑箱测试与白箱测试的定义和方法。 黑箱测试也称功能测试、数据驱动测试或基于规格说明的测试。测试者只知道程序的输入、输出和系统的功能，这是从使用者的角度针对软件的接口、功能及外部结构进行的测试，不考虑程序内部实现逻辑。 白箱测试也称结构测试、逻辑驱动测试或基于程序本身的测试，测试程序内部结构或运行。在白箱测试时，从程序设计语言的角度来设计测试样例。测试者输入数据并验证数据在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。 了解了黑箱测试和白箱测试的定义后，我认识到虽然之前从未接触过这两个概念，但已经使用类似的方法开始测试了。 首先是白箱测试，从C语言程序设计课开始，我似乎就已经开始使用白箱测试了。对我来说，白箱测试的用处是在写完代码后确定程序中的每一步是否都是按照设想执行的，具体的实现方法往往是在每一行可能改变变量值的代码后都加上 printf()或 System.out.println()语句输出想要查看的变量值。我认为这种方法的效果与单步调试的效果相当，但更加简单直接、更加灵活且可用于多线程情况。 之后是黑箱测试，仅关注在给定功能要求和输入下的输出。这个也不陌生，各种课程组的评测机、自己写的评测机和对拍器以及本单元作业中出现的OKTest都是黑箱测试。 在日常使用中，对代码的测试往往是黑箱和白箱相结合的。以OS上机为例，在自认为完成要求后，我会先使用 make xxxx &amp;&amp; make run跑一下课程组的测试。测试代码往往是单独的一个文件，并在其内调用我写好的函数，通过 assert语句检查函数的返回值是否符合预期，这是黑箱测试。在这测试后，如果出现了问题，便需要具体检查函数的实现。这个过程既需要用人脑模拟代码的执行，又可以在多条关键语句前后加上 printk(), debugf()检查变量值的变化是否符合逻辑预期，碰到不符合预期的地方便是发现bug，可以开始修改了，改完之后便可以使用黑箱测试继续测试最终结果，若结果不对就继续白箱测试…… 单元测试等多种测试手段 单元测试：单元测试是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作，对面向过程的语言来说是测试函数，对面向对象的语言来说是测试类的行为。在第10次作业中，我构造大数据完全图对 qsp, qtvs, qtav, qba, qcs等指令进行了测试，这便是单元测试的应用。 功能测试：通过上面黑箱测试的介绍可知功能测试大概就是黑箱测试，不考虑程序内部结构而仅测试程序执行的结果。 集成测试：集成测试是指把多个程序模块放在一起测试的方法。由于每个模块都正确不一定能保证整个程序正确，在单元测试后把多个单元结合在一起测试的集成测试必不可少。从实际效果上来说，在第三单元的功能不断增加的迭代开发过程中，前一次作业中全面的强测就相当于下一次作业的集成测试。 压力测试：压力测试是针对系统或是组建，为确定其稳定性而特意进行的严格测试。我感觉压力测试的意义在于低压测试对不同情况的覆盖不完全，从而可能检查不出程序的潜藏问题，而高压测试通过大数据、高并发(如果是多线程)，可以尽可能枚举出各种情况，增大发现问题的概率。距离而言，在电梯单元中，自己造出的弱数据不一定能发现像是轮询、死锁之类的问题，而助教出的压力测试强数据以及评测机超多线程同时跑多份代码的情况则几乎可以发现绝大多数问题。 回归测试：回归测试旨在测试软件原有功能在修改后是否保持完整，这也是纪老师在课上多次提到的。举例而言，在OO每个单元的迭代中，在测试完某一次作业后，要保留好自己构造的测试样例，下次迭代开发之后继续使用。 数据构造策略在三次作业中，我尝试写了两种数据生成器，一个是针对各种指令的集成测试数据生成器，一个是针对 qtvs, qbs, qcs等指令的单元测试/压力测试生成器。单元测试生成器的逻辑比较简单，首先通过 ln构建一个完全图，然后加入一定数量的 tag，同时不断 ar, mr并且 qtvs，最后再一直 qtvs总计10000条数据来进行压力测试，考虑到 OO评测机的玄学属性，对于一切本地运行时间超过 1.6s的数据，进行分析，并且对于代码进行相应的优化。对于集成测试数据生成器，我原本想采用全部随机生成的方式，但发现这样生成的数据会有大量的异常，对于各种计数指令几乎起不到测试效果。于是我在生成器中维护了几个 id池以及关系池用来存放已经生成的数据，并在具体生成指令时，通过随机数判断生成会引起异常的指令或是不会引起异常的指令，这样生成的数据效果尚可。 架构与图模型在架构上，由于官方包已经给出了比较多且明确的要求和限制，我并没有做什么突破，不同类之间的层次关系都是按照官方包写的。而对于图模型的设计和维护则是本单元算法考察的重点。下面重点谈谈我在三次作业中的图模型设计。 图使用邻接表，即 Acquaintance构建。对于 qci和 qbs，hw9就涉及删边，故并不采用并查集等算法，在每次 qci时做 BFS，在加边/删边时BFS动态维护 qbs。对于 qts，在加边和删边时动态维护。对于 qba，对每个点开一个 TreeSet，在增/删/修改边权时，动态维护该点的 bestAc；对于 qcs，每次遍历所有点进行统计。 优化的重点在于 Tag中的方法，尤其是 qtvs方法，经过本地压力测试，发现如果不进行动态维护，而是使用 JML描述的直接查询的O($n^2$)的复杂度方法，则会 CTLE，因此必须在每次 att, dft,ar, mr的时候进行动态维护。 规格与实现分离及性能问题规格与实现分离在这个单元中，其实很能体会到规格与实现的分离，因为假如不分离，实现按着 JML来，便会因为性能不佳O($n^2$)甚至O($n^3$)的时间复杂度可不是闹着玩的😅而大把扣分。而为了实现规格与代码的分离，我认为要做以下两步。 第一步是通读 JML规格，把 JML的规格设计转换为自然语言，抽象为一些符合常识的描述。在面对一些复杂方法时，这一步尤为重要，因为 JML只描述规格，而我们写代码一般需要知道某个函数的意义(我认为一般人都没有在不知道意义的情况下直接把一堆通过遍历描述的方法转换为 dijkstra等较优算法的能力)。 第二步是根据抽象出来的自然语言描述选取合适的数据结构和算法，完成需要实现的功能。 实现中的性能问题我的代码在本单元三次作业的强测和互测中均未出现性能问题。究其原因，在于我在每一次阅读 JML时就对其中蕴涵的时间复杂度“陷阱”，在经过压力测试后采用动态维护，最终避免了 CTLE。通过上面规格与实现分离部分的讨论便可看出，规格和实现是可以分离的，而作为程序员，应该追求满足规格下的最优性能实现。但是否能达到很好的效果，则取决于程序员的知识积累与阅历。简单来说，如果知道更好的算法，就有可能写出性能更好的代码，否则仅凭规格就写不出来。 Junit测试Junit测试与充分诠释了“测不准原理”的 OO评测机共同构成了Unit3的两大梦魇，甚至在中测环节，Junit测试带来的压迫感远比程序正确性要大得多。 看着即将见底的提交剩余次数与随时可能测出问题的代码，和随机刷新的Junit测试 WA测试点，大家难免骂骂咧咧😡，汗流浃背😅。 那么，有没有办法系统性的解决这一问题呢，我认为是有的。我们发现，Junit测试重点关注两个部分——覆盖率高的测试数据，以及确保“万无一失”的标程。 构造覆盖率高的数据构造覆盖率高的数据技巧不高，在完成数据构造后，可以运用IDEA中的使用覆盖率运行test来进行分支覆盖率测试，最终不断完善，获得一组对目标方法分支覆盖率100%的测试数据。 撰写标程标程考察的无非以下几个条件： 检查 ensure； 检查 pure/assignable； 检查 invariant/constraint； 等等 在具体了解了这些条件后，我们其实可以借鉴 OKTest的方法来撰写标程，下面以 hw11中的 deleteColdEmoji()的测试为例来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int judge(HashMap&lt;Integer, Integer&gt; beforeEmojis, HashMap&lt;Integer, Integer&gt; beforeMessages, HashMap&lt;Integer, Integer&gt; afterEmojis, HashMap&lt;Integer, Integer&gt; afterMessages, int limit, int result) { for (int eid : beforeEmojis.keySet()) { if (beforeEmojis.get(eid) &gt;= limit &amp;&amp; !afterEmojis.containsKey(eid)) { //System.out.println(eid + &quot; &quot; + beforeEmojis.get(eid)); return 1; } } for (int eid : afterEmojis.keySet()) { if (!beforeEmojis.containsKey(eid) || !beforeEmojis.get(eid).equals(afterEmojis.get(eid))) { return 2; } } int cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeEmojis.entrySet()) { if (entry.getValue() &gt;= limit) { ++cnt; } } if (cnt != afterEmojis.size()) { return 3; } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() != null &amp;&amp; afterEmojis.containsKey(entry.getValue()) &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || !entry.getValue().equals(afterMessages.get(entry.getKey())))) { return 5; } } for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null &amp;&amp; (!afterMessages.containsKey(entry.getKey()) || afterMessages.get(entry.getKey()) != null)) { return 6; } } cnt = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : beforeMessages.entrySet()) { if (entry.getValue() == null) { ++cnt; } else if (afterEmojis.containsKey(entry.getValue())) { ++cnt; } } if (cnt != afterMessages.size()) { return 7; } return result == afterEmojis.size() ? 0 : 8; } 可以看到，我们针对 JML中的 \\old条件设置了 before*的一系列数据点，同时针对每个 ensure条件依次测试，对于违反条件的情况依次返回不同的错误值，这样也方便 Debug，最后，只要 assertEquals(0, judge(beforeEmojis, beforeMessages, afterEmojis, afterMessages, limit, result));即可完成正确性的判断。 借由 OKTest的思想，我们能够对于每一个 ensure条件都进行测试的撰写，保证了标程的**“万无一失”**。 心得体会收获还是照例先谈谈这一单元的收获吧，在Unit3的学习中，我主要在以下三个方面有所收获： 复习了图论的相关算法，包括 BFS，并查集，Dijkstra等 初步学习了 JML，对于规格化设计有了初步了解。 了解了各种测试方法，并且重新捡起了在电梯单元无暇进行的评测机撰写。 一点吐槽先谈谈对于 JML的感受吧，在进行这一单元学习的同时，我读到了一个有趣的对于语言的吐槽，来自我在北外的学弟。我认为这十分契合我在Unit3的学习体会，决心一定要写进博客作业里。 JML像是在英汉对译的时候，先将中文翻译为法语，再把法语翻译成英文。我中文还好点，英文水平一般，法语则是完全不会。纵使说法语严谨到天花乱坠，对我来讲与鬼画符真没啥区别。谈及JML的优点，我确实无话可说，能与JML相遇是我的缘分，不过我希望这样的缘分越少越好。 当然，JML能够流传下来，传播甚广，一定是有其独到之处的。就像是那个经典的哲学辩题——被误解是不是表达者的宿命，我在想，如果哲学家辩论时能够使用 JML华山论剑，那想必答案已然明了，作为一种**“建模”语言**，JML最大的有点便是尽可能的减少了误解的存在。 但事实是否真的如此呢，JML显然不便于撰写，Unit3横跨五一假期，假期中我最担心的便是指导书和 JML标程的突然修改，因为这很有可能使我的假期泡汤，而这，在这一单元经常发生！！！ 第二则是评测机的“不确定性”，虽说课程组给出的时间限制是10s，但是在实际情况下，一旦本地运行超过1.8s，那么便很有可能发生 CTLE，这实在叫人胆战心惊，每一次点开强测结果都像是开盲盒，非常刺激😊。 最后还是感谢助教的辛勤付出，以上只是我的一点牢骚，我们也很能理解助教频繁修改指导书，JML背后的不易。只是，连助教团队在实际编写过程中都频繁出错的 JML是否有继续推广的价值呢，我认为值得商榷！！！","link":"/2025/08/13/OO-3/"},{"title":"OO第四单元总结暨课程总结","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z对于OO Unit4和课程总体的总结博客 正向建模与开发先简单介绍一下 正向建模与开发 的定义 正向建模与开发是一种根据给定的需求创建或制作应用程序的方法。正向建模与开发也被称为翻新和回收。正向建模与开发需要高水平的技能，它需要更多的时间来构建或开发应用程序。正向建模与开发是一种创建高层模型或设计的技术，以增加复杂性和低层信息。因此，这种工程在不同的软件和数据库过程中有不同的原则。正向建模与开发应用了所有的软件工程过程，包括软件开发生命周期（SDLC），以重新创建现有的应用程序。它是为了满足用户的新需求而进行重构的。 本单元的主题是 UML，正向建模与开发自然是最重要的一环，我个人也是按照课程组的指导，每次作业先做好建模设计再写代码。具体步骤如下： 通读指导书，记录需求重点和细节，并针对边界情况，各种功能编写各种样例 依据样例，整理项目逻辑，记录各个类的协作关系(类似于顺序图的要求) 依据整理的逻辑进行设计，画出类图草图和协作图草图 编写代码 使用 StarUml 软件参照画 uml 图 其实前几步在其他几个单元的作业中我也会做，毕竟在完全不做设计的情况下写代码是很难的。但是我认为在设计阶段就画仔细的 uml 图其实不太方便，因为 StarUml 细节比较多，要用鼠标点来点去，会分散设计阶段的注意力，但用纸和笔来画草图就很方便，而且还可以自己加各种提示在图中。所以我每次都是先画草图，再在全部写完以后用 StarUml画出最终的 uml 图。 放上一张 Unit1的设计图，也算是有始有终了🥳： ![](OO Unit1架构.jpg) 架构设计和UML模型设计之间的追踪关系本单元架构： 在这几次的作业中，为了做到高内聚，低耦合，我根据指导书的要求对于相应的对象都建了类，让他们各司其职。但是随着需求的增多以及复杂度要求更高，对于低耦合的实现就造成了很大的困难，尤其在 OrderRecord和 BorrowRecord两个类呈现出较大的耦合性。对于一致性方面，流程图以及状态图的实现都较简单，因此一致性较好。 架构设计思维的演进其实我感觉第一单元是架构设计最复杂的单元，因为表达式十分抽象，如果没有 training和实验，我甚至都不知道怎么设计各个类，导致架构设计的难度很高，所以我的架构设计能力基本是在第一单元中养成的。我设计架构以及写代码的核心思想就是追求简单，怎么简单怎么来。因为逻辑简单的代码更好把控，更不容易出 bug，即使真的出问题也很好定位。我在 1，2 单元中都进行了轻微重构，重构的方向都是把原来复杂一些的代码化简，即使这可能会牺牲一些性能或是架构的美观性。其实“面向对象性”和架构简单性的矛盾是我一直在思考的内容。以第四单元举例，如果想秉承模块化等思想，是应该把每个功能处拆成单个类来写的，而不是在图书馆类里面写多个组合函数。但更多的类、更多的包装会导致更多的函数嵌套调用或是对象的嵌套使用，这其实会增加代码逻辑上的复杂度，也可能会增加出问题时 debug 的难度，排查一个问题时可能需要跳转多个函数，且多个函数之间都可能出现问题。这个问题我一直没有一个清晰的答案，在几个单元的作业中，我认为代码逻辑简单更重要，但这种想法也不一定对。这个问题最终的答案我可能也要到后续的代码编写实践中获取了。 测试思维的演进其实在这四个单元中，我的测试思路没有什么变化，都是黑白箱结合的方式。一方面通过阅读代码梳理逻辑等方式进行白箱测试，另一方面编写评测机或者数据生成器进行测试或对拍。这种测试方法的优点是效果尚可，只要生成的数据强度过硬就能测出代码的 bug，同时结合一点编写针对性debug样例的技巧，能够快速地定位bug，便于后续debug。 具体而言： 第一单元，借用递归下降的优势，测试数据的生成，和程序的编写，都可以一同使用，采用了大量的随机数据与少数特殊数据因子相结合的构建方法。 第二单元，DPO😭狠狠的膜了。 第三单元，主要是随机数据，同时考虑查询数据的大量性，保证基本正确性的前提下，构建大量查询边界数据来测试 TLE。另外，还有 Junit测试。 第四单元，鉴于数据有极大的限制，前期边界条件的模糊，在没有保证自己评测会不会正确的前提下，后续参考张鑫和高鹏飞同学的评测机并加以魔改来完成评测。 课程收获 入宝山不要空手而归 其实在上 OO 课之前，我就已经听说过其大名了，知道 OO 很苦很累但是能学到不少东西。但实际体验的收获还是超乎我的想象。我竟然还在一个星期内学会了多线程，这种高效率的学习是我非常喜欢的。在这之前，我也自学过各种东西，但网上的教程总是学起来效率很低，且缺乏在指导下的大规模高效实践，导致学出来只能用来吹没法实干。但 OO 课程却完全解决了这个问题，OO 课通过高压的训练和适当的引导让我很快的发现解决问题所需的重点知识并掌握了它们，在 OO 课程的学习中，我还接触了很多面向对象和 Java 以外的有用的东西，比如 JML 与契约式编程或是非常使用的 UML还有通过python来搭建评测机。这些知识也让我受益匪浅。总而言之，通过 OO 课程的学习，我见识并掌握了很多各种各样的知识，练就了各种各样的能力，收获满满。最后，很感谢老师们和助教们长久以来的付出和对我的帮助，也注 OO 课程越办越好。 还是那句古训，无论艰难困苦，最后结果成功也好，失败也罢，莫以成败论英雄， 入宝山切莫空手而归！！！","link":"/2025/08/13/OO-4/"},{"title":"RooKie_Z P4 Verilog单周期CPU设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z的P4单周期CPU设计文档，在课上测试中本CPU取得了 满分💯的成绩。 总体设计概述本次要求实现的指令集为 add, sub, ori, lw, sw, beq, lui, jal, jr, nop，要求与P3相似，考虑到我P3已经实现了这些指令，并且经过课上测试，感觉CPU总体架构与模块化较为清晰完备，故本次暂不重构，直接翻译Logisim电路。 同样的，与P3类似本次依然做好了实现 各类branch,jump,link指令和诸如lb,lbu,lh,lhu,sb,sh等指令的工作，以备不时之需，但相较Logisim，显然Verilog里面的指令可以更加花哨，这时就比较考验写组合逻辑电路的手法了。 整体架构仍与与肖利民老师课件中的图类似 用ISE完成后整体文件树形图如下 仿真模板如下 关键模块介绍命名规则 在顶层模块 mips.v，内，所有实例化元件的命名均为大写字母开头的模块名，如 Ifu, Npc, Alu 等。 wire类电线命名仍采用小驼峰法与下划线结合的方式，力求可读性强，便于扩展，分为几类讨论，如在顶层模块mips.v内采用小驼峰命名法，在不产生重复误会的前提下，力求wire名称与实例化后的模块端口名称一致，而在对于易混信号，则采用类似 grf_rd1,RD1_rs,这样的命名法加以区别，在 CTRL 内，对于判断具体指令，则采用指令相同的命名，如add,sub……。 控制信号如果是控制元件的操作类型以Op结尾，如ALUOp，DMOp等；如果是多路选择器的控制信号，则以Sel结尾，如A3Sel，WDSel等； 端口命名与P3相同 控制信号的宏定义命名为元件名+下划线+功能，如ALU_add，NPC_jal，DM_w，DM_h等 opcode和funct信号的宏命名为OP/FUNC+下划线+小写指令名，如 OP_beq，FUNC_add 宏定义介绍“工欲善其事必先利其器”，好的宏定义是规范CPU搭建的前提，否则指令一多，程序可读性便急剧降低。 因此，本次搭建CPU时特意建立了一个 signal_def.v 的宏定义文件，来统筹管理各个信号定义，具体分为一下几部分 OP_Code and Func_Code，管理各指令的指令编码，便于识别； GRF signals，管理有关GRF的控制信号，包括 WDSel和A3Sel 两块； DM signals，管理DM读写方式的信号，主要供 DMOp 使用； EXTOp, 管理扩展方式； NPCOp，管理NPC生成方式； CMPOp, 管理CMP的比较方式； ALUSrcB，管理B选择数据来源； ALUOp，管理ALU的计算方式； 至此，宏定义部分结束，课上添加指令时一定要看好并在signal_def.v的文件里进行增添！ Warning：define后不要加分号！！！define生成的宏使用时要加 “`”！！！ 综合考量了课上进行功能拓展的方便程度和适宜Verilog语法的需求，我对于P3的CPU中的模块进行了重新排列组合，并且参考当时CPU中BranchDefine子电路的思想，新增了CMP模块，来控制分支信号。 GRF直接翻译P3电路 端口说明 端口名称 方向 描述 A1[4:0] I 5位地址信号，将其对应寄存器中的值输出到RD1 A2[4:0] I 5位地址信号，将其对应寄存器中的值输出到RD2 A3[4:0] I 5位地址信号，将WD输入的值写入其对应的寄存器中 WD[31:0] I 32位输入信号，将值写入A3对应的寄存器中 WE I 1位写使能信号，高电平写入，低电平无事发生 RD1[31:0] O 32位输出值，输出A1对应寄存器中储存的值 RD2[31:0] O 32位输出值，输出A2对应寄存器中储存的值 clk I 时钟信号 reset I 同步复位信号，高电平将所有寄存器复位到0，低电平无事发生 相关控制信号说明1、A3Sel 控制信号值 功能 A3Sel_rd 选择待写入寄存器地址来自Instr[15:11] (R Type) A3Sel_rt 选择待写入寄存器地址来自Instr[20:16] (I Type) A3Sel_ra 选择写入寄存器的地址为31($ra) (含link的指令) 2、WDSel 控制信号值 功能 WDSel_DMout 选择写入寄存器的数据来自DM (lw sw等指令) WDSel_ALUout 选择写入寄存器的数据来自ALU运算结果 WDSel_PC4 选择写入寄存器的数据为PC+4 (含link的指令存$ra的值) EXT将16位二进制数进行零扩展或符号扩展到32位 控制信号说明 控制信号值 功能 EXT_unsigned 零扩展 EXT_signed 符号扩展 IFU(指令读取单元)与P3不同，考虑到NPC需要便于维护，改为将IM与PC合在一起组成IFU 端口说明 端口名称 方向 描述 NPC[31:0] I 待写入PC的指令地址 clk I 时钟信号 reset I 同步复位信号，高电平复位PC到32’h0000_3000 PC O 当前指令地址 Instr[31:0] O 32位的指令值 rs[4:0] O $rs地址 rt[4:0] O $rt地址 rd[4:0] O $rd地址 imm16[15:0] O 16位立即数 imm[31:0] O 32位立即数，实际上取26位 func[5:0] O 6位func opcode[5:0] O 6位opcode shamt[4:0] O 5位位移量，用于sll，srl等位移指令 ALU端口说明 端口名称 方向 功能描述 A[31:0] I 32位输入运算数A B[31:0] I 32位输入运算数B shamt[4:0] I 移位指令所移位数 ALUOp[4:0] O 控制信号 ALUout[31:0] O 32位输出运算结果 控制信号说明1. ALUOp 控制信号值 功能 ALU_add 执行加法运算 ALU_sub 执行减法运算 ALU_or 执行逻辑或运算 ALU_lui 执行lui指令 2. ALUBSel 控制信号值 功能 SrcB_rt 选择寄存器中的值进行运算 SrcB_imm 选择立即数进行运算 CMP(分支比较)参考P3中CPU内BranchDefine子电路生成的CMP模块，来生成jump信号，判断分支是否跳转，link是否写入 目前实现了beq, bne, bgtz, bltz等指令 代码实现：1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1ps`include &quot;signal_def.v&quot;module CMP( input [31:0] rs, input [31:0] rt, input [2:0] CMPOp, output reg jump ); wire eq = (rs == rt); wire ne = !eq; wire ltz = ($signed(rs) &lt; 0); wire gtz = ($signed(rs) &gt; 0); wire eqz = (rs == 0); always @(*) begin case (CMPOp) `CMP_beq: begin jump = eq ? 1 : 0; end `CMP_bne: begin jump = ne ? 1 : 0; end `CMP_bltz: begin jump = ltz ? 1 : 0; end `CMP_bgtz: begin jump = gtz ? 1 : 0; end default: jump = 1'b0; endcase endendmodule 端口说明 端口名称 方向 功能描述 rs[31:0] I $rs寄存器的值 rt[31:0] I $rt寄存器的值 CMPOp[2:0] I 控制信号 jump O 指示分支是否跳转 NPC(次地址计算)有了CMP之后，NPC的功能也更加简洁，只需根据NPCOp和jump信号输出NPC信号的值就行 端口说明 端口名称 方向 功能描述 PC[31:0] I 32位输入当前地址 imm[31:0] I 32位立即数 jump I 指示b类型指令是否跳转 NPCOp[2:0] I 控制信号 RD1_rs[31:0] I $ra寄存器保存的32位地址 NPC[31:0] O 32位输出次地址 PC4[31:0] O 输出$PC+4$的值 控制信号说明 控制信号值 功能 NPC_PC4 $NPC = PC + 4$ NPC_branch 执行branch指令 NPC_jal 执行j，jal指令 NPC_jalr 执行jalr，jr指令 DM（数据储存器）端口说明 信号名称 方向 功能描述 Addr[31:0] I 待操作的内存地址 WD[31:0] I 待写入内存的值 clk I 时钟信号 reset I 同步复位信号 DMWr I 写使能信号；1：写入有效；0：写入无效 DMOp[2:0] I 控制信号 DMout[31:0] O 输入地址指向的内存中储存的值 控制信号说明 控制信号值 功能 DM_w 对应lw和sw指令，写入或读取整个字 DM_h 对应lh和sh指令，写入或读取半字 DM_b 对应lb和sb指令，写入或读取整个字 DM_hu 对应lhu指令 DM_bu 对应lbu指令 数据通路分析 指令 opcode funct NPCOp A3Sel WDSel EXTOp GRFWE ALUSRCB ALUOp DMWr DMOp add 000000 100000 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_add 0 X sub 000000 100010 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_sub 0 X ori 001101 X NPC_PC4 A3Sel_rt WDSel_ALUout EXT_unsigned 1 SrcB_imm ALU_or 0 X lw 100011 X NPC_PC4 A3Sel_rt WDSel_DMout EXT_signed 1 SrcB_imm ALU_add 0 DM_w sw 101011 X NPC_PC4 X WDSel_DMout EXT_signed 0 SrcB_imm ALU_add 1 DM_w beq 000100 X NPC_branch X X X 0 X X 0 X lui 001111 X NPC_PC4 A3Sel_rt WDSel_ALUout X 1 SrcB_imm ALU_lui 0 X jal 000011 X NPC_jal A3Sel_ra WDSel_PC4 X 1 X X 0 X jr 000000 001000 NPC_jalr X X X 0 X X X X 调试过程记录Warnings 首先是要看清楚RTL语言，这是最重要的。比如说最经典的就是beq指令后面的offset这个偏移量实际上要左移再加上$PC + 4$; 再就是要区分RTL语言中的符号，比如说注意区分 rt 和$ rt ，前者代表 rt 的地址，后者代表 GPR($rt)(即$rt对应寄存器的值) 测试方案通过弱测后，采用C++程序随机生成较强数据的方法进行测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include &lt;ctime&gt;typedef long long ll;using namespace std;unsigned int grf[32];int reg[] = {0, 1, 2, 3, 31};int dm[1024];#define R reg[rand() % 5]#define I (rand() + rand())#define B (rand() % 650)void add(int rs, int rt, int rd){ printf(&quot;add $%d,$%d,$%d\\n&quot;, rd, rt, rs); if (rd) grf[rd] = grf[rs] + grf[rt];}void sub(int rs, int rt, int rd){ printf(&quot;sub $%d,$%d,$%d\\n&quot;, rd, rt, rs); if (rd) grf[rd] = grf[rs] - grf[rt];}void ori(int rs, int rt, int imm){ printf(&quot;ori $%d,$%d,%d\\n&quot;, rt, rs, imm); if (rt) grf[rt] = grf[rs] | imm;}void lui(int rs, int rt, int imm){ printf(&quot;lui $%d,%d\\n&quot;, rs, imm); if (rs) grf[rs] = 1u * imm &lt;&lt; 16;}void lw(int rs, int rt){ int imm = rand() % 1024 * 4; printf(&quot;lw $%d,%d($0)\\n&quot;, rt, imm); grf[rt] = dm[imm / 4];}void sw(int rs, int rt){ int imm = rand() % 1024 * 4; printf(&quot;sw $%d,%d($0)\\n&quot;, rt, imm); dm[imm / 4] = grf[rt];}int jump[1010];void beq(int rs, int rt){ int jaddr = B; while (jump[jaddr]) jaddr = B; printf(&quot;beq $%d,$%d,label%d\\n&quot;, rs, rt, jaddr);}void j(){ int jaddr = B; while (jump[jaddr]) jaddr = B; printf(&quot;j label%d\\n&quot;, jaddr);}void jal(){ int jaddr = B; while (jump[jaddr]) jaddr = B; printf(&quot;jal label%d\\n&quot;, jaddr);}int jr(int rs, int rt){ int i; vector&lt;int&gt; can; can.clear(); for (i = 0; i &lt; 5; i++) if (reg[i] &gt; 0x3000 &amp;&amp; reg[i] &lt;= 0x3700) can.push_back(reg[i]); if (can.size() == 0) { beq(rs, rt); return 0; } rs = can[rand() % can.size()]; printf(&quot;jr $%d\\n&quot;, rs); return 1;}void nop(){ printf(&quot;nop\\n&quot;);}int main(){ int i; srand(time(NULL)); freopen(&quot;mips_code.txt&quot;, &quot;w&quot;, stdout); printf(&quot;sub $31,$31,$31\\n&quot;); //���$sp int last = -1; for (i = 0; i &lt; 1000; i++) { printf(&quot;label%d: &quot;, i); int instr = rand() % 11; while ((i &lt; 300 || last == 1) &amp;&amp; instr &gt;= 6 &amp;&amp; instr &lt;= 9) { //j+j instr = rand() % 11; } int rs = R, rt = R, rd = R, imm = I; if (instr == 0) add(rs, rt, rd); else if (instr == 1) sub(rs, rt, rd); else if (instr == 2) ori(rs, rt, imm); else if (instr == 3) lui(rs, 0, imm); else if (instr == 4) lw(rs, rt); else if (instr == 5) sw(rs, rt); else if (instr == 6) beq(rs, rt); else if (instr == 7) j(); else if (instr == 8) jal(); else if (instr == 9) { int yes = jr(rs, rt); if (!yes) instr = 6; //beq } else nop(); jump[i] = last = (instr &gt;= 6 &amp;&amp; instr &lt;= 9); } printf(&quot;label:\\n beq $0,$0,label\\nnop&quot;); return 0;} 其中一组较强数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260ori $29,$0,0x22fcori $28,$0,0x1800ori $31,$0,0x3000label0:noplabel1:sub $6,$7,$18label2:add $8,$15,$23label3:add $26,$3,$15label4:ori $19,$13,0xaa14label5:noplabel6:ori $11,$0,0x13clw $21,28($11)label7:noplabel8:ori $7,$0,0xd0lw $2,36($7)label9:beq $12,$20,label11label10:beq $18,$3,label187label11:ori $20,$0,0x14csw $27,36($20)label12:beq $17,$0,label26label13:add $12,$15,$3label14:ori $20,$0,0x1c0sw $4,12($20)label15:lui $2,0x8226label16:add $6,$17,$15label17:noplabel18:noplabel19:add $20,$14,$16label20:ori $23,$0,0x1b4sw $4,8($23)label21:noplabel22:beq $16,$24,label80label23:noplabel24:ori $14,$0,0x1c4sw $25,40($14)label25:add $0,$7,$3label26:noplabel27:sub $28,$12,$27label28:ori $3,$0,0x0sw $27,32($3)label29:ori $18,$0,0x1b8sw $26,24($18)label30:ori $26,$0,0x11csw $18,24($26)label31:ori $23,$0,0x94sw $19,16($23)label32:ori $16,$0,0xc4lw $4,16($16)label33:ori $26,$0,0x120lw $20,28($26)label34:ori $18,$0,0x178sw $1,16($18)label35:noplabel36:noplabel37:ori $19,$0,0x140sw $16,12($19)label38:noplabel39:lui $11,0xa5e6label40:lui $22,0xce2elabel41:add $17,$30,$8label42:ori $17,$0,0x118lw $25,36($17)label43:ori $0,$0,0x1dcsw $15,8($0)label44:sub $8,$22,$2label45:ori $14,$0,0x1b8lw $6,40($14)label46:noplabel47:noplabel48:add $5,$14,$22label49:ori $17,$29,0x5cc8label50:ori $24,$0,0x100sw $22,16($24)label51:sub $21,$24,$28label52:ori $29,$0,0xf8lw $22,24($29)label53:sub $19,$2,$23label54:ori $5,$22,0x4cbalabel55:add $7,$22,$9label56:lui $15,0xa746label57:add $30,$6,$25label58:ori $23,$0,0x90sw $4,8($23)label59:ori $22,$0,0xfcsw $6,36($22)label60:jal label129label61:beq $1,$21,label184label62:sub $4,$28,$0label63:add $7,$17,$12label64:add $13,$2,$26label65:lui $24,0x1093label66:sub $24,$2,$17label67:ori $16,$0,0x1a4lw $29,8($16)label68:ori $24,$0,0x1d0lw $21,0($24)label69:sub $17,$27,$17label70:noplabel71:noplabel72:jr $31label73:ori $26,$0,0x6clw $20,40($26)label74:noplabel75:ori $17,$0,0x184lw $4,24($17)label76:ori $26,$0,0xb8sw $16,28($26)label77:ori $3,$0,0xe0sw $19,24($3)label78:ori $16,$10,0xdd62label79:add $21,$23,$15label80:ori $1,$0,0x98lw $18,24($1)label81:beq $25,$19,label127label82:noplabel83:ori $5,$0,0x1e8sw $14,36($5)label84:add $7,$11,$17label85:ori $21,$0,0x6d65label86:beq $26,$28,label119label87:lui $8,0x12calabel88:ori $8,$0,0x1e0sw $18,36($8)label89:add $9,$3,$21label90:sub $25,$29,$15label91:lui $3,0x2f2flabel92:beq $26,$14,label196label93:noplabel94:ori $24,$0,0x8lw $12,24($24)label95:jal label161label96:ori $10,$0,0x2csw $13,0($10)label97:ori $22,$0,0x34lw $20,36($22)label98:ori $17,$0,0xecsw $24,16($17)label99:sub $1,$21,$7label100:ori $24,$0,0xc8sw $30,24($24)label101:ori $5,$0,0x124lw $24,4($5)label102:ori $30,$0,0x16clw $20,36($30)label103:jr $31label104:sub $29,$1,$7label105:jal label108label106:ori $22,$22,0xc2c4label107:jr $31label108:ori $1,$0,0x1c0lw $18,0($1)label109:noplabel110:noplabel111:ori $18,$0,0xfcsw $1,24($18)label112:noplabel113:beq $25,$23,label163label114:jal label161label115:sub $27,$1,$19label116:jr $31label117:beq $19,$2,label161label118:ori $1,$6,0xe0c4label119:sub $27,$24,$5label120:sub $17,$22,$8label121:lui $20,0xad45label122:sub $7,$16,$9label123:ori $6,$0,0x168sw $6,36($6)label124:ori $21,$0,0x1d0lw $4,24($21)label125:sub $4,$30,$10label126:ori $20,$7,0xae65label127:ori $1,$0,0x1csw $17,12($1)label128:jal label163label129:ori $13,$0,0x17csw $25,36($13)label130:ori $5,$0,0x1a4lw $24,0($5)label131:noplabel132:ori $22,$0,0x198lw $27,32($22)label133:ori $16,$0,0xf8sw $7,28($16)label134:ori $26,$29,0xc317label135:beq $2,$14,label172label136:add $7,$16,$0label137:beq $6,$14,label190label138:lui $23,0xe5d7label139:beq $23,$2,label164label140:ori $17,$0,0x134lw $11,32($17)label141:noplabel142:add $2,$28,$26label143:beq $7,$22,label197label144:noplabel145:ori $5,$30,0xbbf8label146:sub $15,$13,$15label147:jal label191label148:jr $31label149:beq $20,$1,label176label150:ori $9,$0,0x198sw $6,40($9)label151:noplabel152:ori $19,$0,0xf8sw $13,40($19)label153:lui $12,0x5e6dlabel154:noplabel155:ori $20,$0,0xf4sw $12,8($20)label156:ori $15,$2,0xa110label157:ori $29,$0,0x24sw $24,0($29)label158:sub $29,$23,$27label159:ori $5,$12,0x4d32label160:ori $2,$0,0xecsw $25,36($2)label161:beq $26,$10,label192label162:lui $17,0xa5b3label163:noplabel164:jal label195label165:ori $27,$0,0x14lw $9,12($27)label166:jal label178label167:lui $6,0x64dflabel168:jal label195label169:jal label193label170:ori $1,$0,0x94lw $17,24($1)label171:jr $31label172:ori $25,$19,0xf861label173:sub $0,$15,$4label174:beq $30,$20,label183label175:noplabel176:beq $22,$21,label187label177:noplabel178:beq $26,$8,label186label179:ori $10,$0,0x1e0lw $12,12($10)label180:beq $16,$29,label198label181:noplabel182:add $22,$2,$26label183:noplabel184:ori $9,$0,0x30sw $23,4($9)label185:lui $24,0xe9ablabel186:add $1,$16,$7label187:ori $26,$0,0x80sw $19,40($26)label188:beq $0,$29,label194label189:sub $4,$19,$19label190:jal label196label191:add $27,$19,$7label192:noplabel193:add $28,$3,$14label194:jal label199label195:jal label198label196:beq $15,$16,label197label197:sub $1,$20,$5label198:noplabel199:nop 魔改MARS输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@00003000: $29 &lt;= 000022fc@00003004: $28 &lt;= 00001800@00003008: $31 &lt;= 00003000@00003010: $ 6 &lt;= 00000000@00003014: $ 8 &lt;= 00000000@00003018: $26 &lt;= 00000000@0000301c: $19 &lt;= 0000aa14@00003024: $11 &lt;= 0000013c@00003028: $21 &lt;= 00000000@00003030: $ 7 &lt;= 000000d0@00003034: $ 2 &lt;= 00000000@00003040: $20 &lt;= 0000014c@00003044: *00000170 &lt;= 00000000@00003090: $28 &lt;= 00000000@00003094: $ 3 &lt;= 00000000@00003098: *00000020 &lt;= 00000000@0000309c: $18 &lt;= 000001b8@000030a0: *000001d0 &lt;= 00000000@000030a4: $26 &lt;= 0000011c@000030a8: *00000134 &lt;= 000001b8@000030ac: $23 &lt;= 00000094@000030b0: *000000a4 &lt;= 0000aa14@000030b4: $16 &lt;= 000000c4@000030b8: $ 4 &lt;= 00000000@000030bc: $26 &lt;= 00000120@000030c0: $20 &lt;= 00000000@000030c4: $18 &lt;= 00000178@000030c8: *00000188 &lt;= 00000000@000030d4: $19 &lt;= 00000140@000030d8: *0000014c &lt;= 000000c4@000030e0: $11 &lt;= a5e60000@000030e4: $22 &lt;= ce2e0000@000030e8: $17 &lt;= 00000000@000030ec: $17 &lt;= 00000118@000030f0: $25 &lt;= 00000000@000030f8: *00000008 &lt;= 00000000@000030fc: $ 8 &lt;= ce2e0000@00003100: $14 &lt;= 000001b8@00003104: $ 6 &lt;= 00000000@00003110: $ 5 &lt;= ce2e01b8@00003114: $17 &lt;= 00007efc@00003118: $24 &lt;= 00000100@0000311c: *00000110 &lt;= ce2e0000@00003120: $21 &lt;= 00000100@00003124: $29 &lt;= 000000f8@00003128: $22 &lt;= ce2e0000@0000312c: $19 &lt;= ffffff6c@00003130: $ 5 &lt;= ce2e4cba@00003134: $ 7 &lt;= ce2e0000@00003138: $15 &lt;= a7460000@0000313c: $30 &lt;= 00000000@00003140: $23 &lt;= 00000090@00003144: *00000098 &lt;= 00000000@00003148: $22 &lt;= 000000fc@0000314c: *00000120 &lt;= 00000000@00003150: $31 &lt;= 00003154@000032b8: $13 &lt;= 0000017c@000032bc: *000001a0 &lt;= 00000000@000032c0: $ 5 &lt;= 000001a4@000032c4: $24 &lt;= 00000000@000032cc: $22 &lt;= 00000198@000032d0: $27 &lt;= 00000000@000032d4: $16 &lt;= 000000f8@000032d8: *00000114 &lt;= ce2e0000@000032dc: $26 &lt;= 0000c3ff@000032e4: $ 7 &lt;= 000000f8@000032ec: $23 &lt;= e5d70000@000032f4: $17 &lt;= 00000134@000032f8: $11 &lt;= 00000000@00003300: $ 2 &lt;= 0000c3ff@0000330c: $ 5 &lt;= 0000bbf8@00003310: $15 &lt;= 58ba017c@00003314: $31 &lt;= 00003318@000033ec: $27 &lt;= 00000064@000033f4: $28 &lt;= 000001b8@000033f8: $31 &lt;= 000033fc Isim仿真输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@00003000: $29 &lt;= 000022fc@00003004: $28 &lt;= 00001800@00003008: $31 &lt;= 00003000@00003010: $ 6 &lt;= 00000000@00003014: $ 8 &lt;= 00000000@00003018: $26 &lt;= 00000000@0000301c: $19 &lt;= 0000aa14@00003024: $11 &lt;= 0000013c@00003028: $21 &lt;= 00000000@00003030: $ 7 &lt;= 000000d0@00003034: $ 2 &lt;= 00000000@00003040: $20 &lt;= 0000014c@00003044: *00000170 &lt;= 00000000@00003090: $28 &lt;= 00000000@00003094: $ 3 &lt;= 00000000@00003098: *00000020 &lt;= 00000000@0000309c: $18 &lt;= 000001b8@000030a0: *000001d0 &lt;= 00000000@000030a4: $26 &lt;= 0000011c@000030a8: *00000134 &lt;= 000001b8@000030ac: $23 &lt;= 00000094@000030b0: *000000a4 &lt;= 0000aa14@000030b4: $16 &lt;= 000000c4@000030b8: $ 4 &lt;= 00000000@000030bc: $26 &lt;= 00000120@000030c0: $20 &lt;= 00000000@000030c4: $18 &lt;= 00000178@000030c8: *00000188 &lt;= 00000000@000030d4: $19 &lt;= 00000140@000030d8: *0000014c &lt;= 000000c4@000030e0: $11 &lt;= a5e60000@000030e4: $22 &lt;= ce2e0000@000030e8: $17 &lt;= 00000000@000030ec: $17 &lt;= 00000118@000030f0: $25 &lt;= 00000000@000030f8: *00000008 &lt;= 00000000@000030fc: $ 8 &lt;= ce2e0000@00003100: $14 &lt;= 000001b8@00003104: $ 6 &lt;= 00000000@00003110: $ 5 &lt;= ce2e01b8@00003114: $17 &lt;= 00007efc@00003118: $24 &lt;= 00000100@0000311c: *00000110 &lt;= ce2e0000@00003120: $21 &lt;= 00000100@00003124: $29 &lt;= 000000f8@00003128: $22 &lt;= ce2e0000@0000312c: $19 &lt;= ffffff6c@00003130: $ 5 &lt;= ce2e4cba@00003134: $ 7 &lt;= ce2e0000@00003138: $15 &lt;= a7460000@0000313c: $30 &lt;= 00000000@00003140: $23 &lt;= 00000090@00003144: *00000098 &lt;= 00000000@00003148: $22 &lt;= 000000fc@0000314c: *00000120 &lt;= 00000000@00003150: $31 &lt;= 00003154@000032b8: $13 &lt;= 0000017c@000032bc: *000001a0 &lt;= 00000000@000032c0: $ 5 &lt;= 000001a4@000032c4: $24 &lt;= 00000000@000032cc: $22 &lt;= 00000198@000032d0: $27 &lt;= 00000000@000032d4: $16 &lt;= 000000f8@000032d8: *00000114 &lt;= ce2e0000@000032dc: $26 &lt;= 0000c3ff@000032e4: $ 7 &lt;= 000000f8@000032ec: $23 &lt;= e5d70000@000032f4: $17 &lt;= 00000134@000032f8: $11 &lt;= 00000000@00003300: $ 2 &lt;= 0000c3ff@0000330c: $ 5 &lt;= 0000bbf8@00003310: $15 &lt;= 58ba017c@00003314: $31 &lt;= 00003318@000033ec: $27 &lt;= 00000064@000033f4: $28 &lt;= 000001b8@000033f8: $31 &lt;= 000033fc 完全一致，测试通过！ Warnings易错点：1.非阻塞赋值与display的内容不相符 评测机是通过看我们display的东西和它需要的一样不一样来评判我们是否正确的。如果采用非阻塞赋值，紧接着来一句display的话，由于非阻塞赋值是在过程块结束时才统一赋值的，所以输出的东西是未修改的。 2.位宽 对于0x0000_3000，它的位宽是32位，所以二进制写法是32’b00000000000000000011000000000000,省事写16进制的话，是32’h0000_3000，这里的32指的是位宽，而不是这个数在某种进制下有几位！ 3.jr跳转 jr不只是可以跳31号寄存器存的地址，任何寄存器存储的地址它都可以跳！这是室友P4课上遭遇的车祸现场，课下弱测并没有测试出来！ 请务必检查jr是否写对了！ 4.还是display 需要输出32位宽的内存地址，不是【13:2】（12位）地址，请大家看好自己的输出！和教程中提供的输出比对一下，应该就会发现。 5.Reset常见误区 首先是同步复位，这个老生常谈了。之后就是reset的地方够不够，对不对，我们需要reset的地方是程序计数器PC，寄存器堆GRF，数据存储器DM，除此之外，如果发现自己在其他地方也使用了reset，就得好好斟酌一下，这里到底需不需要reset？比如，我发现自己在IM中加了一个reset，本地测试过了，提交没输出，为何？经过了一天的思考和从各方获取经验，我隐约意识到可能是复位出了问题，IM里面为什么需要reset？是防止PC值没有变成0x0000_3000吗？我最开始的确是这么想的，所以在里面加了reset，但是，后来我发现，我reset的并不是输入进来的PC，而是，指令存储空间！！也就是说，考虑到评测机最开始上来就reset一下，我读入的code直接没了，当然之后没有输出。为何本地没有测出来问题？因为我没有检查reset,只是保持reset=0跑的程序。这个点卡了我一天多，也卡了评论区不少同学好长时间。还有类似的问题如输出比正常的慢一周期的，也请看看reset。这样，关于reset的坑差不多就介绍完了。 新增指令要点： 注意条件分支带link的指令需改动的点，signal_def中添加OP，CMP_OP，在CMP中分析跳转模式，增加相应case分支。重点：CTRL内的信号添加。首先是添加相应导线，再在NPCOp内添加相应的| 导线名，WDsel的部分添加相应的| 导线名，A3sel的部分也添加相应的| 导线名，最后在于关键的WE信号，因为我采用了取反的方式，所以直接在括号内添加相应的指令模块，如对于bgezal指令，WE可写为 assign GRFWE = !(sw | beq | j | sh | sb | jr | (bgezal &amp; !jump));，重点就在添加(bgezal &amp; !jump)部分！！！ 谨记！！！ 对于复杂计算，则观察计算方法，由于ALU内部采用了case语句的模式，故可以考虑另写functional来保证计算方式合理添加，具体寄存器选择信号则观察指令相似处，与相同模式指令同处加| 导线名即可！！！ 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？ MIPS中以字节为单位，而在我们设计的DM中，每一个reg[31:0]为一个单位。 Addr来自ALU的输出端口，代表要读取的DM存储器的地址，在DM设计中应当取[11:0]，又因为按字节寻址，因此除以4取 [11:2]； 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。 指令对应控制信号取值： 123456789101112`define R 6'b000000 `define lw 6'b100011 case(Instr[31:26]) `R: begin case(Instr[5:0]) 6'b100000:add RegDst=2'b01; Regwrite=1'b1; ALUsrc=2'b00; ALUctrl=3‘b000; Memwrite=0; MemtoReg=2'b00; 6'b100010:sub RegDst=2'b01; Regwrite=1'b1; ALUsrc=2'b00; ALUctrl=3‘b001; Memwrite=0; MemtoReg=2'b00; …… endcase end ` `lw: …… endcase 这种译码方式，对于信号的控制不容易遗漏，对于每一个信号都需要给一个值，清晰易读,比较直观，但是添加指令比较复杂，需要给出完整的控制信号，对于不需要的信号也需要给定默认值，这样也会导致控制部分的代码比较长。 控制信号每种取值所对应的指令 123456789101112131415161718wire add=(Instr[31:26]==6'b000000 &amp;&amp; Instr[5:0] == 6'b100000); wire sub=(Instr[31:26]==6'b000000 &amp;&amp; Instr[5:0] == 6'b100010); ……assign RegDst[1]=1'b0|jal; assign RegDst[0]=1'b0|add|sub; assign Regwrite=1'b0|add|sub|ori|lw|lui|jal; assign EXTop=1'b0|lw|sw; assign ALUsrc[1]=1'b0; assign ALUsrc[0]=1'b0|ori|lw|sw|lui; assign ALUctrl[2]=1'b0; assign ALUctrl[1]=1'b0|ori; assign ALUctrl[0]=1'b0|sub; assign Memwrite=1'b0|sw; assign MemtoReg[1]=1'b0|lui|jal; assign MemtoReg[0]=1'b0|lw|lui; assign NPCop[1]=1'b0|beq|jr; assign NPCop[0]=1'b0|jal|jr|j; assign Branchop[2]=1'b0; assign Branchop[1]=1'b0; assign Branchop[0]=1'b0; assign DMop[1]=1'b0; assign DMop[0]=1'b0; 这种译码方式，是对控制信号用了或指令的方式，如果满足这条指令，就会使的控制信号有效，这种方式的优点在于可以很容易的添加指令，对于指令只需要在相应控制信号之后或上一个即可，但是缺点是不够直观，可能会造成漏加信号的错误。 经过P3的拷打，我认为还是第二种比较好。 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。 在同步复位中，clk的优先级是高于reset的，只有在时钟上升沿到来时reset信号有效才进行复位，单有reset信号而时钟上升沿信号没有到来不能进行复位。 在异步复位中，reset优先级高于clk，不论是否是时钟上升沿来临，只要reset信号高电平就清零。 C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。 根据RTL语言描述：addi与addiu的区别在于当出现溢出时，addiu忽略溢出，并将溢出的最高位舍弃；addi会报告SignalException(IntegerOverflow) 故忽略溢出，二者等价。","link":"/2025/08/10/P4-CPU/"},{"title":"RooKie_Z P5 Verilog流水线CPU设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z的P5流水线CPU设计文档，在课上测试中本CPU取得了 满分💯的成绩。 总体设计概述本次要求实现的指令集为add, sub, ori, lw, sw, beq, lui, jal, jr, nop，与P3、P4相同，但是工作量却天差地别，我的黑眼圈也很能说明这点。言归正传，在考虑到更好地满足转发的要求与利于课上进行增量开发的前提下，我对于P4的代码进行了一部分重构，但总体上更改并不大，具体的设计方案参考自高小鹏老师的PPT和CoekJan学长的博客，他们的详尽叙述帮我省下了大量琢磨AT方法的时间。CoekJan，YYDS！！！ 五级流水线各级部件 数据通路添加转发后的数据通路 注：MDU为乘除法单元，供P6使用 关键模块介绍总体而言，在总体架构不作大的修改的前提下，修改了一部分控制信号，同时添加了流水线各级寄存器和虚拟的阻塞控制单元，对于每一级流水线都设计了相应的译码器。 命名规则 对于各模块文件，均采用对于元件的文件命名，均为流水线层级_元件英文简称，例如D_GRF.v，E_ALU.v等，实例化时命名为大写首字母小写英文名，例如Alu，Grf等 对于流水线寄存器文件命名为两边的流水线层级_REG，例如FD_REG.v，DE_REG.v，实例化时命名为大写英文层级，例如FD 每一级的控制信号和临时的wire均以本级的名称开头，如E_ALUOp，M_DMOp等 在流水线中参与流水的信息遵从以下约定（以D级为例） PC和Instr命名以流水线层级开头，如D_PC，D_Instr 寄存器地址分别为D_rs_addr，D_rt_addr，读出数据为D_rs，D_rt 转发得到的寄存器数据（直接读取也视为一种转发）记作D_FWD_rs_data，D_FWD_rt_data 即将写入的寄存器地址为E_A3，即将写入的数据记作E_WD，选择信号为E_WDSel F级（取指） F级不需要转发，阻塞时停止读入指令，置低PC_WE 本级输入来自D级的NPC，输出F_PC和F_Instr，参与流水 IFU 信号名称 方向 功能描述 NPC[31:0] I 待写入PC的指令地址 clk I 时钟信号 reset I 同步复位信号 PC_WE I PC的写使能 PC O 当前指令地址 Instr[31:0] O 32位的指令值 FD_REG（F/D级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） F_PC I F级PC的指令地址 F_Instr[31:0] I 时钟信号 D_PC O D级PC的指令地址 D_Instr[31:0] O 32位的指令值 D级（译码） 本级需要处理来自E, M, W级的转发，其中W级为寄存器内部转发，另外两个分别是D_FWD_rs,D_FWD_rt，在CMP和NPC中需要用 本级的输入是来自F级的PC和Instr，输出是D_rs，D_rt，D_Ext_Out，D_PC和D_Instr，这些参与流水，还有输出到F级的NPC 本级元件较多，是最复杂的一级 D_GRF端口说明 信号名称 方向 功能描述 A1[4:0] I 5位地址输入信号，将其储存的数据读出到RD1 A2[4:0] I 5位地址输入信号，将其储存的数据读出到RD2 A3[4:0] I 5位地址输入信号，将其作为写入数据的目标寄存器 RD1[31:0] O 输出A1指定的寄存器中的32位数据 RD2[31:0] O 输出A2指定的寄存器中的32位数据 WD[31:0] I 32位数据输入信号 clk I 时钟信号 reset I 同步复位信号，将32个寄存器中的数据清零；1：复位；0：无效 这次删去了WE写使能信号，因为如果我们不写寄存器，可以把A3设为0，就相当于不写寄存器了 Ps ：这是我灵光一现想到的办法，受了P4课上访存指令的启发，如果有指令要在读出之后针对数据判断是否写入GRF，那么WE信号不仅要一直参与流水，还要用于控制每级的转发与阻塞，利用0寄存器的特点就可以规避这一切的麻烦！！！ 控制信号说明1. D_A3 直接给出待写入寄存器的地址，弃用了在P4中利用A3Sel进行选择的设计，这是因为P5采用分布式译码，每一级都需要A3的信息，因此在CTRL里面直接集成了 2. D_WDSel 控制信号值 功能 WDSel_DMout 选择写入寄存器的数据来自DM WDSel_ALUout 选择写入寄存器的数据来自ALU运算结果 WDSel_PC8 选择写入寄存器的数据为当前流水线层级中的PC+8 D_EXT将16位二进制数进行零扩展或符号扩展到32位 控制信号说明 控制信号值 功能 EXT_unsigned 零扩展 EXT_signed 符号扩展 D_CMP(分支比较)参考P3中CPU内BranchDefine子电路生成的CMP模块，来生成jump信号，判断分支是否跳转，link是否写入 目前实现了beq, bne, bgtz, bltz等指令 代码实现：1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1ps`include &quot;signal_def.v&quot;module CMP( input [31:0] rs, input [31:0] rt, input [2:0] CMPOp, output reg jump ); wire eq = (rs == rt); wire ne = !eq; wire ltz = ($signed(rs) &lt; 0); wire gtz = ($signed(rs) &gt; 0); wire eqz = (rs == 0); always @(*) begin case (CMPOp) `CMP_beq: begin jump = eq ? 1 : 0; end `CMP_bne: begin jump = ne ? 1 : 0; end `CMP_bltz: begin jump = ltz ? 1 : 0; end `CMP_bgtz: begin jump = gtz ? 1 : 0; end default: jump = 1'b0; endcase endendmodule 端口说明 端口名称 方向 功能描述 rs[31:0] I 转发后$rs寄存器的值 rt[31:0] I 转发后$rt寄存器的值 CMPOp[2:0] I 控制信号 jump O 指示分支是否跳转 D_NPC(次地址计算)有了CMP之后，NPC的功能也更加简洁，只需根据NPCOp和jump信号输出NPC信号的值就行 实际上NPC横跨了F级和D级两级，因为同时会输入F_PC和D_PC，前者正常跳转F_PC+4用，后者则用于流水PC值，后面转发PC+8的时候用 这次我们弃用了P4中直接输出PC+4的设计，转而让PC信号参与流水，在需要转发时计算PC+8 端口说明 端口名称 方向 功能描述 F_PC[31:0] I 32位输入当前F级地址 D_PC[31:0] I 32位输入当前D级地址 imm[31:0] I 32位立即数 jump I 指示b类型指令是否跳转 NPCOp[2:0] I 控制信号 RD1_rs[31:0] I $ra寄存器保存的32位地址 NPC[31:0] O 32位输出次地址 控制信号说明 控制信号值 功能 NPC_pc4 NPC = F_PC+4 NPC_b 执行beq等b类指令 NPC_jal 执行j，jal指令 NPC_jalr 执行jalr，jr指令 DE_REG（D/E级流水线寄存器） 输入D_PC,D_Instr,D_Ext_Out，此外上一级的$rs和$rt的值也要参与流水，即D_FWD_rs,D_FWD_rt需要参与流水，这是由于指令序列sw, nop, add的存在，sw在M级需要使用$rt的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的$rt值参与流水 输出E_PC,E_Instr,E_Ext_Out,E_rs,E_rt，ALU需要这些信息 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） D_PC[31:0] I D级PC的指令地址 D_Instr[31:0] I 32位的指令值 D_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 D_rs[31:0] I 32位的寄存器数据 D_rt[31:0] I 32位的寄存器数据 E_PC[31:0] O E级PC的指令地址 E_Instr[31:0] O 32位的指令值 E_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 E_rs[31:0] O 32位的寄存器数据 E_rt[31:0] O 32位的寄存器数据 E级（执行）E_ALU 相比于P4，ALU做了很大的变动，添加了ALUSrcA信号选择A运算数的来源，这是为了便于扩展sll和sllv类指令的原因取消了shamt信号，shamt信号从ALUSrcB中选择进入ALU中 端口说明 信号名称 方向 功能描述 A[31:0] I 32位输入运算数A B[31:0] I 32位输入运算数B ALUOp[4:0] I 控制信号 ALUOut[31:0] O 32位输出运算结果 控制信号说明1. ALUOp 控制信号值 功能 ALU_add 执行加法运算 ALU_sub 执行减法运算 ALU_or 执行逻辑或运算 ALU_lui 执行lui指令 2. ALUSrcA 控制信号值 功能 SrcA_rt 对于sll和sllv等移位指令，选择$rt的值 SrcA_rs 对于其他大部分运算指令，采用 $rs的值 3. ALUSrcB 控制信号值 功能 SrcB_rt 选择处理完转发后$rt寄存器中的值进行运算 SrcB_imm 选择立即数进行运算 SrcB_shamt 使用{27'b0, E_ALUshamt}得到32为扩展移位数 SrcB_rs 考虑到sllv指令要求可变的位移数，这里可以选择{27'b0, E_FWD_rs_data[4:0]}，即$rs寄存器中的数据作为移位数 EM_REG（E/M级流水线寄存器） 输入E_PC,E_Instr，此外上一级的ALUOut参与流水，即E_ALU_Out,E_Ext_Out需要参与流水，这是因为ALUOut可能是待写入或读取的内存地址，另外，上一级的rt值需要参与流水，因此还需要输入E_FWD_rt，这是因为sw指令会向内存中写入$rt的数据 输出M_PC,M_Instr,M_ALU_Out,M_DM_Out 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） E_PC[31:0] I E级PC的指令地址 E_Instr[31:0] I 32位的指令值 E_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 E_rt[31:0] I 32位的寄存器数据 E_ALU_Out[31:0] I 32位的ALU运算结果 M_PC[31:0] O M级PC的指令地址 M_Instr[31:0] O 32位的指令值 M_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 M_ALU_Out[31:0] O 32位的ALU运算结果 M_rt[31:0] O 32位的寄存器数据 M级（储存）M_DM端口说明 信号名称 方向 功能描述 Addr[31:0] I 待操作的内存地址 WD[31:0] I 待写入内存的值 clk I 时钟信号 reset I 同步复位信号 DMWr I 写使能信号；1：写入有效；0：写入无效 DMOp[2:0] I 控制信号 DMout[31:0] O 输入地址指向的内存中储存的值 控制信号说明 控制信号值 功能 DM_w 对应lw和sw指令，写入或读取整个字 DM_h 对应lh和sh指令，写入或读取半字 DM_b 对应lb和sb指令，写入或读取整个字 DM_hu 对应lhu指令 DM_bu 对应lbu指令 W级（回写）MW_REG（M/W级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） M_PC[31:0] I M级PC的指令地址 M_Instr[31:0] I 32位的指令值 M_DM_Out[31:0] I 从内存中读取的值 M_ALU_Out[31:0] I 32位的ALU运算结果 W_PC[31:0] O W级PC的指令地址 W_Instr[31:0] O 32位的指令值 W_DM_Out[31:0] O 从内存中读取的值 W_ALU_Out[31:0] O 32位的ALU运算结果 数据通路分析 指令 opcode funct NPCOp A3Sel WDSel EXTOp GRFWE ALUSRCB ALUOp DMWr DMOp add 000000 100000 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_add 0 X sub 000000 100010 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_sub 0 X ori 001101 X NPC_PC4 A3Sel_rt WDSel_ALUout EXT_unsigned 1 SrcB_imm ALU_or 0 X lw 100011 X NPC_PC4 A3Sel_rt WDSel_DMout EXT_signed 1 SrcB_imm ALU_add 0 DM_w sw 101011 X NPC_PC4 X WDSel_DMout EXT_signed 0 SrcB_imm ALU_add 1 DM_w beq 000100 X NPC_branch X X X 0 X X 0 X lui 001111 X NPC_PC4 A3Sel_rt WDSel_ALUout X 1 SrcB_imm ALU_lui 0 X jal 000011 X NPC_jal A3Sel_ra WDSel_PC8 X 1 X X 0 X jr 000000 001000 NPC_jalr X X X 0 X X X X 本CPU采用分布式译码，在每一级均设有译码器，解码出各级所需信息 冲突处理方法转发(Forwarding)对于转发，我们直接采用 AT 法 + 暴力转发，首先要搞明白转发到哪，转发什么。 对于每一个流水线层级，我们要能够确定当前这一级正在执行的指令要写什么数据，向哪里写，因此就要维护 GRFWD （解决转发啥）和 GRFA3 （解决转发到哪）这两个值，我们转发需要去关注的也就是这两个数据，这些信号都可以从 Control 里面译码读出来 简单来说就是，我们需要在每一级都知道本级需要从哪读数据，要写到哪，要写啥，现在不知道没事，总之在这条指令从流水线消失之前，我们肯定知道，并且可以根据这些再经过判断做转发。 在每一个需要用转发数据的地方，我们去比较要用的数据的 GPR 地址和前面正在维护的要写的 GRFA3 的地址，如果相同，那就意味着我们要写的寄存器已经被用了，但是这时前面获得的值显然是错误的，这时候直接转发过去就好了 这里还要考虑优先级的问题，流水线寄存器生成的WD越靠近这条指令，得到的数据就越新，我们就越倾向于优先使用这些数据 利用 AT 法，如果不阻塞就意味着一定能够在使用该寄存器的值之前获得正确的值，如果我们要用的时候，这个正确的值还没有算出来，那肯定不行，这时候我们就阻塞，如果能算出来，那么之前转发的错误的值不用去管它，最后总能得到一个正确的值去覆盖原先错误的值 如果我们还不知道要写的值是啥，那这个时候 GRFA3 就给正确的地址， GRFWD 就给 32'bz ，这时还不能做转发，但是如果写的阻塞模块正确，这个值就不可能被转发，因为这种情况如果出现就已经被阻塞在 D 级了 综合考量各种指令序列，我们得到了转发的旁路： D级需求: E-&gt;D(如序列jal-add), M-&gt;D(如序列jal-nop-add)(W-&gt;D隐藏于GRF的内部转发中); E级需求: M-&gt;E(如序列add-add), W-&gt;E(如序列add-nop-add) M级需求: W-&gt;M(如序列add-sw) 具体设计见前文图片 代码实现W to D: 12345// 寄存器内部转发 assign RD1 = (A1 == 5'b00000) ? 32'h0000_0000 : (A3 == A1 &amp;&amp; A1 != 5'b00000) ? WD : grf[A1]; assign RD2 = (A2 == 5'b00000) ? 32'h0000_0000 : (A3 == A2 &amp;&amp; A2 != 5'b00000) ? WD : grf[A2]; D级转发处理： 12345678910//D级写回数据 assign D_FWD_rs_data = (D_rs_addr == 0) ? 0 : (D_rs_addr == E_A3) ? E_WD : (D_rs_addr == M_A3) ? M_WD : D_rs; assign D_FWD_rt_data = (D_rt_addr == 0) ? 0 : (D_rt_addr == E_A3) ? E_WD : (D_rt_addr == M_A3) ? M_WD : D_rt; E级转发处理： 12345678910//转发 assign E_FWD_rs_data = (E_rs_addr == 0) ? 0 : (E_rs_addr == M_A3) ? M_WD : (E_rs_addr == W_A3) ? W_WD : E_rs; assign E_FWD_rt_data = (E_rt_addr == 0) ? 0 : (E_rt_addr == M_A3) ? M_WD : (E_rt_addr == W_A3) ? W_WD : E_rt; M级转发处理： 12345678//转发 assign M_FWD_rt_data = (M_rt_addr == 0) ? 0 : (M_rt_addr == W_A3) ? W_WD : M_rt; assign M_WD = (M_WDSel == `WDSel_PC8) ? M_PC + 8 : (M_WDSel == `WDSel_ALUout) ? M_ALU_Out : 32'bz; 阻塞(Stall)对于阻塞的处理，直接采用教程中的AT方法，设计一个 Stall 模块，专门负责处理阻塞时流水线寄存器的 flush 和 WE 信号就行 只在 D 级进行阻塞，阻塞控制器接受当前 D，E，M 级的指令输入，处理分析指令类别，算出当前D的Tuse，和E、M的Tnew，再进行相应的计算 代码实现：1234567891011121314151617181920212223242526//阻塞逻辑 wire E_stall_rs = ((E_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rs); wire E_stall_rt = ((E_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rt); wire M_stall_rs = ((M_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rs); wire M_stall_rt = ((M_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rt); assign Stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt; //清空当前指令信号，即插入nop wire FD_Flush, DE_Flush, EM_Flush, MW_Flush; assign FD_WE = !Stall; //不再进新指令 assign DE_WE = 1'b1; assign EM_WE = 1'b1; assign MW_WE = 1'b1; assign PC_WE = !Stall; assign FD_Flush = 1'b0; assign DE_Flush = Stall; //阻塞到D级，清空DE寄存器 assign EM_Flush = 1'b0; assign MW_Flush = 1'b0; 测试方案：先进行弱测，即跑完了提交窗口的测试数据，没有问题。 单条指令功能测试：ori测试：1234ori $t0, $t0, 1ori $t1, $t1, 0ori $t3, $t3, 0x7fffori $t4, $t3, 0xffff add测试：1234ori $t0, $t0, 2ori $t1, $t1, 0xffffadd $t2, $t0, $t0add $t3, $t1, $t1 sub测试：123456ori $t0, $t0, 2ori $t1, $t1, 0xffffsub $t2, $t0, $t0sub $t3, $t1, $t1sub $t4, $t1, $t0sub $t4, $t0, $t1 lui测试：12lui $t0, 0x7fffori $t0, $t0, 0x777f beq测试：1234567891011121314151617181920212223242526272829303132333435363738#三次跳转ori $t3, $t4, 1beq $3, $t0, Aori $t1, $t1, 0xffffA:beq $0, $t0, Blui $t1, 0xffffC:ori $t1, $t1, 1lui $t0, 1B:beq $t0, $0, Clui $t2, 0xffff//后跳beq $t3, $t0, Aori $t1, $t1, 0xffffori $t2, $t2, 0xffffA:lui $t1, 0xffff//不跳beq $3, $t0, AnopA:beq $0, $t0, BnopC:lui $t0, 1B:beq $t0, $0, Cnop//前跳beq $3, $t0, AnopB:lui $t0, 1A:beq $0, $t0, Bnop j，jal，jr测试：1234567891011121314151617jal Aori $s1, $s1, 0x1111add $ra, $ra, $t2ori $s1, $s1, 0x2222A:lui $t1, 200jal Aori $t0, $t0, 0x1111sub $t1, $t1, $t0ori $t2, $t2, 0x1111beq $t2, $t2, BnopA:jr $raadd $t3, $t0, $t0B: sw，lw测试：123456789ori $t0, $t0, 4 #t0 = 4add $t1, $t0, $t0 # t1 = 8sub $t2, $t0, $t1 # t2 = -4add $t3, $t2, $t2 #t3 = -8sub $t4, $t0, $t3 #t4 = csw $t4, 16($t4) # add = 1csw $t3, -4($t1) # add = 4lw $t5, 16($t4) lw $t6, -4($t1) 之后对于各种边界情况和转发阻塞情况，进行覆盖测试： 提供一组超强测样例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019.textinit_1:j init_44 lui $0, 58479init_2:j init_61 lui $26, 40699init_3:nopj init_26 ori $29, 12340init_4:j init_21 lui $9, 18793init_5:nopj init_9 ori $13, 19610init_6:j init_38 ori $28, 17819init_7:nopj init_37 ori $27, 17810init_8:j init_48 ori $14, 1324init_9:j init_8 lui $14, 20958init_10:j init_31 lui $4, 28505init_11:nopj init_13 ori $23, 24263init_12:j init_16 ori $12, 2525init_13:j init_62 lui $24, 49213init_14:j init_59 ori $6, 27235init_15:j init_52 ori $16, 28030init_16:j init_5 lui $13, 39021init_17:j init_23 lui $20, 45636init_18:nopj init_57 ori $7, 34738init_19:j init_56 lui $22, 48232init_20:j init_7 lui $27, 21269init_21:nopj init_24 ori $9, 60940init_22:j init_47 lui $19, 24579init_23:j init_53 ori $20, 23617init_24:j init_27 lui $10, 4700init_25:nopj init_60 ori $5, 25135init_26:j init_34 lui $30, 14559init_27:j init_29 ori $10, 45253init_28:j init_12 lui $12, 55820init_29:j init_36 lui $11, 49875init_30:j init_25 lui $5, 35220init_31:j init_30 ori $4, 7615init_32:j begin lui $31, 60984init_33:j init_43 ori $2, 18084init_34:j init_63 ori $30, 41019init_35:j init_15 lui $16, 54272init_36:nopj init_28 ori $11, 2111init_37:j init_6 lui $28, 33755init_38:j init_3 lui $29, 26291init_39:nopj init_2 ori $25, 48740init_40:j init_42 lui $1, 43965init_41:nopj init_19 ori $21, 27953init_42:nopj init_50 ori $1, 18337init_43:j init_54 lui $3, 36555init_44:j init_40 ori $0, 39840init_45:j init_22 ori $18, 28396init_46:j init_4 ori $8, 13173init_47:nopj init_17 ori $19, 60189init_48:j init_49 lui $15, 28446init_49:nopj init_35 ori $15, 43996init_50:j init_33 lui $2, 50534init_51:j init_45 lui $18, 47692init_52:j init_58 lui $17, 18098init_53:j init_41 lui $21, 23125init_54:nopj init_10 ori $3, 34935init_55:j init_39 lui $25, 37200init_56:j init_64 ori $22, 41245init_57:j init_46 lui $8, 16690init_58:nopj init_51 ori $17, 23659init_59:j init_18 lui $7, 16431init_60:j init_14 lui $6, 20586init_61:j init_20 ori $26, 21724init_62:j init_55 ori $24, 64211init_63:j init_32 lui $31, 32491init_64:j init_11 lui $23, 36591begin: ori $11, $11, 39941 sw $11, 0($0) ori $22, $22, 13378 nop sw $22, 4($0) addu $8, $31, $16 nop nop sw $8, 8($0) subu $20, $16, $6 sw $20, 12($0) addu $9, $15, $7 nop sw $9, 16($0) addu $19, $23, $27 nop nop sw $19, 20($0) subu $5, $1, $31 sw $5, 24($0) addu $22, $6, $26 nop sw $22, 28($0) addu $10, $4, $18 nop nop sw $10, 32($0) subu $19, $3, $0 sw $19, 36($0) subu $22, $24, $1 nop sw $22, 40($0) subu $19, $10, $14 nop nop sw $19, 44($0) subu $0, $19, $15 sw $0, 48($0) ori $21, $21, 728 nop sw $21, 52($0) subu $13, $29, $4 nop nop sw $13, 56($0) addu $11, $3, $1 sw $11, 60($0) addu $27, $19, $11 nop sw $27, 64($0) addu $27, $16, $28 nop nop sw $27, 68($0) ori $25, $25, 7272 sw $25, 72($0) ori $31, $31, 65375 nop sw $31, 76($0) ori $13, $13, 65318 nop nop sw $13, 80($0) ori $5, $5, 27677 sw $5, 84($0) ori $13, $13, 30209 nop sw $13, 88($0) subu $16, $28, $20 nop nop sw $16, 92($0) addu $6, $16, $21 sw $6, 96($0) subu $22, $11, $31 nop sw $22, 100($0) subu $25, $23, $19 nop nop sw $25, 104($0) ori $0, $0, 8927 sw $0, 108($0) ori $24, $24, 21563 nop sw $24, 112($0) addu $13, $16, $11 nop nop sw $13, 116($0) subu $14, $12, $27 sw $14, 120($0) addu $15, $24, $27 nop sw $15, 124($0) subu $20, $1, $24 nop nop sw $20, 128($0) subu $13, $28, $15 sw $13, 132($0) ori $28, $28, 56842 nop sw $28, 136($0) addu $31, $6, $23 nop nop sw $31, 140($0) ori $10, $10, 11112 sw $10, 144($0) addu $21, $23, $9 nop sw $21, 148($0) subu $22, $16, $29 nop nop sw $22, 152($0) addu $16, $1, $31 sw $16, 156($0) subu $12, $15, $28 nop sw $12, 160($0) addu $6, $10, $22 nop nop sw $6, 164($0) ori $12, $12, 14691 sw $12, 168($0) ori $16, $16, 34145 nop sw $16, 172($0) ori $11, $11, 18551 nop nop sw $11, 176($0) sw $sp, 180($0) sw $ra, 184($0) sw $at, 188($0) ori $sp, $0, 4060 ori $1, $0, 32 jal foo1 nop lui $1, 0 ori $1, 0 beq $1, $0, skip_manual1 nop j dl nopskip_manual1: lui $1, 10994 lui $2, 10994 beq $1, $2, skip_manual2 nop j dl nopskip_manual2: lui $3, 10995 nop nop beq $1, $3, dl addu $4, $4, $3 lui $1, 0x6183 addu $2, $2, $1 lui $5, 0x8124 addu $4, $5, $1 subu $6, $6, $5 jal skip_manual3 nop sw $0, 4($0)skip_manual3: sw $7, -0x3000($ra) lw $ra, -0x3000($ra) ori $ra, $0, 0 jal skip_manual4 nop sw $0, 8($0)skip_manual4: beq $ra, $0, dl nop ori $ra, $0, 0 jal skip_manual5 nop sw $ra, 12($0)skip_manual5: nop beq $ra, $0, dl nop ori $4, $0, 4 ori $5, $0, 5 ori $1, $0, 1 addu $4, $4, $1 nop nop beq $4, $5, skip_manual6 nop sw $0, 16($0)skip_manual6: ori $1, $0, 1 ori $2, $0, 2 ori $3, $0, 3 ori $4, $0, 4 ori $5, $0, 6 ori $6, $0, 5 subu $5, $5, $1 addu $6, $2, $1 beq $5, $6, dl nop jal skip_manual8 nopskip_manual8: addu $3, $3, $ra subu $4, $4, $ra jal foo nop jal fooo nop jal foooo nop jal fooooo nopsw $0, 192($0)sw $1, 196($0)sw $2, 200($0)sw $3, 204($0)sw $4, 208($0)sw $5, 212($0)sw $6, 216($0)sw $7, 220($0)sw $8, 224($0)sw $9, 228($0)sw $10, 232($0)sw $11, 236($0)sw $12, 240($0)sw $13, 244($0)sw $14, 248($0)sw $15, 252($0)sw $16, 256($0)sw $17, 260($0)sw $18, 264($0)sw $19, 268($0)sw $20, 272($0)sw $21, 276($0)sw $22, 280($0)sw $23, 284($0)sw $24, 288($0)sw $25, 292($0)sw $26, 296($0)sw $27, 300($0)sw $28, 304($0)sw $29, 308($0)sw $30, 312($0)sw $31, 316($0) lui $31, 63605 jal tag_0 nop ori $ra, $0, 2tag_0:sw $ra, 320($0) addu $14, $13, $7 jal tag_1 nop ori $ra, $0, 2tag_1:sw $ra, 324($0) lw $25, 12($0) jal tag_2 nop ori $ra, $0, 2tag_2:sw $ra, 328($0) lui $29, 14949 nop jal tag_3 nop ori $ra, $0, 2tag_3:sw $ra, 332($0) addu $10, $24, $1 nop jal tag_4 nop ori $ra, $0, 2tag_4:sw $ra, 336($0) lw $12, 164($0) nop jal tag_5 nop ori $ra, $0, 2tag_5:sw $ra, 340($0) lui $31, 58593 nop nop jal tag_6 nop ori $ra, $0, 2tag_6:sw $ra, 344($0) addu $1, $7, $12 nop nop jal tag_7 nop ori $ra, $0, 2tag_7:sw $ra, 348($0) lw $20, 256($0) nop nop jal tag_8 nop ori $ra, $0, 2tag_8:sw $ra, 352($0) lui $17, 19367 jal tag_9 nop ori $ra, $0, 2tag_9:sw $ra, 356($0) addu $8, $11, $11 jal tag_10 nop ori $ra, $0, 2tag_10:sw $ra, 360($0) lw $1, 132($0) jal tag_11 nop ori $ra, $0, 2tag_11:sw $ra, 364($0) lui $18, 56313 nop jal tag_12 nop ori $ra, $0, 2tag_12:sw $ra, 368($0) addu $23, $25, $24 nop jal tag_13 nop ori $ra, $0, 2tag_13:sw $ra, 372($0) lw $20, 368($0) nop jal tag_14 nop ori $ra, $0, 2tag_14:sw $ra, 376($0) lui $21, 22951 nop nop jal tag_15 nop ori $ra, $0, 2tag_15:sw $ra, 380($0) addu $8, $10, $1 nop nop jal tag_16 nop ori $ra, $0, 2tag_16:sw $ra, 384($0) lw $4, 88($0) nop nop jal tag_17 nop ori $ra, $0, 2tag_17:sw $ra, 388($0) ori $4, $0, 12 jal skip_manual7 nopskip_manual7: addu $ra, $ra, $4 jr $ra ori $4, $0, 8 addu $ra, $ra, $4 nop jr $ra nopdl:addu $ra, $0, $0 beq $0, $0, dl nopfoo: jr $ra ori $ra, $ra, 0xfffooo: ori $6, $ra, 0xa jr $ra nopfoooo: jr $ra ori $t8, $ra, 0xfffooooo: ori $t9, $ra, 0xa jr $ra nopfoo1: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 84 ori $s2, $0, 220 lw $t0, -40($s1) lw $t1, -88($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 11072 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 30986 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip1 nop jal foo2 subu $sp, $sp, $1skip1: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo2: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 152 ori $s2, $0, 54 lw $t1, 326($s2) lw $t0, 160($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 21109 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 60683 ori $a2, $a1, 0xf0 beq $a2, $a1, skip2 nop jal foo3 subu $sp, $sp, $1skip2: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo3: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 139 ori $s2, $0, 302 lw $t0, -35($s1) lw $t1, -34($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 29202 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 43269 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip3 nop jal foo13 subu $sp, $sp, $1skip3: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo4: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 297 ori $s2, $0, 96 lw $t1, 104($s2) lw $t0, -197($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 14171 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 18179 ori $a2, $a1, 0xf0 beq $a2, $a1, skip4 nop jal foo11 subu $sp, $sp, $1skip4: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo5: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 106 ori $s2, $0, 190 lw $t0, -26($s1) lw $t1, -82($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 49045 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 36619 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip5 nop jal foo1 subu $sp, $sp, $1skip5: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo6: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 345 ori $s2, $0, 52 lw $t1, -32($s2) lw $t0, 15($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 25874 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 45316 ori $a2, $a1, 0xf0 beq $a2, $a1, skip6 nop jal foo4 subu $sp, $sp, $1skip6: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo7: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 319 ori $s2, $0, 212 lw $t0, -167($s1) lw $t1, 120($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 44079 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 38407 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip7 nop jal foo10 subu $sp, $sp, $1skip7: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo8: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 366 ori $s2, $0, 244 lw $t1, -116($s2) lw $t0, -290($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 20552 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 22025 ori $a2, $a1, 0xf0 beq $a2, $a1, skip8 nop jal foo5 subu $sp, $sp, $1skip8: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo9: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 223 ori $s2, $0, 283 lw $t0, 13($s1) lw $t1, -27($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 28872 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 52993 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip9 nop jal foo15 subu $sp, $sp, $1skip9: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo10: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 228 ori $s2, $0, 255 lw $t1, -155($s2) lw $t0, 12($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 56866 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 21770 ori $a2, $a1, 0xf0 beq $a2, $a1, skip10 nop jal foo12 subu $sp, $sp, $1skip10: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo11: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 54 ori $s2, $0, 306 lw $t0, 278($s1) lw $t1, -238($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 34513 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 36103 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip11 nop jal foo8 subu $sp, $sp, $1skip11: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo12: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 248 ori $s2, $0, 72 lw $t1, 152($s2) lw $t0, 76($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 1104 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 24322 ori $a2, $a1, 0xf0 beq $a2, $a1, skip12 nop jal foo9 subu $sp, $sp, $1skip12: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo13: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 386 ori $s2, $0, 194 lw $t0, -82($s1) lw $t1, -142($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 18477 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 2816 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip13 nop jal foo7 subu $sp, $sp, $1skip13: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo14: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 184 ori $s2, $0, 255 lw $t1, 13($s2) lw $t0, -88($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 26871 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 23821 ori $a2, $a1, 0xf0 beq $a2, $a1, skip14 nop jal foo16 subu $sp, $sp, $1skip14: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo15: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 264 ori $s2, $0, 366 lw $t0, -212($s1) lw $t1, -2($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 36680 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 1289 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip15 nop jal foo14 subu $sp, $sp, $1skip15: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo16: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 39 ori $s2, $0, 301 lw $t1, -17($s2) lw $t0, 317($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 706 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 2561 ori $a2, $a1, 0xf0 beq $a2, $a1, skip16 nop jal foo6 subu $sp, $sp, $1skip16: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nop 对拍输出一致，或许对吧…… 思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。 在回答这个问题之前，我们需要知道，在原本的设计中，beq的分支结果应该在E级产生，现在改在D级产生，这就造成了如下所示的问题： 123lw $t0, 0($0)nopbeq $t1, $t0, label 原本的设计中，beq在E级，lw在W级，正好转发就可以给到新生成的$t0的值，而现在，beq在D级就要新的$t0的值,来不及转发，被迫暂停了，效率降低。 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把PC+8写入寄存器，不然jr后延迟槽内的指令又会再执行一次 我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？ 不妨举一个例子，假设这是各个阶段的时间： F D E M W 50 100 100 150 100 如果此时D阶段需要E的ALU计算的结果，假设数据刚进入D和E级（即刚刚有效沿到来），我们要ALUOut，所以需要100s等待其出结果，然后过了100s后结果出来了，可以转发给D级了，但是此时还没完，D拿到了这个数据，需要对其进行处理，所以又花了100s。也就是说，为了保证正确性，我们的周期最少是200s，而其实150s就够了（即最大周期M级——150s）。只是因为我们进行了这个错误的设计。 我们为什么要使用 GPR 内部转发？该如何实现？ 为了保持W级的写入和此时D级的读出是同一个值，规避数据冒险。 代码实现： 12345// 寄存器内部转发 assign RD1 = (A1 == 5'b00000) ? 32'h0000_0000 : (A3 == A1 &amp;&amp; A1 != 5'b00000) ? WD : grf[A1]; assign RD2 = (A2 == 5'b00000) ? 32'h0000_0000 : (A3 == A2 &amp;&amp; A2 != 5'b00000) ? WD : grf[A2]; 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 详见前文转发实现部分 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。 高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改mips.v内的数据通路 对于计算类：首先改变CTRL，添加相关的wire，注意每个指令的控制信号的对应，之后就直接修改ALU就行了。 对于访存类：改变CTRL，并修改DM增加相应的功能，改变DMOp，并且在mips.v的顶层模块内增添相应控制信号。 对于跳转类：修改CTRL，并在CMP内增添相应功能，同时根据链接条件增添相应check信号。 简要描述你的译码器架构，并思考该架构的优势以及不足。 我采用了分布式译码； 优势当然是实现更加容易实现，不需要考察每一级具体要保留和传递哪些译码上的信息，实现起来比较容易，并且进行增量开发更加容易。 缺点当然是对于资源浪费严重，而且需要实例化的端口太多了，容易编译错误，而且导线太多，容易犯些隐蔽的错误！！！ 主观上来说，我觉得分布式译码就是一个赖子办法，不具备设计上的美感，集中式译码才能体现对于流水线的理解和设计的能力，奈何我不具备，只好用分布式了……","link":"/2025/08/10/P5-CPU/"},{"title":"RooKie_Z challenge-shell实现报告","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 总述先上图，看看我的成品Shell 由于我选择的是Lab6的挑战性任务，整体的子任务数较多，故接下来的介绍顺序完全基于我的实现过程，如有不清楚之处，完全源于本人的能力不足，烦请各位看官海涵。 按照评测测试点，我的实现顺序为 $3 \\to 4 \\to 2 \\to 1 \\to 5$，接下来按照这种顺序介绍。 具体实现实现不带 .b 后缀指令spawn函数与 fork 函数类似，其最终效果都是产生一个子进程，不过与 fork函数不同的是，spawn 函数产生的子进程不再执行与父进程相同的程序，而是装载新的 ELF文件，执行新的程序。 事实上 spawn就是在尝试执行shell里的命令，所以在这里尝试追加执行是最佳位置。即当用户指定的程序路径不存在时，在这里尝试在路径后追加 .b 再打开。 具体代码： 123456789101112131415161718192021// user/lib/spawn.c spawnchar tmp[MAXPATHLEN]; if (prog[0] != '.') { strcpy(tmp, &quot;/&quot;); strcpy(tmp + 1, prog); } else { strcpy(tmp, prog); } int fd; fd = open(tmp, O_RDONLY); if (fd &lt; 0) { int len = strlen(tmp); strcpy(tmp + len, &quot;.b&quot;); fd = open(tmp, O_RDONLY); } if (fd &lt; 0) { return fd; } 实现反引号、注释和历史指令实现反引号实现反引号的思路实际上与引号类似，就是当 parsecmd调用 gettoken读到 `,后，进一步解析其后的字符串，直到另一个反引号位置，获取其中的字符串，直接 runcmd()，具体思路可见下面的示意图： 实际上，上述思路的实现尚不成熟，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142//sh.c gettokenif (*s == '`') { in_quot = !in_quot; }if (in_quot) { *p1 = s; while (*s &amp;&amp; ((in_quot &amp;&amp; !strchr(&quot;`&quot;, *s)) ||!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; } //sh.c parsecmdcase '`': debugf(&quot;clg: use `\\n&quot;); gettoken(0, &amp;t); char s[100]; strcpy(s, t); char ch = gettoken(0, &amp;t); ch = gettoken(0, &amp;t); if (ch == 0 || ch == '\\0') { runcmd(s); } else { if (ch == ';') { int fork1 = 0; fork1 = fork(); if (fork1) { wait(fork1); return parsecmd(argv, rightpipe, 1, job_flag); } else { runcmd(s); } } runcmd(s); } 实际上，在后来处理引号的时候，思路就很清晰了： 12345678910111213//sh.c gettokenif(*s == '`') { // 识别反引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '`')){ s++; } *s++ = 0; *p2 = s; return 'r'; //表示反引号} 实现注释实际上，注释的功能和读取空白符并无区别，较为简单，代码见下： 12345678910111213//sh.c gettoken*p1 = s; while (*s &amp;&amp; (!strchr(WHITESPACE SYMBOLS, *s))) { if (*s == '#') { while (*s) { *s++ = 0; } } else { s++; } } *p2 = s; 由于历史指令的实现我使用了追加重定向的功能，故放到下文一并说 实现追加重定向和引号支持实现引号支持与上文反引号思路相同，直接给出代码： 123456789101112131415161718192021222324//sh.c gettokenif(*s == '\\&quot;') { // 识别引号 *s = 0; s++; *p1 = s; while(*s &amp;&amp; (*s != '\\&quot;')){ s++; } *s++ = 0; *p2 = s; return 's'; // it means &quot;string&quot; }//sh.c parsecmdcase 's': if (argc &gt;= MAXARGS) { debugf(&quot;too many arguments\\n&quot;); exit(); } if (need) { argv[argc++] = t; } 实现追加重定向我的思路是添加一个新的写入方式，即追加 APPEND 123456//user/include/lib.h#define O_APPEND 0x0004//user/lib/file.c openif ((mode &amp; O_APPEND) != 0) { fd-&gt;fd_offset = size;} 因为我们的shell原本就支持对于 &gt;&gt;的解析，所以我们只需要在 parsecmd中稍作修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case '&gt;':; int cc; cc = gettoken(0, &amp;t); if (cc == '&gt;') { if (gettoken(0, &amp;t) != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_APPEND | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } else { if (cc != 'w') { debugf(&quot;syntax error: &gt; not followed by word\\n&quot;); exit(); } // Open 't' for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the 'open' function encounters an error, // utilize 'debugf' to print relevant messages, // and subsequently terminate the process using 'exit'. /* Exercise 6.5: Your code here. (2/3) */ if((fd = open(t, O_WRONLY | O_CREAT)) &lt; 0) { debugf(&quot;failed to open '%s'\\n&quot;, t); exit(); } if((r = dup(fd, 1)) &lt; 0) { debugf(&quot;failed to duplicate file to &lt;stdout&gt;\\n&quot;); exit(); } close(fd); } //argv[argc++] = t; //user_panic(&quot;&gt; redirection not implemented&quot;); re_alloc = 1; 这里的 re_alloc是一个全局变量，表示指令进行了重定向，在后续一行多指令的实现中起了作用。 实现历史指令由于我们已经实现了追加写入，那么保存命令就简单了： 1234567891011121314//sh.c save_cmdvoid save_cmd(char* cmd) { int r = open(&quot;/.mosh_history&quot;, O_CREAT | O_WRONLY | O_APPEND); if (r &lt; 0) { debugf(&quot;open /.mosh_history failed to save&quot;); return r; } write(r, cmd, strlen(cmd)); write(r, &quot;\\n&quot;, 1); return 0;}//sh.c main save_cmd(buf); 接下来就可以通过 history命令调取历史记录并输出： 1234567891011121314151617181920212223242526272829//sh.c rumcmd 实现内置指令if (strcmp(argv[0], &quot;history&quot;) == 0) { history(); }//sh.c historyvoid history() { int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed\\n&quot;); return; } char buf; int r; int cnt = 0; int newline = 1; while ((r = read(fdnum, &amp;buf, 1)) != 0) { if (newline) { debugf(&quot;%c&quot;, buf); cnt++; newline = 0; } else { debugf(&quot;%c&quot;, buf); } if (buf == '\\n') { newline = 1; } }} 实现指令回显由于这部分在评测中尚未涉及，故不多赘述，简单介绍原理 我们知道 Linux对于上下左右键的编码 上下左右键在linux中会被编码为 上： 27 ‘[’ ‘A’ 下： 27 ‘[’ ‘B’ 右： 27 ‘[’ ‘C’ 左： 27 ‘[’ ‘D’ 所以我们需要在读到27 [Esc]后连续读取两个字符以判断指令的类型,从而分别调用属于左右键和上下键的不同功能。 具体这部分代码部分参考了Charles学长的博客，下附代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180int newDirCmd = 1;int offset; // 0:empty line, -1:last cmd, -2:...int solveDirCmd(char* buf, int type) { // type: 0 means up, 1 means down if (newDirCmd == 1) { offset = 0; } if (type == 0) { offset--; } else if (offset &lt; 0) { offset++; } int x = 0; if (offset == 0) { while (buf[x] != '\\0') { buf[x] = '\\0'; x++; } return -1; } int fdnum = open(&quot;/.mosh_history&quot;, O_RDONLY); if (fdnum &lt; 0) { debugf(&quot;open /.mosh_history failed in sloveDir!\\n&quot;); return 0; } struct Fd* fd = num2fd(fdnum); char* c; char* begin = fd2data(fd); char* end = begin + ((struct Filefd*)fd)-&gt;f_file.f_size; c = end - 1; while (((*c) == '\\n' || (*c) == 0) &amp;&amp; (c &gt; begin)) { c--; } if (c == begin) { // no history cmd buf[0] = '\\0'; return 0; } c++; // last \\n or \\0 int i; for (i = 0; i &gt; offset; i--) { while ((*c) != '\\n' &amp;&amp; (*c) != '\\0') { c--; if (c &lt;= begin) { break; } } c--; if (c &lt;= begin) { break; } } offset = i; // avoid offset too bigger than real cmd num if (c &gt; begin) { while (c &gt; begin &amp;&amp; (*c) != '\\n') { c--; } if ((*c) == '\\n') { c++; } } else { c = begin; } int now = 0; while (buf[now] != '\\0') { buf[now] = '\\0'; now++; } now = 0; while ((*c) != '\\n' &amp;&amp; (*c) != '\\0' &amp;&amp; (*c) &lt; end) { buf[now] = *c; now++; c++; } return now;}#define MOVELEFT(y) printf(&quot;\\033[%dD&quot;, (y))#define MOVERIGHT(y) printf(&quot;\\033[%dC&quot;, (y))void readline(char* buf, u_int n) { /* TODO:lab6-challenge */ int r; int off = 0; int len = 0; char op; while (off &lt; n) { if ((r = read(0, &amp;op, 1)) != 1) { if (r &lt; 0) { debugf(&quot;read error: %d\\n&quot;, r); } exit(); } if (op == '\\b' || op == 0x7f) { /* TODO:lab6-challenge */ if (off &gt; 0) { if (off == len) { buf[--off] = 0; printf(&quot;\\033[D \\033[D&quot;); } else { for (int j = off - 1; j &lt; len - 1; j++) { buf[j] = buf[j + 1]; } buf[len - 1] = 0; MOVELEFT(off--); printf(&quot;%s &quot;, buf); MOVELEFT(len - off); } len -= 1; } // } else if (op == '\\r' || op == '\\n') { buf[len] = 0; return; } /* TODO:lab6-challenge */ else if (op == 27) { char tmp; read(0, &amp;tmp, 1); char tmp2; read(0, &amp;tmp2, 1); if (tmp == 91 &amp;&amp; tmp2 == 65) { debugf(&quot;\\x1b[B&quot;); // down to cmd line int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); // left to line head } debugf(&quot;\\x1b[K&quot;); // clean line off = solveDirCmd(buf, 0); len = strlen(buf); debugf(&quot;%s&quot;, buf); } else if (tmp == 91 &amp;&amp; tmp2 == 66) { int j; for (j = 0; j &lt; off; j++) { debugf(&quot;\\x1b[D&quot;); } debugf(&quot;\\x1b[K&quot;); off = solveDirCmd(buf, 1); len = strlen(buf); debugf(&quot;%s&quot;, buf); } /* TODO:lab6-challenge */ else if (tmp == 91 &amp;&amp; tmp2 == 67) { if (off &lt; len) { off++; } else { MOVELEFT(1); } } else if (tmp == 91 &amp;&amp; tmp2 == 68) { if (off &gt; 0) { off--; } else { MOVERIGHT(1); } } // newDirCmd = 0; } else { newDirCmd = 1; if (off == len) { buf[off++] = op; } else { // i &lt; len for (int j = len; j &gt; off; j--) { buf[j] = buf[j - 1]; } buf[off] = op; buf[len + 1] = 0; MOVELEFT(++off); printf(&quot;%s&quot;, buf); MOVELEFT(len - off + 1); } len += 1; } } debugf(&quot;line too long\\n&quot;); while ((r = read(0, buf, 1)) == 1 &amp;&amp; buf[0] != '\\r' &amp;&amp; buf[0] != '\\n') { ; } buf[0] = 0;} 由于同时监听了左右键，所以同时了实现键入命令时任意位置的修改实现了在当前光标位置进行字符的增加与删除。在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。 实现一行多指令shell的原理是 main 从控制台读取一行后 fork，把这一行命令传递给子进程。子进程执行完毕后退出，父进程调用 wait函数等待子进程执行结束被摧毁。 因为在 user/sh.c中的保留 SYMBOLS 里已经预留有 ; 字符，gettoken 函数本身就能够解析下一个 ; 字符，所以我们只需要将；作为一个特殊的token即可，我们无需改变词法部分，只需改变语法解释部分。 [!CAUTION] 注意，在实现一行多命令的过程中，务必考虑以下重定向样例 echo &quot;aaa&quot; &gt;&gt; file1; cat file1 如果在上条命令执行后未及时重定向回标准输出，则再进行一次 cat file1会发现 file1中写入了两个 aaa 下附代码： 1234567891011121314151617case ';':; if (need == 0) { return parsecmd(argv, rightpipe, 1, job_flag); } else { int child = fork(); // fork出两个进程 if(child) { // 父进程等待子进程执行完再执行';'右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } wait(child); return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行';'左边的命令 return argc; } } 实现更多指令touch没什么好说的，就创建文件就行了，下附代码： 12345678910111213141516171819202122232425#include &lt;lib.h&gt;void usage(void) { debugf(&quot;usage: touch file...\\n&quot;); exit();}int main(int argc, char *argv[]) { int fd; if (argc &lt; 2) { usage(); } for (int i = 1; i &lt; argc; i++) { if ((fd = open(argv[i], O_CREAT)) &gt;= 0) { close(fd); } else { printf(&quot;touch: cannot touch \\'%s\\': No such file or directory\\n&quot;, argv[i]); } } return 0;} rmrm指令需要解析其输入后的参数，如 -r, -f, -rf等等，我采用了全局变量来实现，同时编写了工具函数 isdir来判断要求的文件是不是目录: 123456789101112131415static void init(){ enableForce = 0; // -f enableRecursive = 0; // -r}int isdir(const char* path){ struct Stat st; if (stat(path, &amp;st) &lt; 0) return 0; return st.st_isdir;} 主体实现部分为两个函数 rm 和 _rm分别表示删除文件和目录，原理较为简单，rm调用 remove删除文件，_rm则通过遍历目标目录后不断递归调用自身，来实现对于目标目录的递归删除，下附代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void rm(const char* path){ int ret; struct Stat st; if ((ret = stat(path, &amp;st)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } if (st.st_isdir &amp;&amp; !enableRecursive) { printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); return; } if (st.st_isdir) _rm(path); ret = remove(path); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, path, ret);}static void _rm(const char* path){ char dir[MAXPATHLEN]; // open directory int fd; if ((fd = open(path, O_RDONLY)) &lt; 0) { if (!enableForce) printf(&quot;rm: cannot remove \\'%s\\': No such file or directory\\n&quot;, path); return; } // get number of sub items int size; int ret; int is_dir; struct File file; while ((size = readn(fd, &amp;file, sizeof(struct File))) == sizeof(struct File)) { if (!file.f_name[0]) continue; strcpy(dir, path); strcat_(dir, &quot;/&quot;); strcat_(dir, file.f_name); is_dir = isdir(dir); if (is_dir) { if (!enableRecursive) printf(&quot;rm: cannot remove \\'%s\\': Is a directory\\n&quot;, path); else _rm(dir); } ret = remove(dir); if (ret != 0) debugf(&quot;Failed to remove '%s': %d\\n&quot;, dir, ret); }} mkdirmkdir是这3个指令中最麻烦的一个，考虑到 -p指令的特殊性，为实现这一条指令，新增了不少工具函数： 12345678910111213141516171819202122232425262728293031323334//user/include/fsreq.hstruct Fsreq_create{ char req_path[MAXPATHLEN]; u_int req_omode;}; //表示创建目录//fs/fs.cint file_creat(const char* path, u_int omode, struct File** pfile){ char name[MAXNAMELEN]; struct File* dir; struct File* f; int ret; if ((ret = walk_path(path, &amp;dir, &amp;f, name)) == 0) return -E_FILE_EXISTS; if ((ret != -E_NOT_FOUND) || (dir == NULL)) return ret; if ((ret = dir_alloc_file(dir, &amp;f)) &lt; 0) return ret; strcpy(f-&gt;f_name, name); f-&gt;f_type = (omode &amp; O_MKDIR) ? FTYPE_DIR : FTYPE_REG; if (pfile) *pfile = f; // file_flush(f); return 0;} //创建目录 在 mkdir.c中，思路与 rm类似，同时创建了 access工具函数，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void init(){ enableParents = 0;}//accessint access(const char* path, int type){ char dir[MAXPATHLEN]; struct Stat st; int ret; while (*path &amp;&amp; (*path == ' ')) path++; strcpy_(dir, path); // debugf(&quot;Access: %s\\n&quot;, dir); ret = stat(dir, &amp;st); if (ret &lt; 0) { // debugf(&quot;Acess error: %d\\n&quot;, ret); return 0; } if (type == FTYPE_DIR) return st.st_isdir; else if (type == FTYPE_REG) return !st.st_isdir; return 1;}//mkdirstatic int mkdir(const char* path){ char dir[MAXPATHLEN]; const char* p = path; const char* base = path; while (*p != '\\0') { while (*p &amp;&amp; (*p != '/')) p++; memcpy_(dir, base, p - base); dir[p - base] = '\\0'; while (*p &amp;&amp; (*p == '/')) p++; if (*p) // there are remaining directories to create try(_create(dir, enableParents, 0)); else // the last element try(_create(dir, 1, 1)); } return 0;} 主体 mkdir函数中，通过不断调用 _create函数，来实现目录的递归创建： 12345678910111213141516171819202122232425static int _create(const char* path, int create, int final){ if (access(path, FTYPE_DIR)) { if (!final) return 0; printf(&quot;mkdir: cannot create directory \\'%s\\': File exists\\n&quot;, path); return 11; } // now, there is no such a file if (!create &amp;&amp; !final) { printf(&quot;mkdir: cannot create directory \\'%s\\': No such file or directory\\n&quot;, path); return 13; } // now, it's time to create file int ret = creat(path, O_MKDIR); if (ret &lt; 0) { debugf(&quot;Failed to create '%s': %d\\n&quot;, path, ret); return ret; } return 0;} 实现指令条件执行个人认为这是本次挑战性任务中最难的一个点，在深思熟虑后，我并未采取课程组提供的修改 exit函数的思路 指令返回值获取同时，根据讨论区于恩泽同学的前车之鉴，我新建了专门的 ipc来发送返回值： 12345678910111213141516171819202122232425262728//user/lib/ipc.cvoid ipc_send_cmd(u_int whom, u_int val, const void *srcva, u_int perm) { int r; while ((r = syscall_ipc_try_send_cmd(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) { syscall_yield(); } user_assert(r == 0);}u_int ipc_recv_cmd(u_int *whom, void *dstva, u_int *perm) { int r = syscall_ipc_recv_cmd(dstva); if (r != 0) { user_panic(&quot;syscall_ipc_recv err: %d&quot;, r); } if (whom) { *whom = env-&gt;env_ipc_from; } if (perm) { *perm = env-&gt;env_ipc_perm; } return env-&gt;env_ipc_value;}//env.hu_int env_ipc_recving_cmd; //whether this env is receiving cmd 然后在 libos.c 和 debugf.c中进行修改，使相关函数能够发送返回值： 12345678910111213141516171819202122232425262728//libos.cvoid libmain(int argc, char **argv) { // set env to point at our env structure in envs[]. env = &amp;envs[ENVX(syscall_getenvid())]; // call user main routine int r; r = main(argc, argv); debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); syscall_env_job_done(env-&gt;env_id); // exit gracefully exit();}//debugf.cvoid _user_panic(const char *file, int line, const char *fmt, ...) { debugf(&quot;panic at %s:%d: &quot;, file, line); va_list ap; va_start(ap, fmt); vdebugf(fmt, ap); va_end(ap); debugf(&quot;\\n&quot;); // //ipc_send(env-&gt;env_parent_id, r, 0, 0); ipc_send_cmd(env-&gt;env_parent_id, -1, 0, 0); exit();} 根据返回值条件执行指令同时在 runcmd中进行修改，来获取和发送返回值，同时给 parsecmd添加一个参数，根据上条命令的返回值，来指示当前命令是否执行，同时在 gettoken中添加判断，来解析 &amp;&amp; 和 ||，下附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//gettokenif (*s == '&amp;') { if (*(s + 1) == '&amp;') { *s++ = 0; flag = 'a'; } } if (*s == '|') { if (*(s + 1) == '|') { *s++ = 0; flag = 'o'; } } //parsecmd case 'a': debugf(&quot;we have &amp;&amp;\\n&quot;); if (need) { forkand = fork(); if (forkand == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); int need_ = (i == 0) ? 1 : 0; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 1, job_flag); }…… case 'o': debugf(&quot;we have ||\\n&quot;); if (need) { forkor = fork(); if (forkor == 0) { condition = 1; return argc; } else { int i = ipc_recv_cmd(NULL, 0, 0); //debugf(&quot;received return : %d\\n&quot;, i); //wait(forkand); int need_ = (i == 0) ? 0 : 1; condition = 0; return parsecmd(argv, rightpipe, need_, job_flag); } } else { return parsecmd(argv, rightpipe, 0, job_flag); }//runcmdif (argc == 0) { if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, 0, 0, 0); } return; }int child = spawn(argv[0], argv); close_all(); if (child &gt;= 0) { //debugf(&quot;Begin recv : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); if (job_flag) { syscall_env_save_job(child, tmp); } int r = ipc_recv_cmd(NULL, 0, 0); if (condition) { //debugf(&quot;Begin send : child %d, parent %d\\n&quot;, env-&gt;env_id, env-&gt;env_parent_id); ipc_send_cmd(env-&gt;env_parent_id, r, 0, 0); } 实现前后台任务管理后台任务运行所谓后台运行所需要的任务便是shell 不需要等待此命令执行完毕后再继续执行，即当存在 &amp;时，不进行 wait即可，下附代码： 12345678910111213141516//parsecmdcase '&amp;':; int child_ = fork(); if(child_) { // 父进程执行右边的命令 if(re_alloc == 0){ // 如果前一条命令出现了重定向，那么再重定向回来 dup(1, 0); } else if(re_alloc == 1) { dup(0, 1); } re_alloc = 0; return parsecmd(argv, rightpipe, 1, job_flag); } else { // 子进程执行左边的命令 re_alloc = 0; *job_flag = 1; return argc; } 后台任务管理考虑到如果在用户进程中维护一个任务列表，那么各进程间共享将会非常麻烦，于是进过慎重考虑，我决定在内核维护一个任务列表，通过系统调用来进行操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//env.hstruct Job { int status; // 0表示已经结束，1表示正在运行 int envid; char cmd[200]; };//env.cstatic struct Job jobs[2000];void env_save_job(u_int envid, char *cmd) { jobs[job_cnt].envid = envid; strcpy(jobs[job_cnt].cmd, cmd); jobs[job_cnt].status = 1; job_cnt++;}void env_job_done(u_int envid) { for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].envid == envid) { jobs[i].status = 0; break; } }}int env_get_job(int i) { if (i &gt; job_cnt) { return -1; } return jobs[i - 1].envid;}void env_jobs() { char str[20]; for (int i = 0; i &lt; job_cnt; i++) { if (jobs[i].status == 0) { strcpy(str, &quot;Done&quot;); } else { strcpy(str, &quot;Running&quot;); } printk(&quot;[%d] %-10s 0x%08x %s\\n&quot;, i + 1, str, jobs[i].envid, jobs[i].cmd); }}//syscall_all.cvoid sys_env_save_job(u_int envid, char *cmd) { env_save_job(envid, cmd);}void sys_env_job_done(u_int envid) { env_job_done(envid);}int sys_env_get_job(int i) { return env_get_job(i);}void sys_env_jobs() { env_jobs();}//sh.cvoid jobs() { syscall_env_jobs();}void kill(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { syscall_env_destroy(envid); syscall_env_job_done(envid); }}void fg(int job_id) { int envid = syscall_env_get_job(job_id); if (envid == -1) { printf(&quot;fg: job (%d) do not exist\\n&quot;, job_id); return; } else if (envs[ENVX(envid)].env_status == ENV_FREE) { printf(&quot;fg: (0x%08x) not running\\n&quot;, envid); } else { wait(envid); }} fg即 wait该任务完成。 同时，设置全局变量 job_flag，表示该任务是否为后台任务，需要进行管理，在 runcmd中完成内置指令的实现： 12345678910111213141516171819202122232425//sh.c runcmdelse if (strcmp(argv[0], &quot;jobs&quot;) == 0 &amp;&amp; argc == 1) { jobs(); close_all(); } else if (strcmp(argv[0], &quot;kill&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } kill(ret); close_all(); } else if (strcmp(argv[0], &quot;fg&quot;) == 0 &amp;&amp; argc == 2) { int ret = 0; char *s = argv[1]; while (*s) { ret = ret * 10 + (*s++ - '0'); } syscall_env_job_done(ret); fg(ret); close_all(); } 易错点同时，有几个需要注意的点： 123456789101112//libos.c libmainsyscall_env_job_done(env-&gt;env_id); 在指令结束前将任务设置为Done//syscall_all.cint sys_cgetc(void) { int ch; //while ((ch = scancharc()) == 0) { //} ch = scancharc(); //Shell-Challenge return ch;}删除了造成忙等的死循环 完结撒花！！！至此，挑战性任务的所有功能实现完毕 心路历程从开始到结束，总计135次commit(超过了OO两学期的commit总和)，终于是把Shell做完了，虽然是一个残废版的shell，感谢 yez，zyt，zx几位大佬，以及助教 shk不厌其烦地解答我的疑问，是你们拯救了我羸弱的OS，衷心感谢","link":"/2025/08/14/challenge-shell/"},{"title":"RooKie_Z P6 Verilog流水线CPU设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z的P6流水线CPU设计文档，在课上测试中本CPU取得了 满分💯的成绩。 总体设计概述本次要求实现的指令集为add, sub, and, or, slt, sltu, lui，addi, andi, ori，lb, lh, lw, sb, sh, sw，mult, multu, div, divu, mfhi, mflo, mthi, mtlo，beq, bne, jal, jr，可以看到，除了一部分位移指令和异常相关的指令，指令集内各类型指令均有覆盖。由于P5架构较为完备，大部分指令已于P5课下实现，故本次设计仅添加乘除单元MDU，并结合课程组所给tb对数据通路稍作修改，并未进行大的重构。 数据通路添加转发后的数据通路 关键模块介绍总体而言，在总体架构不作大的修改的前提下，修改了一部分控制信号，同时添加了流水线各级寄存器和虚拟的阻塞控制单元，对于每一级流水线都设计了相应的译码器。 命名规则 对于各模块文件，均采用对于元件的文件命名，均为流水线层级_元件英文简称，例如D_GRF.v，E_ALU.v等，实例化时命名为大写首字母小写英文名，例如Alu，Grf等 对于流水线寄存器文件命名为两边的流水线层级_REG，例如FD_REG.v，DE_REG.v，实例化时命名为大写英文层级，例如FD 每一级的控制信号和临时的wire均以本级的名称开头，如E_ALUOp，M_DMOp等 在流水线中参与流水的信息遵从以下约定（以D级为例） PC和Instr命名以流水线层级开头，如D_PC，D_Instr 寄存器地址分别为D_rs_addr，D_rt_addr，读出数据为D_rs，D_rt 转发得到的寄存器数据（直接读取也视为一种转发）记作D_FWD_rs_data，D_FWD_rt_data 即将写入的寄存器地址为E_A3，即将写入的数据记作E_WD，选择信号为E_WDSel F级（取指）PC（程序计数器） 信号名称 方向 功能描述 NPC[31:0] I 待写入PC的指令地址 clk I 时钟信号 reset I 同步复位信号 PC_WE I PC的写使能 PC O 当前指令地址 然后与mips_txt.v交互获得当前指令 123456789101112F_PC _pc( .clk(clk), .reset(reset), .PC_WE(PC_WE), .NPC(NPC), .PC(F_PC));assign i_inst_addr = F_PC;assign F_Instr = i_inst_rdata; FD_REG（F/D级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） F_PC I F级PC的指令地址 F_Instr[31:0] I 时钟信号 D_PC O D级PC的指令地址 D_Instr[31:0] O 32位的指令值 D级（译码） 本级需要处理来自E, M, W级的转发，其中W级为寄存器内部转发，另外两个分别是D_FWD_rs,D_FWD_rt，在CMP和NPC中需要用 本级的输入是来自F级的PC和Instr，输出是D_rs，D_rt，D_Ext_Out，D_PC和D_Instr，这些参与流水，还有输出到F级的NPC 本级元件较多，是最复杂的一级 D_GRF端口说明 信号名称 方向 功能描述 A1[4:0] I 5位地址输入信号，将其储存的数据读出到RD1 A2[4:0] I 5位地址输入信号，将其储存的数据读出到RD2 A3[4:0] I 5位地址输入信号，将其作为写入数据的目标寄存器 RD1[31:0] O 输出A1指定的寄存器中的32位数据 RD2[31:0] O 输出A2指定的寄存器中的32位数据 WD[31:0] I 32位数据输入信号 clk I 时钟信号 reset I 同步复位信号，将32个寄存器中的数据清零；1：复位；0：无效 这次删去了WE写使能信号，因为如果我们不写寄存器，可以把A3设为0，就相当于不写寄存器了 Ps ：这是我灵光一现想到的办法，受了P4课上访存指令的启发，如果有指令要在读出之后针对数据判断是否写入GRF，那么WE信号不仅要一直参与流水，还要用于控制每级的转发与阻塞，利用0寄存器的特点就可以规避这一切的麻烦！！！ 控制信号说明1. D_A3 直接给出待写入寄存器的地址，弃用了在P4中利用A3Sel进行选择的设计，这是因为P5采用分布式译码，每一级都需要A3的信息，因此在CTRL里面直接集成了 2. D_WDSel 控制信号值 功能 WDSel_DMout 选择写入寄存器的数据来自DM WDSel_ALUout 选择写入寄存器的数据来自ALU运算结果 WDSel_PC8 选择写入寄存器的数据为当前流水线层级中的PC+8 D_EXT将16位二进制数进行零扩展或符号扩展到32位 控制信号说明 控制信号值 功能 EXT_unsigned 零扩展 EXT_signed 符号扩展 D_CMP(分支比较)参考P3中CPU内BranchDefine子电路生成的CMP模块，来生成jump信号，判断分支是否跳转，link是否写入 目前实现了beq, bne, bgtz, bltz等指令 代码实现：1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1ps`include &quot;signal_def.v&quot;module CMP( input [31:0] rs, input [31:0] rt, input [2:0] CMPOp, output reg jump ); wire eq = (rs == rt); wire ne = !eq; wire ltz = ($signed(rs) &lt; 0); wire gtz = ($signed(rs) &gt; 0); wire eqz = (rs == 0); always @(*) begin case (CMPOp) `CMP_beq: begin jump = eq ? 1 : 0; end `CMP_bne: begin jump = ne ? 1 : 0; end `CMP_bltz: begin jump = ltz ? 1 : 0; end `CMP_bgtz: begin jump = gtz ? 1 : 0; end default: jump = 1'b0; endcase endendmodule 端口说明 端口名称 方向 功能描述 rs[31:0] I 转发后$rs寄存器的值 rt[31:0] I 转发后$rt寄存器的值 CMPOp[2:0] I 控制信号 jump O 指示分支是否跳转 D_NPC(次地址计算)有了CMP之后，NPC的功能也更加简洁，只需根据NPCOp和jump信号输出NPC信号的值就行 实际上NPC横跨了F级和D级两级，因为同时会输入F_PC和D_PC，前者正常跳转F_PC+4用，后者则用于流水PC值，后面转发PC+8的时候用 这次我们弃用了P4中直接输出PC+4的设计，转而让PC信号参与流水，在需要转发时计算PC+8 端口说明 端口名称 方向 功能描述 F_PC[31:0] I 32位输入当前F级地址 D_PC[31:0] I 32位输入当前D级地址 imm[31:0] I 32位立即数 jump I 指示b类型指令是否跳转 NPCOp[2:0] I 控制信号 RD1_rs[31:0] I $ra寄存器保存的32位地址 NPC[31:0] O 32位输出次地址 控制信号说明 控制信号值 功能 NPC_pc4 NPC = F_PC+4 NPC_b 执行beq等b类指令 NPC_jal 执行j，jal指令 NPC_jalr 执行jalr，jr指令 DE_REG（D/E级流水线寄存器） 输入D_PC,D_Instr,D_Ext_Out，此外上一级的$rs和$rt的值也要参与流水，即D_FWD_rs,D_FWD_rt需要参与流水，这是由于指令序列sw, nop, add的存在，sw在M级需要使用$rt的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的$rt值参与流水 输出E_PC,E_Instr,E_Ext_Out,E_rs,E_rt，ALU需要这些信息 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） D_PC[31:0] I D级PC的指令地址 D_Instr[31:0] I 32位的指令值 D_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 D_rs[31:0] I 32位的寄存器数据 D_rt[31:0] I 32位的寄存器数据 E_PC[31:0] O E级PC的指令地址 E_Instr[31:0] O 32位的指令值 E_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 E_rs[31:0] O 32位的寄存器数据 E_rt[31:0] O 32位的寄存器数据 E_ALU 相比于P4，ALU做了很大的变动，添加了ALUSrcA信号选择A运算数的来源，这是为了便于扩展sll和sllv类指令的原因取消了shamt信号，shamt信号从ALUSrcB中选择进入ALU中 端口说明 信号名称 方向 功能描述 A[31:0] I 32位输入运算数A B[31:0] I 32位输入运算数B ALUOp[4:0] I 控制信号 ALUOut[31:0] O 32位输出运算结果 控制信号说明1. ALUOp具体见代码，已实现绝大多数计算功能。 控制信号值 功能 ALU_add 执行加法运算 ALU_sub 执行减法运算 ALU_or 执行逻辑或运算 ALU_lui 执行lui指令 2. ALUSrcA 控制信号值 功能 SrcA_rt 对于sll和sllv等移位指令，选择$rt的值 SrcA_rs 对于其他大部分运算指令，采用 $rs的值 3. ALUSrcB 控制信号值 功能 SrcB_rt 选择处理完转发后$rt寄存器中的值进行运算 SrcB_imm 选择立即数进行运算 SrcB_shamt 使用{27'b0, E_ALUshamt}得到32为扩展移位数 SrcB_rs 考虑到sllv指令要求可变的位移数，这里可以选择{27'b0, E_FWD_rs_data[4:0]}，即$rs寄存器中的数据作为移位数 E_MDU（乘除单元）端口说明 信号名称 方向 功能描述 clk I 时钟信号 reset I 复位信号 MDUOp[2:0] I 控制信号 D1[31:0] I 32位输入运算数A D1[31:0] I 32位输入运算数B Start I 开始运算的指示信号 Busy O 是否处于运算过程中 HI[31:0] O 32位HI寄存器值结果 LO[31:0] O 32位LO寄存器值结果 控制信号说明1. MDUOp 控制信号值 功能 MDU_mult 乘法运算 MDU_div 除法运算 MDU_multu 无符号乘法运算 MDU_divu 无符号除法运算 MDU_mfhi mfhi指令 MDU_mflo mflo指令 MDU_mthi mthi指令，把D1的值赋给HI寄存器中 MDU_mtlo mtlo指令，把D1的值赋给LO寄存器中 EM_REG（E/M级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） E_PC[31:0] I E级PC的指令地址 E_Instr[31:0] I 32位的指令值 E_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 E_rt[31:0] I 32位的寄存器数据 E_ALU_Out[31:0] I 32位的ALU运算结果 E_MDU_Out[31:0] I 32位的MDU运算结果 M_PC[31:0] O M级PC的指令地址 M_Instr[31:0] O 32位的指令值 M_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 M_ALU_Out[31:0] O 32位的ALU运算结果 M_MDU_Out[31:0] O 32位的MDU运算结果 M_rt[31:0] O 32位的寄存器数据 M级（储存） 输入E_PC,E_Instr，此外上一级的ALUOut参与流水，即E_ALU_Out,E_Ext_Out需要参与流水，这是因为ALUOut可能是待写入或读取的内存地址，另外，上一级的rt值需要参与流水，因此还需要输入E_FWD_rt，这是因为sw指令会向内存中写入$rt的数据 输出M_PC,M_Instr,M_ALU_Out,M_DM_Out,M_MDU_Out M_DM（数据储存器） DM已经不需要自行实现，调用mips_txt.v中的接口即可 利用BE模块处理待写入数据，使其支持按半字、字节、字储存 利用DE模块处理DM返回的数据，使其可以按照不同要求存入寄存器 M_BE 信号名称 方向 功能描述 BEOp[1:0] 输入 控制信号 Addr[31:0] 输入 地址信息，用于处理半字、字节 rt_data[31:0] 输入 读取的寄存器数据，待处理 DMWr 输入 写使能 m_data_byteen[3:0] 输出 控制写入半字、字节的位置位置 m_data_wdata[31:0] 输出 待写入数据 M_DE 信号名称 方向 功能描述 DEOp[1:0] 输入 控制信号 Addr[31:0] 输入 地址信息，用于处理半字、字节 m_data_rdata[31:0] 输入 mips_txt.v返回的DM中的数据 DMout[31:0] 输出 处理之后的正确的读取数据 与接口进行交互12345678910111213141516171819202122232425// 与DM交互M_BE _be( .BEOp(M_BEOp), .Addr(M_ALU_Out), .WD(M_FWD_rt_data), .m_data_byteen(m_data_byteen), .m_data_wdata(m_data_wdata));assign m_inst_addr = M_PC;assign m_data_addr = M_ALU_OUt;wire [31:0] M_DM_Out;M_DE _de( .DEOp(M_DEOp), .Addr(M_ALU_Out), .m_data_rdata(m_data_rdata), .DMRD(M_DM_out));// 正确输出GRF读写信息assign w_grf_addr = W_A3;assign w_grf_wdata = W_WD;assign w_grf_we = W_GRFWE;assign w_inst_addr = W_PC; W级（回写）MW_REG（M/W级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） M_PC[31:0] I M级PC的指令地址 M_Instr[31:0] I 32位的指令值 M_DM_Out[31:0] I 从内存中读取的值 M_ALU_Out[31:0] I 32位的ALU运算结果 W_PC[31:0] O W级PC的指令地址 W_Instr[31:0] O 32位的指令值 W_DM_Out[31:0] O 从内存中读取的值 W_ALU_Out[31:0] O 32位的ALU运算结果 数据通路分析 指令 opcode funct NPCOp A3Sel WDSel EXTOp GRFWE ALUSRCB ALUOp DMWr DMOp add 000000 100000 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_add 0 X sub 000000 100010 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_sub 0 X ori 001101 X NPC_PC4 A3Sel_rt WDSel_ALUout EXT_unsigned 1 SrcB_imm ALU_or 0 X lw 100011 X NPC_PC4 A3Sel_rt WDSel_DMout EXT_signed 1 SrcB_imm ALU_add 0 DM_w sw 101011 X NPC_PC4 X WDSel_DMout EXT_signed 0 SrcB_imm ALU_add 1 DM_w beq 000100 X NPC_branch X X X 0 X X 0 X lui 001111 X NPC_PC4 A3Sel_rt WDSel_ALUout X 1 SrcB_imm ALU_lui 0 X jal 000011 X NPC_jal A3Sel_ra WDSel_PC8 X 1 X X 0 X jr 000000 001000 NPC_jalr X X X 0 X X X X 本CPU采用分布式译码，在每一级均设有译码器，解码出各级所需信息 冲突处理方法转发(Forwarding)对于转发，我们直接采用 AT 法 + 暴力转发，首先要搞明白转发到哪，转发什么。 对于每一个流水线层级，我们要能够确定当前这一级正在执行的指令要写什么数据，向哪里写，因此就要维护 GRFWD （解决转发啥）和 GRFA3 （解决转发到哪）这两个值，我们转发需要去关注的也就是这两个数据，这些信号都可以从 Control 里面译码读出来 简单来说就是，我们需要在每一级都知道本级需要从哪读数据，要写到哪，要写啥，现在不知道没事，总之在这条指令从流水线消失之前，我们肯定知道，并且可以根据这些再经过判断做转发。 在每一个需要用转发数据的地方，我们去比较要用的数据的 GPR 地址和前面正在维护的要写的 GRFA3 的地址，如果相同，那就意味着我们要写的寄存器已经被用了，但是这时前面获得的值显然是错误的，这时候直接转发过去就好了 这里还要考虑优先级的问题，流水线寄存器生成的WD越靠近这条指令，得到的数据就越新，我们就越倾向于优先使用这些数据 利用 AT 法，如果不阻塞就意味着一定能够在使用该寄存器的值之前获得正确的值，如果我们要用的时候，这个正确的值还没有算出来，那肯定不行，这时候我们就阻塞，如果能算出来，那么之前转发的错误的值不用去管它，最后总能得到一个正确的值去覆盖原先错误的值 如果我们还不知道要写的值是啥，那这个时候 GRFA3 就给正确的地址， GRFWD 就给 32'bz ，这时还不能做转发，但是如果写的阻塞模块正确，这个值就不可能被转发，因为这种情况如果出现就已经被阻塞在 D 级了 综合考量各种指令序列，我们得到了转发的旁路： D级需求: E-&gt;D(如序列jal-add), M-&gt;D(如序列jal-nop-add)(W-&gt;D隐藏于GRF的内部转发中); E级需求: M-&gt;E(如序列add-add), W-&gt;E(如序列add-nop-add) M级需求: W-&gt;M(如序列add-sw) 具体设计见前文图片 代码实现W to D: 12345// 寄存器内部转发 assign RD1 = (A1 == 5'b00000) ? 32'h0000_0000 : (A3 == A1 &amp;&amp; A1 != 5'b00000) ? WD : grf[A1]; assign RD2 = (A2 == 5'b00000) ? 32'h0000_0000 : (A3 == A2 &amp;&amp; A2 != 5'b00000) ? WD : grf[A2]; D级转发处理： 12345678910//D级写回数据 assign D_FWD_rs_data = (D_rs_addr == 0) ? 0 : (D_rs_addr == E_A3) ? E_WD : (D_rs_addr == M_A3) ? M_WD : D_rs; assign D_FWD_rt_data = (D_rt_addr == 0) ? 0 : (D_rt_addr == E_A3) ? E_WD : (D_rt_addr == M_A3) ? M_WD : D_rt; E级转发处理： 12345678910//转发 assign E_FWD_rs_data = (E_rs_addr == 0) ? 0 : (E_rs_addr == M_A3) ? M_WD : (E_rs_addr == W_A3) ? W_WD : E_rs; assign E_FWD_rt_data = (E_rt_addr == 0) ? 0 : (E_rt_addr == M_A3) ? M_WD : (E_rt_addr == W_A3) ? W_WD : E_rt; M级转发处理： 12345678//转发 assign M_FWD_rt_data = (M_rt_addr == 0) ? 0 : (M_rt_addr == W_A3) ? W_WD : M_rt; assign M_WD = (M_WDSel == `WDSel_PC8) ? M_PC + 8 : (M_WDSel == `WDSel_ALUout) ? M_ALU_Out : 32'bz; 阻塞(Stall)对于阻塞的处理，直接采用教程中的AT方法，设计一个 Stall 模块，专门负责处理阻塞时流水线寄存器的 flush 和 WE 信号就行 只在 D 级进行阻塞，阻塞控制器接受当前 D，E，M 级的指令输入，处理分析指令类别，算出当前D的Tuse，和E、M的Tnew，再进行相应的计算 代码实现：1234567891011121314151617181920212223242526//阻塞逻辑 wire E_stall_rs = ((E_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rs); wire E_stall_rt = ((E_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rt); wire M_stall_rs = ((M_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rs); wire M_stall_rt = ((M_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rt); assign Stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt; //清空当前指令信号，即插入nop wire FD_Flush, DE_Flush, EM_Flush, MW_Flush; assign FD_WE = !Stall; //不再进新指令 assign DE_WE = 1'b1; assign EM_WE = 1'b1; assign MW_WE = 1'b1; assign PC_WE = !Stall; assign FD_Flush = 1'b0; assign DE_Flush = Stall; //阻塞到D级，清空DE寄存器 assign EM_Flush = 1'b0; assign MW_Flush = 1'b0; 测试方案指令集：add, sub, and, or, slt, sltu, lui, addi, andi, ori, lb, lh, lw, sb, sh, sw, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, beq, bne, jal, jr 测试目标 单计算指令行为 单存取指令行为 单跳转指令行为 计算/存取指令数据冲突阻塞转发行为 跳转指令与计算/存取指令数据冲突阻塞转发行为 新增存储指令行为 单指令乘除指令行为以及 Busy 信号表现 乘除指令阻塞行为 计算指令/乘除指令的数据冲突阻塞转发行为 具体实现分为两部分 功能性测试采用课下提供的P6_L0_weak.txt测试每条指令的功能，对于未进行测试的指令，进行手动测试 首先在P5的测试工具基础上进行简单的修改，由于指令类型相似，因此仅在P5的基础上添加了mfhi,mflo,mthi,mtlo,div,divu,mult,multu指令然后进行大范围的随机生成测试 我的测试方法是利用随机生成数据进行大范围测试，对于随机数据无法覆盖的点，通过手动构造特殊样例进行测试 对于更多情况，手动构造数据处理 单条指令功能测试：ori测试：1234ori $t0, $t0, 1ori $t1, $t1, 0ori $t3, $t3, 0x7fffori $t4, $t3, 0xffff add测试：1234ori $t0, $t0, 2ori $t1, $t1, 0xffffadd $t2, $t0, $t0add $t3, $t1, $t1 sub测试：123456ori $t0, $t0, 2ori $t1, $t1, 0xffffsub $t2, $t0, $t0sub $t3, $t1, $t1sub $t4, $t1, $t0sub $t4, $t0, $t1 lui测试：12lui $t0, 0x7fffori $t0, $t0, 0x777f beq测试：1234567891011121314151617181920212223242526272829303132333435363738#三次跳转ori $t3, $t4, 1beq $3, $t0, Aori $t1, $t1, 0xffffA:beq $0, $t0, Blui $t1, 0xffffC:ori $t1, $t1, 1lui $t0, 1B:beq $t0, $0, Clui $t2, 0xffff//后跳beq $t3, $t0, Aori $t1, $t1, 0xffffori $t2, $t2, 0xffffA:lui $t1, 0xffff//不跳beq $3, $t0, AnopA:beq $0, $t0, BnopC:lui $t0, 1B:beq $t0, $0, Cnop//前跳beq $3, $t0, AnopB:lui $t0, 1A:beq $0, $t0, Bnop j，jal，jr测试：1234567891011121314151617jal Aori $s1, $s1, 0x1111add $ra, $ra, $t2ori $s1, $s1, 0x2222A:lui $t1, 200jal Aori $t0, $t0, 0x1111sub $t1, $t1, $t0ori $t2, $t2, 0x1111beq $t2, $t2, BnopA:jr $raadd $t3, $t0, $t0B: sw，lw测试：123456789ori $t0, $t0, 4 #t0 = 4add $t1, $t0, $t0 # t1 = 8sub $t2, $t0, $t1 # t2 = -4add $t3, $t2, $t2 #t3 = -8sub $t4, $t0, $t3 #t4 = csw $t4, 16($t4) # add = 1csw $t3, -4($t1) # add = 4lw $t5, 16($t4) lw $t6, -4($t1) 之后对于各种边界情况和转发阻塞情况，进行覆盖测试： 提供一组超强测样例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019.textinit_1:j init_44 lui $0, 58479init_2:j init_61 lui $26, 40699init_3:nopj init_26 ori $29, 12340init_4:j init_21 lui $9, 18793init_5:nopj init_9 ori $13, 19610init_6:j init_38 ori $28, 17819init_7:nopj init_37 ori $27, 17810init_8:j init_48 ori $14, 1324init_9:j init_8 lui $14, 20958init_10:j init_31 lui $4, 28505init_11:nopj init_13 ori $23, 24263init_12:j init_16 ori $12, 2525init_13:j init_62 lui $24, 49213init_14:j init_59 ori $6, 27235init_15:j init_52 ori $16, 28030init_16:j init_5 lui $13, 39021init_17:j init_23 lui $20, 45636init_18:nopj init_57 ori $7, 34738init_19:j init_56 lui $22, 48232init_20:j init_7 lui $27, 21269init_21:nopj init_24 ori $9, 60940init_22:j init_47 lui $19, 24579init_23:j init_53 ori $20, 23617init_24:j init_27 lui $10, 4700init_25:nopj init_60 ori $5, 25135init_26:j init_34 lui $30, 14559init_27:j init_29 ori $10, 45253init_28:j init_12 lui $12, 55820init_29:j init_36 lui $11, 49875init_30:j init_25 lui $5, 35220init_31:j init_30 ori $4, 7615init_32:j begin lui $31, 60984init_33:j init_43 ori $2, 18084init_34:j init_63 ori $30, 41019init_35:j init_15 lui $16, 54272init_36:nopj init_28 ori $11, 2111init_37:j init_6 lui $28, 33755init_38:j init_3 lui $29, 26291init_39:nopj init_2 ori $25, 48740init_40:j init_42 lui $1, 43965init_41:nopj init_19 ori $21, 27953init_42:nopj init_50 ori $1, 18337init_43:j init_54 lui $3, 36555init_44:j init_40 ori $0, 39840init_45:j init_22 ori $18, 28396init_46:j init_4 ori $8, 13173init_47:nopj init_17 ori $19, 60189init_48:j init_49 lui $15, 28446init_49:nopj init_35 ori $15, 43996init_50:j init_33 lui $2, 50534init_51:j init_45 lui $18, 47692init_52:j init_58 lui $17, 18098init_53:j init_41 lui $21, 23125init_54:nopj init_10 ori $3, 34935init_55:j init_39 lui $25, 37200init_56:j init_64 ori $22, 41245init_57:j init_46 lui $8, 16690init_58:nopj init_51 ori $17, 23659init_59:j init_18 lui $7, 16431init_60:j init_14 lui $6, 20586init_61:j init_20 ori $26, 21724init_62:j init_55 ori $24, 64211init_63:j init_32 lui $31, 32491init_64:j init_11 lui $23, 36591begin: ori $11, $11, 39941 sw $11, 0($0) ori $22, $22, 13378 nop sw $22, 4($0) addu $8, $31, $16 nop nop sw $8, 8($0) subu $20, $16, $6 sw $20, 12($0) addu $9, $15, $7 nop sw $9, 16($0) addu $19, $23, $27 nop nop sw $19, 20($0) subu $5, $1, $31 sw $5, 24($0) addu $22, $6, $26 nop sw $22, 28($0) addu $10, $4, $18 nop nop sw $10, 32($0) subu $19, $3, $0 sw $19, 36($0) subu $22, $24, $1 nop sw $22, 40($0) subu $19, $10, $14 nop nop sw $19, 44($0) subu $0, $19, $15 sw $0, 48($0) ori $21, $21, 728 nop sw $21, 52($0) subu $13, $29, $4 nop nop sw $13, 56($0) addu $11, $3, $1 sw $11, 60($0) addu $27, $19, $11 nop sw $27, 64($0) addu $27, $16, $28 nop nop sw $27, 68($0) ori $25, $25, 7272 sw $25, 72($0) ori $31, $31, 65375 nop sw $31, 76($0) ori $13, $13, 65318 nop nop sw $13, 80($0) ori $5, $5, 27677 sw $5, 84($0) ori $13, $13, 30209 nop sw $13, 88($0) subu $16, $28, $20 nop nop sw $16, 92($0) addu $6, $16, $21 sw $6, 96($0) subu $22, $11, $31 nop sw $22, 100($0) subu $25, $23, $19 nop nop sw $25, 104($0) ori $0, $0, 8927 sw $0, 108($0) ori $24, $24, 21563 nop sw $24, 112($0) addu $13, $16, $11 nop nop sw $13, 116($0) subu $14, $12, $27 sw $14, 120($0) addu $15, $24, $27 nop sw $15, 124($0) subu $20, $1, $24 nop nop sw $20, 128($0) subu $13, $28, $15 sw $13, 132($0) ori $28, $28, 56842 nop sw $28, 136($0) addu $31, $6, $23 nop nop sw $31, 140($0) ori $10, $10, 11112 sw $10, 144($0) addu $21, $23, $9 nop sw $21, 148($0) subu $22, $16, $29 nop nop sw $22, 152($0) addu $16, $1, $31 sw $16, 156($0) subu $12, $15, $28 nop sw $12, 160($0) addu $6, $10, $22 nop nop sw $6, 164($0) ori $12, $12, 14691 sw $12, 168($0) ori $16, $16, 34145 nop sw $16, 172($0) ori $11, $11, 18551 nop nop sw $11, 176($0) sw $sp, 180($0) sw $ra, 184($0) sw $at, 188($0) ori $sp, $0, 4060 ori $1, $0, 32 jal foo1 nop lui $1, 0 ori $1, 0 beq $1, $0, skip_manual1 nop j dl nopskip_manual1: lui $1, 10994 lui $2, 10994 beq $1, $2, skip_manual2 nop j dl nopskip_manual2: lui $3, 10995 nop nop beq $1, $3, dl addu $4, $4, $3 lui $1, 0x6183 addu $2, $2, $1 lui $5, 0x8124 addu $4, $5, $1 subu $6, $6, $5 jal skip_manual3 nop sw $0, 4($0)skip_manual3: sw $7, -0x3000($ra) lw $ra, -0x3000($ra) ori $ra, $0, 0 jal skip_manual4 nop sw $0, 8($0)skip_manual4: beq $ra, $0, dl nop ori $ra, $0, 0 jal skip_manual5 nop sw $ra, 12($0)skip_manual5: nop beq $ra, $0, dl nop ori $4, $0, 4 ori $5, $0, 5 ori $1, $0, 1 addu $4, $4, $1 nop nop beq $4, $5, skip_manual6 nop sw $0, 16($0)skip_manual6: ori $1, $0, 1 ori $2, $0, 2 ori $3, $0, 3 ori $4, $0, 4 ori $5, $0, 6 ori $6, $0, 5 subu $5, $5, $1 addu $6, $2, $1 beq $5, $6, dl nop jal skip_manual8 nopskip_manual8: addu $3, $3, $ra subu $4, $4, $ra jal foo nop jal fooo nop jal foooo nop jal fooooo nopsw $0, 192($0)sw $1, 196($0)sw $2, 200($0)sw $3, 204($0)sw $4, 208($0)sw $5, 212($0)sw $6, 216($0)sw $7, 220($0)sw $8, 224($0)sw $9, 228($0)sw $10, 232($0)sw $11, 236($0)sw $12, 240($0)sw $13, 244($0)sw $14, 248($0)sw $15, 252($0)sw $16, 256($0)sw $17, 260($0)sw $18, 264($0)sw $19, 268($0)sw $20, 272($0)sw $21, 276($0)sw $22, 280($0)sw $23, 284($0)sw $24, 288($0)sw $25, 292($0)sw $26, 296($0)sw $27, 300($0)sw $28, 304($0)sw $29, 308($0)sw $30, 312($0)sw $31, 316($0) lui $31, 63605 jal tag_0 nop ori $ra, $0, 2tag_0:sw $ra, 320($0) addu $14, $13, $7 jal tag_1 nop ori $ra, $0, 2tag_1:sw $ra, 324($0) lw $25, 12($0) jal tag_2 nop ori $ra, $0, 2tag_2:sw $ra, 328($0) lui $29, 14949 nop jal tag_3 nop ori $ra, $0, 2tag_3:sw $ra, 332($0) addu $10, $24, $1 nop jal tag_4 nop ori $ra, $0, 2tag_4:sw $ra, 336($0) lw $12, 164($0) nop jal tag_5 nop ori $ra, $0, 2tag_5:sw $ra, 340($0) lui $31, 58593 nop nop jal tag_6 nop ori $ra, $0, 2tag_6:sw $ra, 344($0) addu $1, $7, $12 nop nop jal tag_7 nop ori $ra, $0, 2tag_7:sw $ra, 348($0) lw $20, 256($0) nop nop jal tag_8 nop ori $ra, $0, 2tag_8:sw $ra, 352($0) lui $17, 19367 jal tag_9 nop ori $ra, $0, 2tag_9:sw $ra, 356($0) addu $8, $11, $11 jal tag_10 nop ori $ra, $0, 2tag_10:sw $ra, 360($0) lw $1, 132($0) jal tag_11 nop ori $ra, $0, 2tag_11:sw $ra, 364($0) lui $18, 56313 nop jal tag_12 nop ori $ra, $0, 2tag_12:sw $ra, 368($0) addu $23, $25, $24 nop jal tag_13 nop ori $ra, $0, 2tag_13:sw $ra, 372($0) lw $20, 368($0) nop jal tag_14 nop ori $ra, $0, 2tag_14:sw $ra, 376($0) lui $21, 22951 nop nop jal tag_15 nop ori $ra, $0, 2tag_15:sw $ra, 380($0) addu $8, $10, $1 nop nop jal tag_16 nop ori $ra, $0, 2tag_16:sw $ra, 384($0) lw $4, 88($0) nop nop jal tag_17 nop ori $ra, $0, 2tag_17:sw $ra, 388($0) ori $4, $0, 12 jal skip_manual7 nopskip_manual7: addu $ra, $ra, $4 jr $ra ori $4, $0, 8 addu $ra, $ra, $4 nop jr $ra nopdl:addu $ra, $0, $0 beq $0, $0, dl nopfoo: jr $ra ori $ra, $ra, 0xfffooo: ori $6, $ra, 0xa jr $ra nopfoooo: jr $ra ori $t8, $ra, 0xfffooooo: ori $t9, $ra, 0xa jr $ra nopfoo1: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 84 ori $s2, $0, 220 lw $t0, -40($s1) lw $t1, -88($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 11072 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 30986 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip1 nop jal foo2 subu $sp, $sp, $1skip1: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo2: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 152 ori $s2, $0, 54 lw $t1, 326($s2) lw $t0, 160($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 21109 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 60683 ori $a2, $a1, 0xf0 beq $a2, $a1, skip2 nop jal foo3 subu $sp, $sp, $1skip2: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo3: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 139 ori $s2, $0, 302 lw $t0, -35($s1) lw $t1, -34($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 29202 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 43269 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip3 nop jal foo13 subu $sp, $sp, $1skip3: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo4: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 297 ori $s2, $0, 96 lw $t1, 104($s2) lw $t0, -197($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 14171 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 18179 ori $a2, $a1, 0xf0 beq $a2, $a1, skip4 nop jal foo11 subu $sp, $sp, $1skip4: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo5: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 106 ori $s2, $0, 190 lw $t0, -26($s1) lw $t1, -82($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 49045 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 36619 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip5 nop jal foo1 subu $sp, $sp, $1skip5: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo6: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 345 ori $s2, $0, 52 lw $t1, -32($s2) lw $t0, 15($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 25874 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 45316 ori $a2, $a1, 0xf0 beq $a2, $a1, skip6 nop jal foo4 subu $sp, $sp, $1skip6: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo7: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 319 ori $s2, $0, 212 lw $t0, -167($s1) lw $t1, 120($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 44079 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 38407 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip7 nop jal foo10 subu $sp, $sp, $1skip7: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo8: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 366 ori $s2, $0, 244 lw $t1, -116($s2) lw $t0, -290($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 20552 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 22025 ori $a2, $a1, 0xf0 beq $a2, $a1, skip8 nop jal foo5 subu $sp, $sp, $1skip8: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo9: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 223 ori $s2, $0, 283 lw $t0, 13($s1) lw $t1, -27($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 28872 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 52993 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip9 nop jal foo15 subu $sp, $sp, $1skip9: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo10: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 228 ori $s2, $0, 255 lw $t1, -155($s2) lw $t0, 12($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 56866 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 21770 ori $a2, $a1, 0xf0 beq $a2, $a1, skip10 nop jal foo12 subu $sp, $sp, $1skip10: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo11: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 54 ori $s2, $0, 306 lw $t0, 278($s1) lw $t1, -238($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 34513 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 36103 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip11 nop jal foo8 subu $sp, $sp, $1skip11: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo12: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 248 ori $s2, $0, 72 lw $t1, 152($s2) lw $t0, 76($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 1104 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 24322 ori $a2, $a1, 0xf0 beq $a2, $a1, skip12 nop jal foo9 subu $sp, $sp, $1skip12: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo13: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 386 ori $s2, $0, 194 lw $t0, -82($s1) lw $t1, -142($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 18477 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 2816 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip13 nop jal foo7 subu $sp, $sp, $1skip13: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nopfoo14: sw $a0, 0($sp) sw $a1, 4($sp) sw $ra, 16($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 184 ori $s2, $0, 255 lw $t1, 13($s2) lw $t0, -88($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 26871 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 23821 ori $a2, $a1, 0xf0 beq $a2, $a1, skip14 nop jal foo16 subu $sp, $sp, $1skip14: lw $a3, 16($sp) jr $a3 addu $sp, $sp, $1foo15: sw $ra, 16($sp) sw $a0, 0($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 264 ori $s2, $0, 366 lw $t0, -212($s1) lw $t1, -2($s2) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 36680 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 1289 ori $a2, $a1, 0xf0 nop beq $a2, $a1, skip15 nop jal foo14 subu $sp, $sp, $1skip15: lw $a3, 16($sp) addu $sp, $sp, $1 jr $a3 nopfoo16: sw $a0, 0($sp) sw $ra, 16($sp) sw $a1, 4($sp) sw $a2, 8($sp) sw $a3, 12($sp) sw $t0, 20($sp) sw $t1, 24($sp) sw $t2, 28($sp) ori $s1, $0, 39 ori $s2, $0, 301 lw $t1, -17($s2) lw $t0, 317($s1) addu $a3, $t0, $t1 addu $a0, $a0, $t0 addu $a1, $a1, $t1 addu $t2, $a0, $a1 ori $a0, $t2, 706 addu $t2, $t2, $t2 addu $t2, $t2, $t2 ori $a1, $t2, 2561 ori $a2, $a1, 0xf0 beq $a2, $a1, skip16 nop jal foo6 subu $sp, $sp, $1skip16: lw $a3, 16($sp) addu $sp, $sp, $1 nop jr $a3 nop 对拍输出一致，或许对吧…… 思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？ 因为乘法除法需要在多个周期内执行，且只用HI，LO寄存器。所以用单独的HI,LO寄存器可以减少阻塞周期，提高效率，因为在乘除法部件工作时ALU模块还可以进行其他指令的工作，做到高效率执行。 并且HI，LO寄存器不属于通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于GRF中，内置在MDU中即可。 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。 乘法实现： 首先CPU会初始化三个通用寄存器用来存放被乘数，乘数，部分积。部分积寄存器初始化为0。判断乘数寄存器的低位是0|1，如果为0则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。同时部分积寄存器高位补0。如果为1则将部分积寄存器加上被乘数寄存器，再进行移位操作。当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。 还有另一种乘法的方式： 只需两个寄存器，A[31:0],B[63:0]，A初始化为被乘数，B初始化为乘数。每一次取B的最低位，为1则将A[31:0]+B[63:32] -&gt; B[63:32]，为0则不操作。每次将B &gt;&gt; 1，然后高位补0。 除法实现： 与乘法的操作基本相反，首先CPU会初始化三个寄存器,用来存放被除数，除数，部分商。余数(被除数与除数比较的结果)放到被除数的有效高位上。CPU做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先CPU会把被除数bit位与除数bit位对齐，然后再让对齐的被除数与除数比较(双符号位判断)。比如01-10=11(前面的1是符号位) 1-2=-1 计算机通过符号位和后一位的bit位来判断大于和小于，那么01-10=11 就说明01小于10，如果得数为01就代表大于，如果得数为00代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位(上商就是将商的最低位左移1位腾出商寄存器最低位上新的商)如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？ 对于stall信号，我增加了如果Start或者Busy信号有效，且D级时mfhi,mflo,mthi,mtlo时进行阻塞。 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑） 清晰性方面，按字节使能相当于onehot编码，1为写入，0为不写入，直观清楚。 统一性方面，对于各种处理内存指令只需设置好字节使能信号就可以控制数据的写入，不用通过取出该字的数据后再次拼接，对各种指令的操作表现的一样。 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？ 在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是同一节，因为读写所使用的地址都来自上一级的ALUresult，但是对应的字节不能保证一样，因为写入的和读出的有特定的模块控制。 在有sb，sh这种不是对于完整字节操作的指令来说， 按字节的读写效率会更高，如果按字处理，需要先从内存中读出该字节的所存储的数据，接下来根据需要进行拼接，最后组成完整的字节存入地址中，从内存中读出所消耗的组合逻辑延迟会降低效率，以字节读写就会消除这方面的影响。 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？ 主要采用了指令分类的方法，P6 完全沿用了 P5 的分类方法，新增的指令对应的特点都没有脱离这些分类，因此对于每条指令而言，只需译码后将其加入对应的分类，数据通路部分和 P5 完全类似，转发部分完全不用改，暂停部分只需添加一个因乘除块而导致的暂停。 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？ 冲突方面，主要是数据冒险和控制冒险，分别通过暂停转发以及比较前移+延迟槽解决。 具体而言： R类型Rd（写），后续指令Rs或Rt（读） 使用旁路转发，以add为例 123add $t0,$t1,$t2 add $a0,$t0,$t1 M到E级转发 add $t0,$t1,$t2 nop add $a0,$t0,$t1 M到D级转发 add $t0,$t1,$t2 nop nop add $a0,$t0,$t1 WB向D级转发 load指令Rt（写），隔条指令Rs或Rt（读） 123lw $t0,0($0) add $t0,$t0,$t0 stall一个周期，WB向E级转发 lw $t0,0($0) nop add $t0,$t0,$t0 WB向E级转发 lw $t0,0($0) nop nop add $t0,$t0,$t0 WB向D级转发 mult、multu、div、divu和mfhi、mflo、mthi、mtlo 如果E级的Busy或Start信号有效，如果是其他非乘除法相关指令，不会阻塞，使用ALU即可，如果是乘除法相关指令，如果是mfhi、mflo、mthi、mtlo，将它们阻塞在D级，直到乘除法结束；如果是mult、multu、div、divu，清空乘除法模块中的操作，将D级流水到E级。 12mult $t1,$t2 mflo $a0 会阻塞直到乘除法结束 mult $t1,$t2 div $a0,$a1 mult指令被div指令覆盖 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。 数据生成器采用了特殊策略：单组数据中除了 0 和 31 号寄存器外，至多涉及 3 个寄存器。一方面，这样产生的代码中，邻近的指令几乎全部都存在数据冒险，可以充分测试转发和暂停；另一方面，当测试数据的组数一定多，几乎涉及了每个寄存器，避免了只测试部分寄存器。此外，所有跳转指令都是特殊构造的，不会进入死循环的同时如果跳转出错可以输出中体现。 对于一些会产生异常的指令，为防止 MARS 报错，进行了一定的规避，比如除法不会去生成有关0号寄存器的除法，lw,sw保证是4的倍数等等。","link":"/2025/08/10/P6-CPU/"},{"title":"RooKie_Z P7 基于Verilog CPU的MIPS微体系设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是RooKie_Z的P7基于Verilog CPU的MIPS微体系设计文档，在课上测试中本CPU取得了 满分💯的成绩。 总体设计概述本次要求实现的指令集为add, sub, and, or, slt, sltu, lui，addi, andi, ori，lb, lh, lw, sb, sh, sw，mult, multu, div, divu, mfhi, mflo, mthi, mtlo，beq, bne, jal, jr，mfc0, mtc0, eret, syscall ，在P6的基础上新增加了mfc0, mtc0, eret, syscall。 CPU部分与P6相比添加了重要模块CP0协处理器，其余的端口定义和转发、阻塞规则与P6相同，详见附带的P6设计文档，在此处不再赘述 考虑到宏观PC的处理，我把CP0协处理器放置在了M级 数据通路添加转发后的数据通路 CP0插入流水线与异常码流水 做这样设计的原因如下： 我们称M级为宏观级. F, D, E级的指令”未曾执行”, M级指令“正在执行”, W级指令“执行完毕”. 相当于把流水线CPU封装为一个单周期 CPU. MIPS微系统整体设计 关键模块介绍CPU部分与P6相比添加了重要模块CP0协处理器，其余的端口定义和转发、阻塞规则与P6相同，详见附带的P6设计文档，在此处不再赘述。 CP0协处理器简单介绍协处理器 CP0，包含 3个 32 位寄存器，用于支持中断和异常。 端口定义 端口 输入/输出 位宽 描述 A1 I 5 指定 4 个寄存器中的一个，将其存储的数据读出到 RD A2 I 5 指定 4 个寄存器中的一个，作为写入的目标寄存器 CP0in I 32 写入寄存器的数据信号 PC I 32 目前传入的下一个 EPC 值 ExcCodeIn I 5 目前传入的下一个 ExcCode 值 isInDelaySlot I 32 目前传入的下一个 BD 值 HWInt I 6 外部硬件中断信号 WE I 1 写使能信号，高电平有效 EXLClr I 1 传入 eret 指令时将 SR 的 EXL 位置 0 ，高电平有效 clk I 1 时钟信号 reset I 1 同步复位信号 Req O 1 输出当前的中断请求 EPCOut O 32 输出当前 EPC 寄存器中的值 CP0out O 32 输出 A 指定的寄存器中的数据 功能定义 序号 功能名称 功能描述 1 同步复位 当时钟上升沿到来且同步复位信号有效时，将所有寄存器的值设置为 0x00000000。 2 读数据 读出 A1 地址对应寄存器中存储的数据到 RD；当 WE 有效时会将 WD 的值会实时反馈到对应的 RD，当 ERET 有效时会将 EXL 置 0，即内部转发。 3 写数据 当 WE 有效且时钟上升沿到来时，将 WD 的数据写入 A2 对应的寄存器中。 4 中断处理 根据各种传入信号和寄存器的值判断当前是否要进行中断，将结果输出到 IntReq。 异常处理流程： 将异常码ExcCode、是否处于延迟槽中的判断信号isInDelaySlot和当前PC（如果时取指地址异常则传递错误的PC值）一直跟着流水线到达M级直至提交至CP0，由CP0综合判断分析是否响应该异常 如果需要响应该异常，则CP0输出Req信号置为1，此时FD、DE、DM、MW寄存器响应Req信号，清空Instr，将PC值设为0x4180，然后输入F级的NPC也被置为0x4180，下一条指令从0x4180开始执行 当外设和系统外部输入中断信号时，CP0同样也会确认是否响应该中断，然后把Req置为1，执行相同的操作。 至于如何处理这个异常信号呢？Well，只需要跳到0x4180，接下来就是课程组的异常处理程序的工作了。 下面是P6的实验报告的部分内容： 所有的流水线寄存器均需要添加isInDelaySlot, Eret, Syscall, ExcCode的传递。 命名规则 对于各模块文件，均采用对于元件的文件命名，均为流水线层级_元件英文简称，例如D_GRF.v，E_ALU.v等，实例化时命名为大写首字母小写英文名，例如Alu，Grf等 对于流水线寄存器文件命名为两边的流水线层级_REG，例如FD_REG.v，DE_REG.v，实例化时命名为大写英文层级，例如FD 每一级的控制信号和临时的wire均以本级的名称开头，如E_ALUOp，M_DMOp等 在流水线中参与流水的信息遵从以下约定（以D级为例） PC和Instr命名以流水线层级开头，如D_PC，D_Instr 寄存器地址分别为D_rs_addr，D_rt_addr，读出数据为D_rs，D_rt 转发得到的寄存器数据（直接读取也视为一种转发）记作D_FWD_rs_data，D_FWD_rt_data 即将写入的寄存器地址为E_A3，即将写入的数据记作E_WD，选择信号为E_WDSel F级（取指）PC（程序计数器） 信号名称 方向 功能描述 NPC[31:0] I 待写入PC的指令地址 clk I 时钟信号 reset I 同步复位信号 PC_WE I PC的写使能 PC O 当前指令地址 然后与mips_txt.v交互获得当前指令 123456789101112F_PC _pc( .clk(clk), .reset(reset), .PC_WE(PC_WE), .NPC(NPC), .PC(F_PC));assign i_inst_addr = F_PC;assign F_Instr = i_inst_rdata; FD_REG（F/D级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） F_PC I F级PC的指令地址 F_Instr[31:0] I 时钟信号 D_PC O D级PC的指令地址 D_Instr[31:0] O 32位的指令值 D级（译码） 本级需要处理来自E, M, W级的转发，其中W级为寄存器内部转发，另外两个分别是D_FWD_rs,D_FWD_rt，在CMP和NPC中需要用 本级的输入是来自F级的PC和Instr，输出是D_rs，D_rt，D_Ext_Out，D_PC和D_Instr，这些参与流水，还有输出到F级的NPC 本级元件较多，是最复杂的一级 D_GRF端口说明 信号名称 方向 功能描述 A1[4:0] I 5位地址输入信号，将其储存的数据读出到RD1 A2[4:0] I 5位地址输入信号，将其储存的数据读出到RD2 A3[4:0] I 5位地址输入信号，将其作为写入数据的目标寄存器 RD1[31:0] O 输出A1指定的寄存器中的32位数据 RD2[31:0] O 输出A2指定的寄存器中的32位数据 WD[31:0] I 32位数据输入信号 clk I 时钟信号 reset I 同步复位信号，将32个寄存器中的数据清零；1：复位；0：无效 这次删去了WE写使能信号，因为如果我们不写寄存器，可以把A3设为0，就相当于不写寄存器了 Ps ：这是我灵光一现想到的办法，受了P4课上访存指令的启发，如果有指令要在读出之后针对数据判断是否写入GRF，那么WE信号不仅要一直参与流水，还要用于控制每级的转发与阻塞，利用0寄存器的特点就可以规避这一切的麻烦！！！ 控制信号说明1. D_A3 直接给出待写入寄存器的地址，弃用了在P4中利用A3Sel进行选择的设计，这是因为P5采用分布式译码，每一级都需要A3的信息，因此在CTRL里面直接集成了 2. D_WDSel 控制信号值 功能 WDSel_DMout 选择写入寄存器的数据来自DM WDSel_ALUout 选择写入寄存器的数据来自ALU运算结果 WDSel_PC8 选择写入寄存器的数据为当前流水线层级中的PC+8 D_EXT将16位二进制数进行零扩展或符号扩展到32位 控制信号说明 控制信号值 功能 EXT_unsigned 零扩展 EXT_signed 符号扩展 D_CMP(分支比较)参考P3中CPU内BranchDefine子电路生成的CMP模块，来生成jump信号，判断分支是否跳转，link是否写入 目前实现了beq, bne, bgtz, bltz等指令 代码实现：1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1ps`include &quot;signal_def.v&quot;module CMP( input [31:0] rs, input [31:0] rt, input [2:0] CMPOp, output reg jump ); wire eq = (rs == rt); wire ne = !eq; wire ltz = ($signed(rs) &lt; 0); wire gtz = ($signed(rs) &gt; 0); wire eqz = (rs == 0); always @(*) begin case (CMPOp) `CMP_beq: begin jump = eq ? 1 : 0; end `CMP_bne: begin jump = ne ? 1 : 0; end `CMP_bltz: begin jump = ltz ? 1 : 0; end `CMP_bgtz: begin jump = gtz ? 1 : 0; end default: jump = 1'b0; endcase endendmodule 端口说明 端口名称 方向 功能描述 rs[31:0] I 转发后$rs寄存器的值 rt[31:0] I 转发后$rt寄存器的值 CMPOp[2:0] I 控制信号 jump O 指示分支是否跳转 D_NPC(次地址计算)有了CMP之后，NPC的功能也更加简洁，只需根据NPCOp和jump信号输出NPC信号的值就行 实际上NPC横跨了F级和D级两级，因为同时会输入F_PC和D_PC，前者正常跳转F_PC+4用，后者则用于流水PC值，后面转发PC+8的时候用 这次我们弃用了P4中直接输出PC+4的设计，转而让PC信号参与流水，在需要转发时计算PC+8 端口说明 端口名称 方向 功能描述 F_PC[31:0] I 32位输入当前F级地址 D_PC[31:0] I 32位输入当前D级地址 imm[31:0] I 32位立即数 jump I 指示b类型指令是否跳转 NPCOp[2:0] I 控制信号 RD1_rs[31:0] I $ra寄存器保存的32位地址 NPC[31:0] O 32位输出次地址 控制信号说明 控制信号值 功能 NPC_pc4 NPC = F_PC+4 NPC_b 执行beq等b类指令 NPC_jal 执行j，jal指令 NPC_jalr 执行jalr，jr指令 DE_REG（D/E级流水线寄存器） 输入D_PC,D_Instr,D_Ext_Out，此外上一级的$rs和$rt的值也要参与流水，即D_FWD_rs,D_FWD_rt需要参与流水，这是由于指令序列sw, nop, add的存在，sw在M级需要使用$rt的数据，但是在E级不会再进行转发（因为在D级已经转发过了），因此需要让正确的$rt值参与流水 输出E_PC,E_Instr,E_Ext_Out,E_rs,E_rt，ALU需要这些信息 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） D_PC[31:0] I D级PC的指令地址 D_Instr[31:0] I 32位的指令值 D_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 D_rs[31:0] I 32位的寄存器数据 D_rt[31:0] I 32位的寄存器数据 E_PC[31:0] O E级PC的指令地址 E_Instr[31:0] O 32位的指令值 E_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 E_rs[31:0] O 32位的寄存器数据 E_rt[31:0] O 32位的寄存器数据 E_ALU 相比于P4，ALU做了很大的变动，添加了ALUSrcA信号选择A运算数的来源，这是为了便于扩展sll和sllv类指令的原因取消了shamt信号，shamt信号从ALUSrcB中选择进入ALU中 端口说明 信号名称 方向 功能描述 A[31:0] I 32位输入运算数A B[31:0] I 32位输入运算数B ALUOp[4:0] I 控制信号 ALUOut[31:0] O 32位输出运算结果 控制信号说明1. ALUOp具体见代码，已实现绝大多数计算功能。 控制信号值 功能 ALU_add 执行加法运算 ALU_sub 执行减法运算 ALU_or 执行逻辑或运算 ALU_lui 执行lui指令 2. ALUSrcA 控制信号值 功能 SrcA_rt 对于sll和sllv等移位指令，选择$rt的值 SrcA_rs 对于其他大部分运算指令，采用 $rs的值 3. ALUSrcB 控制信号值 功能 SrcB_rt 选择处理完转发后$rt寄存器中的值进行运算 SrcB_imm 选择立即数进行运算 SrcB_shamt 使用{27'b0, E_ALUshamt}得到32为扩展移位数 SrcB_rs 考虑到sllv指令要求可变的位移数，这里可以选择{27'b0, E_FWD_rs_data[4:0]}，即$rs寄存器中的数据作为移位数 E_MDU（乘除单元）端口说明 信号名称 方向 功能描述 clk I 时钟信号 reset I 复位信号 MDUOp[2:0] I 控制信号 D1[31:0] I 32位输入运算数A D1[31:0] I 32位输入运算数B Start I 开始运算的指示信号 Busy O 是否处于运算过程中 HI[31:0] O 32位HI寄存器值结果 LO[31:0] O 32位LO寄存器值结果 控制信号说明1. MDUOp 控制信号值 功能 MDU_mult 乘法运算 MDU_div 除法运算 MDU_multu 无符号乘法运算 MDU_divu 无符号除法运算 MDU_mfhi mfhi指令 MDU_mflo mflo指令 MDU_mthi mthi指令，把D1的值赋给HI寄存器中 MDU_mtlo mtlo指令，把D1的值赋给LO寄存器中 注意：当已经发生中断或异常时，Req信号置高，乘除槽停止工作，mult, multu, div, divu不再进行。 EM_REG（E/M级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） E_PC[31:0] I E级PC的指令地址 E_Instr[31:0] I 32位的指令值 E_Ext_Out[31:0] I 16位立即数经EXT扩展的结果 E_rt[31:0] I 32位的寄存器数据 E_ALU_Out[31:0] I 32位的ALU运算结果 E_MDU_Out[31:0] I 32位的MDU运算结果 M_PC[31:0] O M级PC的指令地址 M_Instr[31:0] O 32位的指令值 M_Ext_Out[31:0] O 16位立即数经EXT扩展的结果 M_ALU_Out[31:0] O 32位的ALU运算结果 M_MDU_Out[31:0] O 32位的MDU运算结果 M_rt[31:0] O 32位的寄存器数据 M级（储存） 输入E_PC,E_Instr，此外上一级的ALUOut参与流水，即E_ALU_Out,E_Ext_Out需要参与流水，这是因为ALUOut可能是待写入或读取的内存地址，另外，上一级的rt值需要参与流水，因此还需要输入E_FWD_rt，这是因为sw指令会向内存中写入$rt的数据 输出M_PC,M_Instr,M_ALU_Out,M_DM_Out,M_MDU_Out M_DM（数据储存器） DM已经不需要自行实现，调用mips_txt.v中的接口即可 利用BE模块处理待写入数据，使其支持按半字、字节、字储存 利用DE模块处理DM返回的数据，使其可以按照不同要求存入寄存器 M_BE 信号名称 方向 功能描述 BEOp[1:0] I 控制信号 Addr[31:0] I 地址信息，用于处理半字、字节 rt_data[31:0] I 读取的寄存器数据，待处理 DMWr I 写使能 m_data_byteen[3:0] O 控制写入半字、字节的位置位置 m_data_wdata[31:0] O 待写入数据 M_DE 信号名称 方向 功能描述 DEOp[1:0] I 控制信号 Addr[31:0] I 地址信息，用于处理半字、字节 m_data_rdata[31:0] I mips_txt.v返回的DM中的数据 DMout[31:0] O 处理之后的正确的读取数据 与接口进行交互12345678910111213141516171819202122232425// 与DM交互M_BE _be( .BEOp(M_BEOp), .Addr(M_ALU_Out), .WD(M_FWD_rt_data), .m_data_byteen(m_data_byteen), .m_data_wdata(m_data_wdata));assign m_inst_addr = M_PC;assign m_data_addr = M_ALU_OUt;wire [31:0] M_DM_Out;M_DE _de( .DEOp(M_DEOp), .Addr(M_ALU_Out), .m_data_rdata(m_data_rdata), .DMRD(M_DM_out));// 正确输出GRF读写信息assign w_grf_addr = W_A3;assign w_grf_wdata = W_WD;assign w_grf_we = W_GRFWE;assign w_inst_addr = W_PC; W级（回写）MW_REG（M/W级流水线寄存器） 信号名称 方向 功能描述 clk I 时钟信号 reset I 同步复位信号 flush I 寄存器刷新信号（阻塞时使用） M_PC[31:0] I M级PC的指令地址 M_Instr[31:0] I 32位的指令值 M_DM_Out[31:0] I 从内存中读取的值 M_ALU_Out[31:0] I 32位的ALU运算结果 W_PC[31:0] O W级PC的指令地址 W_Instr[31:0] O 32位的指令值 W_DM_Out[31:0] O 从内存中读取的值 W_ALU_Out[31:0] O 32位的ALU运算结果 数据通路分析 指令 opcode funct NPCOp A3Sel WDSel EXTOp GRFWE ALUSRCB ALUOp DMWr DMOp add 000000 100000 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_add 0 X sub 000000 100010 NPC_PC4 A3Sel_rd WDSel_ALUout X 1 SrcB_rt ALU_sub 0 X ori 001101 X NPC_PC4 A3Sel_rt WDSel_ALUout EXT_unsigned 1 SrcB_imm ALU_or 0 X lw 100011 X NPC_PC4 A3Sel_rt WDSel_DMout EXT_signed 1 SrcB_imm ALU_add 0 DM_w sw 101011 X NPC_PC4 X WDSel_DMout EXT_signed 0 SrcB_imm ALU_add 1 DM_w beq 000100 X NPC_branch X X X 0 X X 0 X lui 001111 X NPC_PC4 A3Sel_rt WDSel_ALUout X 1 SrcB_imm ALU_lui 0 X jal 000011 X NPC_jal A3Sel_ra WDSel_PC8 X 1 X X 0 X jr 000000 001000 NPC_jalr X X X 0 X X X X 本CPU采用分布式译码，在每一级均设有译码器，解码出各级所需信息 顶层模块设计Bridge系统桥是处理CPU与外设（两个计时器）之间信息交互的通道 CPU中store类指令需要储存的数据经过BE处理后会通过m_data_addr, m_data_byteen, m_data_wdata三个信号输出到桥中，桥会根据写使能m_data_byteen和地址m_data_addr来判断到底写的是内存还是外设，然后给出正确的写使能 load类指令则是全部把地址传递给每个外设和DE中，然后桥根据地址选择从应该反馈给CPU从哪里读出来的数据，然后DE再处理读出的数据，反馈正确的结果。 具体端口：123456789101112131415161718192021222324module Bridge( output [31:0] m_data_addr, input [31:0] m_data_rdata, output [31:0] m_data_wdata, output [3:0] m_data_byteen, input [31:0] m_data_addr_cpu, output [31:0] m_data_rdata_cpu, input [31:0] m_data_wdata_cpu, input [3:0] m_data_byteen_cpu, output [31:0] m_int_addr, output [3:0] m_int_byteen, input [31:0] TC0_Dout, output [31:0] TC0_Addr, output TC0_WE, output [31:0] TC0_Din, input [31:0] TC1_Dout, output [31:0] TC1_Addr, output TC1_WE, output [31:0] TC1_Din ); 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869`timescale 1ns / 1ps`include &quot;signal_def.v&quot;`define StartAddrDM 32'h0000_0000`define EndAddrDM 32'h0000_2fff`define StartAddrTC1 32'h0000_7f00`define EndAddrTC1 32'h0000_7f0b`define StartAddrTC2 32'h0000_7f10`define EndAddrTC2 32'h0000_7f1b`define StartAddrInt 32'h0000_7f20`define EndAddrInt 32'h0000_7f23module Bridge( output [31:0] m_data_addr, input [31:0] m_data_rdata, output [31:0] m_data_wdata, output [3:0] m_data_byteen, input [31:0] m_data_addr_cpu, output [31:0] m_data_rdata_cpu, input [31:0] m_data_wdata_cpu, input [3:0] m_data_byteen_cpu, output [31:0] m_int_addr, output [3:0] m_int_byteen, input [31:0] TC0_Dout, output [31:0] TC0_Addr, output TC0_WE, output [31:0] TC0_Din, input [31:0] TC1_Dout, output [31:0] TC1_Addr, output TC1_WE, output [31:0] TC1_Din ); assign m_data_addr = m_data_addr_cpu; assign m_data_wdata = m_data_wdata_cpu; assign TC0_Addr = m_data_addr_cpu; assign TC1_Addr = m_data_addr_cpu; assign TC0_Din = m_data_wdata_cpu; assign TC1_Din = m_data_wdata_cpu; assign TC0_WE = (m_data_addr_cpu &gt;= `StartAddrTC1 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC1) &amp;&amp; (| m_data_byteen_cpu); assign TC1_WE = (m_data_addr_cpu &gt;= `StartAddrTC2 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC2) &amp;&amp; (| m_data_byteen_cpu); assign m_data_rdata_cpu = (m_data_addr_cpu &gt;= `StartAddrTC1 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC1) ? TC0_Dout : (m_data_addr_cpu &gt;= `StartAddrTC2 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC2) ? TC1_Dout : m_data_rdata; assign m_data_byteen = ((m_data_addr_cpu &gt;= `StartAddrTC1 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC1) || (m_data_addr_cpu &gt;= `StartAddrTC2 &amp;&amp; m_data_addr_cpu &lt;= `EndAddrTC2)) ? 4'b0 : (m_data_addr_cpu &gt;= `StartAddrInt &amp;&amp; m_data_addr_cpu &lt;= `EndAddrInt &amp;&amp; (| m_data_byteen_cpu)) ? 4'b1 : m_data_byteen_cpu; assign m_int_addr = m_data_addr; assign m_int_byteen = m_data_byteen;endmodule Mips模块其实就是在mips.v中实例化CPU，Bridge，TC0和TC1四个模块相互交互。 冲突处理方法转发(Forwarding)对于转发，我们直接采用 AT 法 + 暴力转发，首先要搞明白转发到哪，转发什么。 对于每一个流水线层级，我们要能够确定当前这一级正在执行的指令要写什么数据，向哪里写，因此就要维护 GRFWD （解决转发啥）和 GRFA3 （解决转发到哪）这两个值，我们转发需要去关注的也就是这两个数据，这些信号都可以从 Control 里面译码读出来 简单来说就是，我们需要在每一级都知道本级需要从哪读数据，要写到哪，要写啥，现在不知道没事，总之在这条指令从流水线消失之前，我们肯定知道，并且可以根据这些再经过判断做转发。 在每一个需要用转发数据的地方，我们去比较要用的数据的 GPR 地址和前面正在维护的要写的 GRFA3 的地址，如果相同，那就意味着我们要写的寄存器已经被用了，但是这时前面获得的值显然是错误的，这时候直接转发过去就好了 这里还要考虑优先级的问题，流水线寄存器生成的WD越靠近这条指令，得到的数据就越新，我们就越倾向于优先使用这些数据 利用 AT 法，如果不阻塞就意味着一定能够在使用该寄存器的值之前获得正确的值，如果我们要用的时候，这个正确的值还没有算出来，那肯定不行，这时候我们就阻塞，如果能算出来，那么之前转发的错误的值不用去管它，最后总能得到一个正确的值去覆盖原先错误的值 如果我们还不知道要写的值是啥，那这个时候 GRFA3 就给正确的地址， GRFWD 就给 32'bz ，这时还不能做转发，但是如果写的阻塞模块正确，这个值就不可能被转发，因为这种情况如果出现就已经被阻塞在 D 级了 综合考量各种指令序列，我们得到了转发的旁路： D级需求: E-&gt;D(如序列jal-add), M-&gt;D(如序列jal-nop-add)(W-&gt;D隐藏于GRF的内部转发中); E级需求: M-&gt;E(如序列add-add), W-&gt;E(如序列add-nop-add) M级需求: W-&gt;M(如序列add-sw) 具体设计见前文图片 代码实现W to D: 12345// 寄存器内部转发 assign RD1 = (A1 == 5'b00000) ? 32'h0000_0000 : (A3 == A1 &amp;&amp; A1 != 5'b00000) ? WD : grf[A1]; assign RD2 = (A2 == 5'b00000) ? 32'h0000_0000 : (A3 == A2 &amp;&amp; A2 != 5'b00000) ? WD : grf[A2]; D级转发处理： 12345678910//D级写回数据 assign D_FWD_rs_data = (D_rs_addr == 0) ? 0 : (D_rs_addr == E_A3) ? E_WD : (D_rs_addr == M_A3) ? M_WD : D_rs; assign D_FWD_rt_data = (D_rt_addr == 0) ? 0 : (D_rt_addr == E_A3) ? E_WD : (D_rt_addr == M_A3) ? M_WD : D_rt; E级转发处理： 12345678910//转发 assign E_FWD_rs_data = (E_rs_addr == 0) ? 0 : (E_rs_addr == M_A3) ? M_WD : (E_rs_addr == W_A3) ? W_WD : E_rs; assign E_FWD_rt_data = (E_rt_addr == 0) ? 0 : (E_rt_addr == M_A3) ? M_WD : (E_rt_addr == W_A3) ? W_WD : E_rt; M级转发处理： 12345678//转发 assign M_FWD_rt_data = (M_rt_addr == 0) ? 0 : (M_rt_addr == W_A3) ? W_WD : M_rt; assign M_WD = (M_WDSel == `WDSel_PC8) ? M_PC + 8 : (M_WDSel == `WDSel_ALUout) ? M_ALU_Out : 32'bz; 阻塞(Stall)阻塞需要添加一行，关于eret的阻塞 1wire M_stall_eret = (D_eret) &amp;&amp; ((E_mtc0 &amp;&amp; E_rd_ad == 5'd14) || (M_mtc0 &amp;&amp; M_rd_ad == 5'd14)); 对于阻塞的处理，直接采用教程中的AT方法，设计一个 Stall 模块，专门负责处理阻塞时流水线寄存器的 flush 和 WE 信号就行 只在 D 级进行阻塞，阻塞控制器接受当前 D，E，M 级的指令输入，处理分析指令类别，算出当前D的Tuse，和E、M的Tnew，再进行相应的计算 代码实现：1234567891011121314151617181920212223242526//阻塞逻辑 wire E_stall_rs = ((E_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rs); wire E_stall_rt = ((E_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (E_Tnew &gt; D_Tuse_rt); wire M_stall_rs = ((M_A3 == D_rs_ad) &amp;&amp; (D_rs_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rs); wire M_stall_rt = ((M_A3 == D_rt_ad) &amp;&amp; (D_rt_ad != 0)) &amp;&amp; (M_Tnew &gt; D_Tuse_rt); assign Stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt; //清空当前指令信号，即插入nop wire FD_Flush, DE_Flush, EM_Flush, MW_Flush; assign FD_WE = !Stall; //不再进新指令 assign DE_WE = 1'b1; assign EM_WE = 1'b1; assign MW_WE = 1'b1; assign PC_WE = !Stall; assign FD_Flush = 1'b0; assign DE_Flush = Stall; //阻塞到D级，清空DE寄存器 assign EM_Flush = 1'b0; assign MW_Flush = 1'b0; 中断异常处理方法异常码 异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 PC 地址超过 0x3000 ~ 0x6ffc。 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 lh 取数地址未与 2 字节对齐。 lh, lb 取 Timer 寄存器的值。 load 型指令 计算地址时加法溢出。 load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 sh 存数地址未 2 字节对齐。 sh, sb 存 Timer 寄存器的值。 store 型指令 计算地址加法溢出。 store 型指令 向计时器的 Count 寄存器存值。 store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） - 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 地址范围 异常处理流程： 具体实现：将异常码ExcCode、是否处于延迟槽中的判断信号isInDelaySlot和当前PC（如果时取指地址异常则传递错误的PC值）一直跟着流水线到达M级直至提交至CP0，由CP0综合判断分析是否响应该异常 如果需要响应该异常，则CP0输出Req信号置为1，此时FD、DE、DM、MW寄存器响应Req信号，清空Instr，将PC值设为0x4180，然后输入F级的NPC也被置为0x4180，下一条指令从0x4180开始执行 当外设和系统外部输入中断信号时，CP0同样也会确认是否响应该中断，然后把Req置为1，执行相同的操作。 至于如何处理这个异常信号呢？Well，只需要跳到0x4180，接下来就是课程组的异常处理程序的工作了。 测试方案没有自动评测工具，通过对特定的异常和中断编写程序进行测试 异常测试取指异常123456789101112131415161718192021222324252627282930313233343536.textli $28, 0li $29, 0# jr PC mod 4 not 0la $1, label1la $2, label1addiu $1, $1, 1jr $1noplabel1:# jr PC &lt; 0x3000li $1, 0x2996la $2, label2jr $1noplabel2:# jr PC &gt; 0x4ffcli $1, 0x4fffla $2, label3jr $1noplabel3:end:j end.ktext 0x4180mfc0 $12, $12mfc0 $13, $13mfc0 $14, $14mtc0 $2, $14eretori $1, $0, 0 其它异常12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879.textli $28, 0li $29, 0lw $1, 1($0)lh $1, 1($0)lhu $1, 1($0)lh $1, 0x7f00($0)lhu $1, 0x7f04($0)lb $1, 0x7f08($0)lbu $1, 0x7f10($0)lb $1, 0x7f14($0)lb $1, 0x7f18($0)li $2, 0x7ffffffflw $1, 1($2)lh $1, 1($2)lhu $1, 1($2)lb $1, 1($2)lbu $1, 1($2)lw $1, 0x3000($0)lh $1, 0x4000($0)lhu $1, 0x6000($0)lb $1, 0x7f0c($0)lbu $1, 0x7f1c($0)sw $1, 1($0)sh $1, 1($0)sh $1, 0x7f00($0)sb $1, 0x7f04($0)sh $1, 0x7f08($0)sb $1, 0x7f10($0)sh $1, 0x7f14($0)sb $1, 0x7f18($0)li $2, 0x7fffffffsw $1, 1($2)sh $1, 1($2)sb $1, 1($2)sw $1, 0x7f08($0)sh $1, 0x7f08($0)sb $1, 0x7f08($0)sw $1, 0x7f18($0)sh $1, 0x7f18($0)sb $1, 0x7f18($0)sw $1, 0x3000($0)sh $1, 0x4000($0)sh $1, 0x6000($0)sb $1, 0x7f0c($0)sb $1, 0x7f1c($0)msub $1, $2li $1, 0x7fffffffadd $1, $1, $1addi $1, $1, 1li $1, 0x80000000add $1, $1, $1addi $1, $1, -1sub $1, $1, $2sub $1, $2, $1end:j end.ktext 0x4180mfc0 $12, $12mfc0 $13, $13mfc0 $14, $14addi $14, $14, 4mtc0 $14, $14eretori $1, $0, 0 计时器功能测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.textli $12, 0x0c01mtc0 $12, $12li $1, 500li $2, 9sw $1, 0x7f04($0)sw $2, 0x7f00($0)li $1, 1000sw $1, 0x7f14($0)sw $2, 0x7f10($0)lw $1, 0x7f00($0)lw $1, 0x7f04($0)lw $1, 0x7f10($0)lw $1, 0x7f14($0)li $1, 0li $2, 0for:ori $3, $3, 0beq $1, $0, fornopbeq $2, $0, fornoplw $1, 0x7f00($0)lw $1, 0x7f04($0)lw $1, 0x7f10($0)lw $1, 0x7f14($0)end:j end.ktext 0x4180mfc0 $13, $13li $15, 0x7fffffffand $13, $13, $15li $14, 1024beq $13, $14, timer0nopli $14, 2048beq $13, $14, timer1noperettimer0:li $1, 1sw $0, 0x7f00($0)erettimer1:li $2, 2sw $0, 0x7f10($0)eret 延迟槽异常测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177.textli $28, 0li $29, 0li $1, 1bne $0, $0, endlw $1, 1($0)li $1, 1bne $0, $0, endlh $1, 1($0)li $1, 1bne $0, $0, endlhu $1, 1($0)li $1, 1bne $0, $0, endlh $1, 0x7f00($0)li $1, 1bne $0, $0, endlhu $1, 0x7f04($0)li $1, 1bne $0, $0, endlb $1, 0x7f08($0)li $1, 1bne $0, $0, endlbu $1, 0x7f10($0)li $1, 1bne $0, $0, endlb $1, 0x7f14($0)li $1, 1bne $0, $0, endlb $1, 0x7f18($0)li $2, 0x7fffffffli $1, 1bne $0, $0, endlw $1, 1($2)li $1, 1bne $0, $0, endlh $1, 1($2)li $1, 1bne $0, $0, endlhu $1, 1($2)li $1, 1bne $0, $0, endlb $1, 1($2)li $1, 1bne $0, $0, endlbu $1, 1($2)li $1, 1bne $0, $0, endlw $1, 0x3000($0)li $1, 1bne $0, $0, endlh $1, 0x4000($0)li $1, 1bne $0, $0, endlhu $1, 0x6000($0)li $1, 1bne $0, $0, endlb $1, 0x7f0c($0)li $1, 1bne $0, $0, endlbu $1, 0x7f1c($0)li $1, 1bne $0, $0, endsw $1, 1($0)li $1, 1bne $0, $0, endsh $1, 1($0)li $1, 1bne $0, $0, endsh $1, 0x7f00($0)li $1, 1bne $0, $0, endsb $1, 0x7f04($0)li $1, 1bne $0, $0, endsh $1, 0x7f08($0)li $1, 1bne $0, $0, endsb $1, 0x7f10($0)li $1, 1bne $0, $0, endsh $1, 0x7f14($0)li $1, 1bne $0, $0, endsb $1, 0x7f18($0)li $2, 0x7fffffffli $1, 1bne $0, $0, endsw $1, 1($2)li $1, 1bne $0, $0, endsh $1, 1($2)li $1, 1bne $0, $0, endsb $1, 1($2)li $1, 1bne $0, $0, endsw $1, 0x7f08($0)li $1, 1bne $0, $0, endsh $1, 0x7f08($0)li $1, 1bne $0, $0, endsb $1, 0x7f08($0)li $1, 1bne $0, $0, endsw $1, 0x7f18($0)li $1, 1bne $0, $0, endsh $1, 0x7f18($0)li $1, 1bne $0, $0, endsb $1, 0x7f18($0)li $1, 1bne $0, $0, endsw $1, 0x3000($0)li $1, 1bne $0, $0, endsh $1, 0x4000($0)li $1, 1bne $0, $0, endsh $1, 0x6000($0)li $1, 1bne $0, $0, endsb $1, 0x7f0c($0)li $1, 1bne $0, $0, endsb $1, 0x7f1c($0)li $1, 1bne $0, $0, endmsub $1, $2li $1, 0x7fffffffli $11, 1bne $0, $0, endadd $1, $1, $1li $11, 1bne $0, $0, endaddi $1, $1, 1li $1, 0x80000000li $11, 1bne $0, $0, endadd $1, $1, $1li $11, 1bne $0, $0, endaddi $1, $1, -1li $11, 1bne $0, $0, endsub $1, $1, $2li $11, 1bne $0, $0, endsub $1, $2, $1end:j end.ktext 0x4180mfc0 $12, $12mfc0 $13, $13mfc0 $14, $14addi $14, $14, 8mtc0 $14, $14eretori $1, $0, 0 一组异常覆盖100%的数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116.text mtc0 $0, $12 ori $at, $0, 0xfffc #====OV===== lui $t0, 0x7fff lui $t1, 0xffff add $t2, $t0, $t1 sub $t2, $t0, $t1 sub $t2, $t1, $t0 lui $t1, 0x7fff add $t2, $t0, $t1 ori $t1, $t1, 0xffff addi $t2, $t1, 0xfffffff0 addi $t1, $t1, 0x0010 #=====SYSCALL===== syscall #=====ADEL===== lui $t1, 0x7fff jal label1 add $ra, $ra, $t1label1: jr $ra nop jal label2 addi $ra, $ra, 1label2: jr $ra nop ori $t0, $0, 0x7f00 ori $t2, $0, 0x7f20 sw $t0, 0($0) lw $t0, 0($0) lw $t0, 1($0) lw $t0, 2($0) lh $t0, 3($0) lh $t0, 0($t0) lh $t0, 2($t0) lb $t0, 0($t0) lb $t0, 3($t0)loop_timer1: lw $t1, 0($t0) addi $t0, $t0, 4 bne $t0, $t2, loop_timer1 nop ori $t0, $0, 0x3000 lw $t0, 0($t0) lui $t0, 0x7fff ori $t0, $t0, 0xffff lw $t0, 1($t0) lw $t0, -4($0) #=====ADES===== sw $0, 1($0) sw $0, 2($0) sh $0, 3($0) sw $0, 4($0) sh $0, 6($0) sb $0, 7($0) ori $t0, $0, 0x7f00 sh $0, 0($t0) sh $0, 2($t0) sb $0, 0($t0) sb $0, 3($t0) ori $t1, $0, 0x7f30loop_timer2: sw $0, 0($t0) addi $t0, $t0, 4 bne $t0, $t1, loop_timer2 nop ori $t0, $0, 0x3000 sw $0, 0($t0) lui $t0, 0x7fff ori $t0, $t0, 0xffff sw $0, 1($t0) sw $0, -1($0) #=====ALTOGETHER===== lui $t0, 0x7fff ori $t1, $t0, 0xffff sw $0, 0($t0) addi $t1, $t1, 1 syscall sw $0, 0($t0) addi $t1, $t1, 1 nop sw $0, 0($t0) addi $t1, $t1, 0 syscall sw $0, 0($0) addi $t1, $t1, 1 syscall lui $t0, 0x8000 addi $t1, $t1, 1 beq $t0, $t1, end nopend: beq $0, $0, end nop.ktext 0x4180_main_handler: mfc0 $k0, $13 mfc0 $k0, $14 and $k0, $k0, $at addi $k0, $k0, 4 mtc0 $k0, $14 sb $0, 0x7f20($0) eret 中断测试其实没有什么特殊的测试方案，就是把中断的PC值取在各个地方，取在各种指令之前或之后，进行测试就行，看是否断在相应的地方。 提供一组测试方案 说明123456789- 0x3010 宏观pc对应写GRF指令时，给予外部中断- 0x3014 宏观pc对应store类指令时，给予外部中断- 0x301c 宏观pc对应mtc0指令时，给予外部中断- 0x3020 宏观pc对应load类指令时，给予外部中断- 0x3028 在stall状态下，给予外部中断- 0x3034 宏观pc对应跳转指令，给予外部中断- 0x3038 宏观pc对应延迟槽指令且此时存在异常时，给予外部中断- 0x303c D级是跳转指令时，给予外部中断- 0x307c stall刷出很多空泡，给予外部中断 样例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677.text lui $1,0xffffori $1,$1,0xfc01mtc0 $1,$12lui $2,0xffff#int-grfori $2,$2,0x1234#int-storesw $2,0($0)ori $3,$0,0xfc01#int-mtc0mtc0 $3,$12#int-loadlw $4,0($0)lw $5,0($0)#int-stalladd $6,$5,$4lui $7,0x7ffflui $8,0x7fff#int-beqbeq $7,$8,label1#int&amp;exc-BDadd $9,$7,$8#int-D beqaddi $10,$0,0x0001addi $11,$0,0x0002beq $7,$8,label1noplabel1:mult $7,$8syscalldiv $7,$8syscallmthi $7syscallmtlo $8syscallmfhi $10mflo $11mult $7,$8beq $7,$8,label2#int-many nopmflo $12addi $12,$0,0x0001addi $12,$0,0x0002label2:addi $13,$0,0x0001end:beq $0,$0,endnop.ktext 0x4180main_handler:mfc0 $26,$13mfc0 $27,$14ori $27,$0,0x007cand $26,$27,$26beq $0,$26,interruptnopmfc0 $26,$14add $26,$26,4mtc0 $26,$14beq $0,$0,returnnopinterrupt:ori $27,$0,0x2137sw $27,0x7f20($0)beq $0,$0,returnnopreturn:eret 相应tb：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171 `timescale 1ns/1ps module mips_txt; reg clk; reg reset; reg interrupt; wire [31:0] macroscopic_pc; wire [31:0] i_inst_addr; wire [31:0] i_inst_rdata; wire [31:0] m_data_addr; wire [31:0] m_data_rdata; wire [31:0] m_data_wdata; wire [3 :0] m_data_byteen; wire [31:0] m_int_addr; wire [3 :0] m_int_byteen; wire [31:0] m_inst_addr; wire w_grf_we; wire [4 :0] w_grf_addr; wire [31:0] w_grf_wdata; wire [31:0] w_inst_addr; mips uut( .clk(clk), .reset(reset), .interrupt(interrupt), .macroscopic_pc(macroscopic_pc), .i_inst_addr(i_inst_addr), .i_inst_rdata(i_inst_rdata), .m_data_addr(m_data_addr), .m_data_rdata(m_data_rdata), .m_data_wdata(m_data_wdata), .m_data_byteen(m_data_byteen), .m_int_addr(m_int_addr), .m_int_byteen(m_int_byteen), .m_inst_addr(m_inst_addr), .w_grf_we(w_grf_we), .w_grf_addr(w_grf_addr), .w_grf_wdata(w_grf_wdata), .w_inst_addr(w_inst_addr) ); initial begin clk &lt;= 0; reset &lt;= 1; interrupt &lt;= 0; #20 reset &lt;= 0; end integer i; reg [31:0] fixed_addr; reg [31:0] fixed_wdata; reg [31:0] data[0:4095]; reg [31:0] inst[0:5119]; // ----------- For Instructions ----------- assign m_data_rdata = data[(m_data_addr &gt;&gt; 2) % 5120]; assign i_inst_rdata = inst[((i_inst_addr - 32'h3000) &gt;&gt; 2) % 5120]; initial begin $readmemh(&quot;code.txt&quot;, inst); $readmemh(&quot;handler.txt&quot;,inst,32'h1180 &gt;&gt; 2); for (i = 0; i &lt; 5120; i = i + 1) data[i] &lt;= 0; end always @(*) begin fixed_wdata = data[(m_data_addr &gt;&gt; 2) &amp; 4095]; fixed_addr = m_data_addr &amp; 32'hfffffffc; if (m_data_byteen[3]) fixed_wdata[31:24] = m_data_wdata[31:24]; if (m_data_byteen[2]) fixed_wdata[23:16] = m_data_wdata[23:16]; if (m_data_byteen[1]) fixed_wdata[15: 8] = m_data_wdata[15: 8]; if (m_data_byteen[0]) fixed_wdata[7 : 0] = m_data_wdata[7 : 0]; end always @(posedge clk) begin if (~reset) begin if (w_grf_we &amp;&amp; (w_grf_addr != 0)) begin $display(&quot;%d@%h: $%d &lt;= %h&quot;,$time,w_inst_addr, w_grf_addr, w_grf_wdata); end end end always @(posedge clk) begin if (reset) for (i = 0; i &lt; 4096; i = i + 1) data[i] &lt;= 0; else if (|m_data_byteen &amp;&amp; fixed_addr &gt;&gt; 2 &lt; 4096) begin data[fixed_addr &gt;&gt; 2] &lt;= fixed_wdata; $display(&quot;%d@%h: *%h &lt;= %h&quot;,$time,m_inst_addr, fixed_addr, fixed_wdata); end end // ----------- For Interrupt ----------- wire [31:0] fixed_macroscopic_pc; assign fixed_macroscopic_pc = macroscopic_pc &amp; 32'hfffffffc;//字对齐 always @(negedge clk) begin if (reset) begin interrupt = 0; end else begin if (interrupt) begin if ((|m_int_byteen) &amp;&amp; (m_int_addr &amp; 32'hfffffffc) == 32'h7f20) begin interrupt = 0; end end end end reg [31:0] interrupt_cnt = 100;//可以修改外部中断总数 always @(negedge clk) begin if (~reset) begin if (interrupt_cnt == 32'd100 &amp;&amp; fixed_macroscopic_pc == 32'h3010) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd99 &amp;&amp; fixed_macroscopic_pc == 32'h3014) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd98 &amp;&amp; fixed_macroscopic_pc == 32'h301c) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd97 &amp;&amp; fixed_macroscopic_pc == 32'h3020) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd96 &amp;&amp; fixed_macroscopic_pc == 32'h3028) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd95 &amp;&amp; fixed_macroscopic_pc == 32'h3034) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd94 &amp;&amp; fixed_macroscopic_pc == 32'h3038) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd93 &amp;&amp; fixed_macroscopic_pc == 32'h303c) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end if (interrupt_cnt == 32'd92 &amp;&amp; fixed_macroscopic_pc == 32'h307c) begin interrupt &lt;= 1; interrupt_cnt &lt;= interrupt_cnt - 1; end end end always #2 clk &lt;= ~clk;endmodule 思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？ 键盘和鼠标本质上都是输入设备，其自身的内部有一些微处理器来控制自己与主机之间的信息交互。而在CPU看来，外部信号会经过很多层级传入到内部，而内部的信息也会经过很多层级传出至外部。这些层级由外至内大致可以分为主存-&gt;cache(-&gt;bridge)-&gt;CPU。 每个设备都需要驱动程序的，只不过驱动程序有的在电脑系统内，有的却需另外按装，比如：无线键鼠套装，驱动程序已经在USB头上，我们叫它免驱设备。如果没有这些指定驱动程序的话，电脑是无法识别内容的。 请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法） 因为中断异常处理程序是在程序所有程序运行前就已经写好了，设置固定的地址，就能保证异常或者中断来临的时候呢能够跳转到正确的地址进行处理。 如果由用户提供中断异常处理程序的话，它跳转的地址也是计算出来的，但是如果在算跳转地址的时候出现了错误，那就无法正常进行异常处理行为。 为何与外设通信需要 Bridge？ 因为我们的CPU可能会与许多外设相连，如果为每一个外设提供一套数据和地址，就会让CPU变得非常复杂。这里Bridge充当一个交互的角色，将多个外设与CPU连起来，这样我们的CPU只用提供一个接口即可。 添加外设时，外设也只需要体现在入口地址的不同而不需要改变CPU的内部结构，让CPU访问外设只需通过地址，这样也是体现了”高内聚，低耦合”的原则。 请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。 两种中断，模式0为定时中断，模式1为周期性中断。区别在于倒计时达到0之后的状态。 区别： 两种中断，模式0为定时中断，模式1为周期性中断。区别在于倒计时达到0之后的状态。 计数器模式 0： 当计数器倒计数为 0 后，计数器停止计数，Ctrl 寄存器的计数使能自动变为 0，并且中断信号始终保持有效，直到屏蔽中断或重新开始计数。该模式通常用于定时中断。 状态转移图如下： 计数器模式 1： 当计数器倒计时为 0 后，会自动的重新读取 preset 寄存器的值，然后重新开始倒计数。在这种模式下，中断信号只会产生一个周期。该模式通常用于产生周期性中断。 状态转移图如下： 倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？ 可能会出现宏观PC和EPC的错误，而且延迟槽标记信号也会出现问题。 如果是中断或者异常指令造成的流水线清空，应该保持原有的PC值，以保证宏观PC的正确。 如果是阻塞造成的DE级流水线清除，应该要保持原有的PC并且保持原有的BD标志信号。 为什么 jalr 指令为什么不能写成 jalr $31, $31？ 具体实现上： 因为jalr $31,$31，是要同时读写$31，而GRF具有内部转发，也就是在其他i1与i2同时读写一个寄存器时，会直接把写的数据加载到读端口，如此jalr就读出的是PC+4，并没有实现原先的跳转功能。 规范上： 这种操作具有二义性，不知道先跳转还是先链接 指令集要求。寄存器说明符 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。","link":"/2025/08/10/P7-CPU/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/08/09/hello-world/"},{"title":"学海伴航——教辅平台系统设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面这是学海伴航——教辅平台的系统设计文档，源于大三上数据库课程大作业。本项目由RooKie_Z,Galaxy_Jew, LPF三人一同完成，在最终的展示后取得了 满分💯的成绩。 👉 系统实现报告 一、需求分析1.1 需求描述1.1.1 背景调研通过积极调研新生需求，了解学院教学需要，同时与辅导员老师沟通，我们发现传统的微信QQ群学习小组的答疑教辅模式已不再高效。建立功能更丰富，交互更便捷，上手更简单，连接更紧密的教辅平台需求迫在眉睫。 以下为传源书院计划开发的微信答疑小程序： 1.1.2 用户调研对于学生与辅导师的诉求，我们通过联系传源书院的辅导员，获取了他们问卷调查的数据，初步总结需求如下： 学生 辅导师 管理人员 提出问题，并得到及时回答 避免过度同质化的提问 了解同学们的学习情况 获取各科目资料集合，进行自学自测 避免答疑活动对课下生活的打扰 了解同学们的学习诉求 看见其他同学的答疑内容 便于组织模拟考试并加以批改 统计辅导师的工作量 开展模拟考试 发布公告 1.1.3 需求总结对于需要获取学业帮扶的学生他们需要一款产品，能够： 提出课业上的问题，并获得及时准确的回答。 看见其它同学的答疑内容。 获取各科习题资料，包括往年资料。 有条理地获取自己的学习做题记录。 参与模拟测试，并及时获取答题情况。 对于辅导师他们需要一款产品，能够： 避免对日常生活的过度打扰。 避免过度同质化的提问。 获得同学们对回答的反馈。 及时更新题库 发布模拟考试并加以批改 对于学业支持中心/导员他们需要一款产品，能够： 直观了解辅导师工作情况，方便监督。 自动统计辅导师的工作量并换算为志愿时长。 开展模拟考试等集体学习活动，并发布公告。 1.1.4 项目优势通过上述需求分析，可见，学海伴航具有庞大的需求空间，光明的应用前景，具有开发的价值，通过我们的平台，三类目标用户可以在多种场景下获得利好： 从学生的角度 共享学习资料：平台统一整合学习资料，方便同学查阅下载。 共享问题与解答：所有问题均公开共享，同学可以搜索自己困惑的相似的问题，从其他人的已解决问题和回答得到启发。 自主学习：平台组织统一模拟测试，学生获取模拟情况，指导自主学习。 激励学习：可视化自己解决的问题数量，同时在主页获取推荐题目，学习更有动力，更有积极性。 减少微信私聊数量：学生反馈群聊数量过多的问题，一个线下答疑活动需要建立很多的群聊，大群、小组群、互助群，影响日常的消息接收，带来不必要的麻烦。通过平台进行信息整合，交流与信息统一化。 从小导师角度 辅导积极性更高：基于回答问题，上传题目，组织考试，批改试题的次数分配志愿时长，奖励机制更加公平合理，增强辅导师的解答积极性。 在平台统一答疑，避免占用辅导师过多课下私人时间。 从学院组织者角度 活动推进：可视化活动活跃度情况，学生参与度情况，有效推进活动开展。 氛围营造：通过平台统一管理活动，定期发布相关学习公告，营造良好的学习氛围。 1.2 数据流图1.2.1 总体数据流图 1.2.2 用户管理部分数据流图 1.2.3 消息公告部分数据流图 1.2.4 题目题库部分数据流图 1.2.5 模拟考试部分数据流图 1.2.6 讨论区部分数据流图 1.2.7 用户主页部分数据流图 1.3 数据元素表1.3.1 用户管理部分用户表 字段名称 数据类型 可否为空 说明 id int NO 用户id，主键 user_id varchar NO 学号 pass_word varchar NO 密码 mail varchar NO 邮箱 college varchar NO 学院 entryYear varchar NO 入学年份 avatar varchar NO 头像 user_role varchar NO 用户身份（学生/辅导师） 1.3.2 消息部分消息表 字段名称 数据类型 可否为空 说明 id int NO 消息id，主键 sender int NO 外键，发送消息学生编号 sender_avatar varchar NO 发送者头像 sent_at date NO 发送时间 receiver int NO 外键，接收消息学生编号 content varchar NO 消息内容 is_read boolean NO 是否已阅 1.3.3 公告部分公告表 字段名称 数据类型 可否为空 说明 id int NO 公告id，主键 sender int NO 外键，发布者编号 sender_avatar varchar NO 发布者头像 sent_at date NO 发布时间 last_updated date NO 时间 content varchar NO 公告内容 title varchar NO 公告标题 1.3.4 题目部分题目表 字段名称 数据类型 可否为空 说明 id int NO 题目id，主键 type varchar NO 题目类型 content varchar NO 题目内容 subject varchar NO 题目所属科目 added_at date NO 上传时间 source varchar NO 题目来源 tags json YES 题目标签 difficulty int NO 题目难度 added_by int NO 题目添加者id question_banks json YES 外键，题目所属题库 option_count int NO 题目选项数量 题库表 字段名称 数据类型 可否为空 说明 id int NO 题库id，主键 subject varchar NO 题库所属科目 estimated_time date NO 题库预计完成时间 created_at date NO 题库创建时间 creator int NO 题库创建者id description varchar NO 题库描述 question_count int NO 题库题目数量 题目讨论区表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 question int NO 题目id，外键 created_at date NO 题目创建时间 creator int NO 题目创建者id content varchar NO 题目讨论区内容 题目讨论区讨论表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 question int NO 题目id，外键 created_at date NO 题目创建时间 creator int NO 题目创建者id content varchar NO 题目讨论区内容 做题记录表 字段名称 数据类型 可否为空 说明 id int NO 做题记录id，主键 user int NO 做题者用户id，外键 question int NO 题目id，外键 attempted_at date NO 做题时间 is_correct boolean NO 是否做对本题 1.3.5 模拟考试部分考试表 字段名称 数据类型 可否为空 说明 id int NO 模拟考试id，主键 title varchar NO 模拟考试标题 subject varchar NO 题目所属科目 description varchar NO 模拟考试描述 created_at date NO 考试创建时间 start_time date NO 考试开始时间 duration int NO 考试持续时间 end_time date NO 考试结束时间 created_by int NO 考试创建者id，外键 students json YES 外键，模拟考试所有报名学生 questions json NO 外键，模拟考试所有题目 模拟考试作答表 字段名称 数据类型 可否为空 说明 id int NO 做题记录id，主键 exam int NO 作答所属考试id，外键 user int NO 做答用户id，外键 question int NO 作答题目id，外键 submitted_answer varchar NO 最后做答答案 submitted_at date NO 最后做答时间 is_correct boolean NO 是否做对本题 1.3.6 讨论区部分讨论帖表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 title varchar NO 讨论帖标题 content varchar NO 讨论帖内容 publisher int NO 发帖者id，外键 avatar varchar NO 发帖者头像 publish_time date NO 发帖时间 last_updated date NO 讨论帖最后更新时间 tag varchar NO 讨论帖标签 subscribers json YES 订阅者id集合 likes json YES 喜爱者id集合 is_marked boolean NO 帖子是否为精华帖 帖子回复表 字段名称 数据类型 可否为空 说明 id int NO 题目讨论区id，主键 discussion int NO 回帖所属讨论帖id，外键 content varchar NO 回复内容 publisher int NO 回帖者id，外键 avatar varchar NO 回帖者头像 publish_time date NO 回帖时间 last_updated date NO 回帖最后更新时间 likes json YES 回帖喜爱者id集合 ⼆、数据库概念模式设计2.1 系统初步 ER 图2.1.1 实体 ER 图 2.1.2 关系 ER 图 2.2 系统基本 ER 图 [!IMPORTANT]由于实体属性过于复杂，将属性画入ER图内将大大影响图的美观性，故下面ER图内将不包含属性，只指示关系 三、数据库逻辑模式设计与优化3.1 数据库关系模式 [!IMPORTANT] 关系模式可以形式化表示为R(U, D, DOM, F)。U为组成该关系的属性名，D为U中属性所来⾃的域，DOM 指的是属性与域的映射，F指的是属性间的依赖关系集合。以下约定N表示正整数，FLOAT 表示浮点数，S为任意字符组成的字符S，T表示时间，B表示布尔值，J表示json类型。码以下划线标识。 以下是由 E-R 图得到的关系模式。 3.1.1 实体 学生 students({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(id) = DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 辅导师 teachers({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 消息 messages({id，发送者，发送者头像，发送时间，接收者， 消息内容，是否已阅}，D，DOM，F) D = {STR, N, B, T} DOM = {DOM(id) = DOM(发送者) = DOM(接收者) = N， DOM(头像) = DOM(内容) = STR，DOM(发送时间) = T，DOM(是否已阅) = B} F = {id$\\to$其他属性} 公告 broadcasts({id，发布者，发布者头像，发布时间，更新时间，公告内容，公告标题}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = STR，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 题库 quesionbanks({id，科目，预计完成时间，创建时间，创建者，题库描述，题目数量}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(创建者) = DOM(题目数量) = N， DOM(科目) = DOM(题库描述) = STR，DOM(创建时间) = DOM(预计完成时间) = T} F = {id$\\to$其他属性} 题目 questions({id，类型，内容，科目，上传时间，来源，标签，难度，上传者，选项数量，所属题库，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(上传者) = DOM(题目难度) = DOM(选项数量) = DOM(所属题库) = N， DOM(科目) = DOM(类型) = DOM(来源) = DOM(内容) = STR，DOM(标签) = DOM(所属题库) = J，DOM(上传时间) = T} F = {id$\\to$其他属性} 讨论帖 discussions({id，发布者，发布者头像，发布时间，更新时间，帖子内容，帖子标题，帖子标签，订阅者，喜爱者，是否加精}，D，DOM，F) D = {STR, N，T，J，B} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = DOM(标签) = STR，DOM(订阅者) = DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T，DOM(是否加精) = B} F = {id$\\to$其他属性} 回复帖 replies({id，所属讨论帖，发布者，发布者头像，发布时间，更新时间，帖子内容，喜爱者}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(所属讨论帖) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = STR，DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 模拟考试 exams({id，标题，科目，开始时间，持续时间，结束时间，创建时间，创建者，考试描述，考试题目，参考学生}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(创建者) = N， DOM(科目) = DOM(标题) = DOM(考试描述) = STR，DOM(考试试题) = DOM(参考学生) = J，DOM(创建时间) = DOM(持续时间) = DOM(创开始时间) = DOM(结束时间) = T} F = {id$\\to$其他属性} 3.1.2 联系 [!IMPORTANT] 约定以下函数依赖集合省略⾮主属性对码的完全函数依赖。 3.1.2.1 多对多联系 学生——考试 studentExam({student, exam}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(exam) = N} 外码：student 对应学⽣表的主码 student.id, course 对应考试表的主码 course.id 考试——题目 questionExam({question, exam}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(exam) = N} 外码：question 对应题目表的主码 question.id, course 对应考试表的主码 course.id 题库——题目 questionQuestionbank({question, questionbank}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(questionbank) = N} 外码：question 对应题目表的主码 question.id, questionbank 对应题库表的主码 questionbank.id 帖子——订阅 subscibeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id 帖子——喜爱 likeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id 回复——喜爱 likeReply({student, reply}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply 对应回复帖表的主码 reply.id 学生作答题目 studentSubmission({student, question, time, submission, is_correct}, D, DOM, F) D = {STR, N, T, B} DOM = {DOM(submission) = STR,DOM(student) = DOM(question) = N, DOM(time) = T, DOM(is_correct) = B} 外码：student 对应学⽣表的主码 student.id, question 对应题目表的主码 question.id 3.1.2.2 一对多联系 学生——发送消息 sendMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id 学生——接收消息 receiveMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id 学生——接收公告 receiveBroadcast({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(broadcast) = N} 外码：student 对应学⽣表的主码 student.id, broadcast 对应公告表的主码 broadcast.id 教师——发布公告 publishBroadcast({message, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(broadcast) = N} 外码：teacher 对应教师表的主码 teacher.id, broadcast 对应公告表的主码 broadcast.id 教师——题库 teacherQuestionbank({questionbank, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(questionbank) = N} 外码：teacher 对应教师表的主码 teacher.id, questionbank 对应题库表的主码 questionbank.id 教师——题目 teacherQuestion({question, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(question) = N} 外码：teacher 对应教师表的主码 teacher.id, question 对应题库表的主码 question.id 教师——考试 teacherExam({exam, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(exam) = N} 外码：teacher 对应教师表的主码 teacher.id, exam 对应考试表的主码 exam.id 学生——讨论 studentDiscussion({discussion, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion对应讨论表的主码 discussion.id 学生——回复 studentReply({reply, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply对应回复表的主码 reply.id 讨论帖——回复 discussionReply({reply, discussion}, D, DOM, F) D = {N} DOM = {DOM(reply) = DOM(discussion) = N} 外码：discussion对应讨论表的主码 discussion.id, reply对应回复表的主码 reply.id 3.2 关系模式范式等级的判定与规范 [!NOTE] 分别对上述表进⾏范式等级判断，然后将未达到 3NF 的表规范到 3NF。 3.2.1 实体 学生 students({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(id) = DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 对于学生表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以学生表$\\in BCNF$，学生表$\\in 3NF$ 辅导师 teachers({id，头像，邮箱, 密码, 姓名, 学号, 年级，学院，身份}, D, DOM, F) D = {STR, N} DOM = {DOM(年级) = DOM(身份) = N,DOM(头像) = DOM(邮箱) = DOM(密码) = DOM(姓名) = DOM(学号) = STR} F = {id$\\to$其他属性} 对于辅导师表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以辅导师表$\\in BCNF$，辅导师表$\\in 3NF$ 消息 messages({id，发送者，发送者头像，发送时间，接收者， 消息内容，是否已阅}，D，DOM，F) D = {STR, N, B, T} DOM = {DOM(id) = DOM(发送者) = DOM(接收者) = N， DOM(头像) = DOM(内容) = STR，DOM(发送时间) = T，DOM(是否已阅) = B} F = {id$\\to$其他属性} 对于消息表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以消息表$\\in BCNF$，消息表$\\in 3NF$ 公告 broadcasts({id，发布者，发布者头像，发布时间，更新时间，公告内容，公告标题}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = STR，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 对于公告表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以公告表$\\in BCNF$，公告表$\\in 3NF$ 题库 quesionbanks({id，科目，预计完成时间，创建时间，创建者，题库描述，题目数量}，D，DOM，F) D = {STR, N，T} DOM = {DOM(id) = DOM(创建者) = DOM(题目数量) = N， DOM(科目) = DOM(题库描述) = STR，DOM(创建时间) = DOM(预计完成时间) = T} F = {id$\\to$其他属性} 对于题库表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以题库表$\\in BCNF$，题库表$\\in 3NF$ 题目 questions({id，类型，内容，科目，上传时间，来源，标签，难度，上传者，选项数量，所属题库，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(上传者) = DOM(题目难度) = DOM(选项数量) = DOM(所属题库) = N， DOM(科目) = DOM(类型) = DOM(来源) = DOM(内容) = STR，DOM(标签) = DOM(所属题库) = J，DOM(上传时间) = T} F = {id$\\to$其他属性} 对于题目表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以题目表$\\in BCNF$，题目表$\\in 3NF$ 讨论帖 discussions({id，发布者，发布者头像，发布时间，更新时间，帖子内容，帖子标题，帖子标签，订阅者，喜爱者，是否加精}，D，DOM，F) D = {STR, N，T，J，B} DOM = {DOM(id) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = DOM(标题) = DOM(标签) = STR，DOM(订阅者) = DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T，DOM(是否加精) = B} F = {id$\\to$其他属性} 对于讨论帖表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以讨论帖表$\\in BCNF$，讨论帖表$\\in 3NF$ 回复帖 replies({id，所属讨论帖，发布者，发布者头像，发布时间，更新时间，帖子内容，喜爱者}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(所属讨论帖) = DOM(发布者) = N， DOM(发布者头像) = DOM(内容) = STR，DOM(喜爱者) = J，DOM(发布时间) = DOM(更新时间) = T} F = {id$\\to$其他属性} 对于回复帖表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以回复帖表$\\in BCNF$，回复帖表$\\in 3NF$ 模拟考试 exams({id，标题，科目，开始时间，持续时间，结束时间，创建时间，创建者，考试描述，考试题目，参考学生}，D，DOM，F) D = {STR, N，T，J} DOM = {DOM(id) = DOM(创建者) = N， DOM(科目) = DOM(标题) = DOM(考试描述) = STR，DOM(考试试题) = DOM(参考学生) = J，DOM(创建时间) = DOM(持续时间) = DOM(创开始时间) = DOM(结束时间) = T} F = {id$\\to$其他属性} 对于模拟考试表，id是主码，⾮主属性仅仅依赖于唯⼀的主码，所以模拟考试表$\\in BCNF$，模拟考试表$\\in 3NF$ 3.2.2 联系 [!IMPORTANT] 约定以下函数依赖集合省略⾮主属性对码的完全函数依赖。 3.2.2.1 多对多联系 学生——考试 studentExam({student, exam}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(exam) = N} 外码：student 对应学⽣表的主码 student.id, course 对应考试表的主码 course.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 考试——题目 questionExam({question, exam}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(exam) = N} 外码：question 对应题目表的主码 question.id, course 对应考试表的主码 course.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 题库——题目 questionQuestionbank({question, questionbank}, D, DOM, F) D = {N} DOM = {DOM(question) = DOM(questionbank) = N} 外码：question 对应题目表的主码 question.id, questionbank 对应题库表的主码 questionbank.id 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 帖子——订阅 subscibeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id F = {(student, discussion) $\\to$ subscribed} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 帖子——喜爱 likeDiscussion({student, discussion}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion 对应讨论帖表的主码 discussion.id F = {(student, discussion) $\\to$ liked} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 回复——喜爱 likeReply({student, reply}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply 对应回复帖表的主码 reply.id F = {(student, reply) $\\to$ liked} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 学生作答题目 studentSubmission({student, question, time, submission, is_correct}, D, DOM, F) D = {STR, N, T, B} DOM = {DOM(submission) = STR,DOM(student) = DOM(question) = N, DOM(time) = T, DOM(is_correct) = B} 外码：student 对应学⽣表的主码 student.id, question 对应题目表的主码 question.id F = {(student, question ) $\\to$ is_correct, (student, question ) $\\to$ time} 对于该表，所有函数依赖左端都是主码，所以$ \\in BCNF$，因此也$\\in 3NF$。 3.2.2.2 ⼀对多联系 学生——发送消息 sendMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id F = {message $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——接收消息 receiveMessage({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(message) = N} 外码：student 对应学⽣表的主码 student.id, message 对应消息表的主码 message.id F = {message $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——接收公告 receiveBroadcast({message, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(broadcast) = N} 外码：student 对应学⽣表的主码 student.id, broadcast 对应公告表的主码 broadcast.id F = {broadcast $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——发布公告 publishBroadcast({message, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(broadcast) = N} 外码：teacher 对应教师表的主码 teacher.id, broadcast 对应公告表的主码 broadcast.id F = {broadcast $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——题库 teacherQuestionbank({questionbank, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(questionbank) = N} 外码：teacher 对应教师表的主码 teacher.id, questionbank 对应题库表的主码 questionbank.id F = {questionbank $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——题目 teacherQuestion({question, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(question) = N} 外码：teacher 对应教师表的主码 teacher.id, question 对应题库表的主码 question.id F = {question $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 教师——考试 teacherExam({exam, teacher}, D, DOM, F) D = {N} DOM = {DOM(teacher) = DOM(exam) = N} 外码：teacher 对应教师表的主码 teacher.id, exam 对应考试表的主码 exam.id F = {exam $\\to$ teacher} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——讨论 studentDiscussion({discussion, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(discussion) = N} 外码：student 对应学⽣表的主码 student.id, discussion对应讨论表的主码 discussion.id F = {discussion $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 学生——回复 studentReply({reply, student}, D, DOM, F) D = {N} DOM = {DOM(student) = DOM(reply) = N} 外码：student 对应学⽣表的主码 student.id, reply对应回复表的主码 reply.id F = {reply $\\to$ student} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 讨论帖——回复 discussionReply({reply, discussion}, D, DOM, F) D = {N} DOM = {DOM(reply) = DOM(discussion) = N} 外码：discussion对应讨论表的主码 discussion.id, reply对应回复表的主码 reply.id F = {reply $\\to$ discussion} 函数依赖左端仅包含主码，不存在传递函数依赖和部分函数依赖，所以 $\\in BCNF$，因此也$\\in 3NF$。 3.3 数据库关系模式优化3.3.1 使⽤外键使⽤外键来保证数据的关联性并提⾼访问速度，同时在使⽤过程中保证数据的参照完整性。在本项⽬的后端数据库中，各表具有完备的外键联系，通过遵循这种外键关系进⾏实际数据库的建⽴，将从逻辑的⻆度保证数据库的设计功能能够完全正确执⾏到位。 3.3.2 优化查询语句可以优化的地⽅有如下⼏点： 能使⽤联表查询的地⽅尽可能使⽤联表查询⽐较⾼效 尽可能不将查询语句放在循环内 使⽤高效的 ORM 框架 3.3.3 合并相同主码的表对于主码相同的表，可以在设计的时候将其合并，例如将题目创建表和题目表合并，直接将题目的上传者和上传时间存⼊题目表，这样做的好处是在同时需要查询两个表中的数据时，减少了⼀次连接操作，提⾼效率。 3.3.4 严格约束加⼊数据库的数据通过建表时添加约束、⽤触发器实现约束等⽅法，严格约束对数据库的增删操作，避免将异常数据插⼊数据表。 建表时可以添加的约束有主键约束、UNIQUE 约束、外码约束等。 四、数据库物理设计4.1 存取方法存储引擎： 选择支持事务和索引优化的存储引擎——支持MySQL 的 GAUSSDB。 理由：GAUSSDB支持事务和外键约束，可以确保数据一致性，同时MySQL针对复杂查询性能较优。 分区策略： 垂直分区 将核心表（如 User、Question 和 QuestionBank）与非核心表（如 QuestionComment 和 QuestionDiscussion）分开存储。 理由：核心表频繁被查询，可以优化存储和查询效率；非核心表如评论和讨论，属于高并发写入的表，可独立优化。 水平分区 针对大数据量表（如 Question 和 UserQuestionRecord），根据字段（如 added_by 或 user_id）进行分片。 理由：便于高并发环境下的数据分布和扩展性。 数据类型选择： 使用合适的数据类型，如 INTEGER、VARCHAR、DATE 等。 对于 JSON 格式数据（如 tags），选择利用字符串存储。 4.2 索引定义为提高查询效率，我们设计索引如下： 1. User 表 主键索引：id（自动创建） 唯一索引：student_id 优点：学生学号唯一，且常用于查询，加快查询速度 索引：user_role 优点：辅导师角色（user_role = 1）在权限检查中频繁使用，加快查询速度 2. Question 表 主键索引：id（自动创建） 索引：added_by 优点：便于根据创建者快速查询 索引：type和 subject 优点：按题目类型和科目分类查询时提升效率 索引：added_at 优点：时间排序查询优化 索引：tags 优点：支持基于关键词的搜索（如 工科数学分析） 3. QuestionBank 表 主键索引：id（自动创建） 索引：subject 优点：按学科分类查询优化 索引：creator 优点：便于按创建者筛选 4. QuestionDiscussion 表 主键索引：id（自动创建） 索引：question_id 优点：按题目快速查询讨论区。 索引：created_by 优点：便于按创建者筛选讨论。 5. QuestionComment 表 主键索引：id（自动创建） 索引：discussion_id 优点：便于按讨论区快速查询评论 索引：created_by 优点：便于按创建者筛选评论 6. UserQuestionRecord 表 主键索引：id（自动创建） 唯一复合索引：(user_id, question_id) 优点：确保每个用户对每道题目只有一个做题记录 索引：user_id 优点：按用户快速筛选做题记录 索引：question_id 优点：按题目快速筛选做题记录 7. ExamRecordRecord 表 主键索引：id（自动创建） 唯一复合索引：(student_id, question_id) 优点：确保每个用户对每道题目只有一个做题记录 索引：student_id 优点：按用户快速筛选做题记录 索引：question_id 优点：按题目快速筛选做题记录 8. Discussion表 主键索引：id（自动创建） 索引：publisher 优点：便于按创建者筛选讨论 9. Reply表 主键索引：id（自动创建） 索引：publisher 优点：便于按创建者筛选讨论 索引：discussion 优点：便于按讨论帖筛选回复 10. Message表 主键索引：id（自动创建） 索引：sender 优点：便于按发送者筛选消息 索引：receiver 优点：便于按接收者筛选消息 11. Broadcast表 主键索引：id（自动创建） 索引：sender 优点：便于按发布者筛选公告 12. 外键约束 为外键字段自动创建索引： QuestionBank.questions $\\to$ Question.id QuestionDiscussion.question $\\to$ Question.id QuestionComment.discussion $\\to$ QuestionDiscussion.id UserQuestionRecord.question $\\to$ Question.id UserQuestionRecord.user $\\to$ User.id","link":"/2025/08/14/database/"},{"title":"RooKie_Z Compiler编译器设计文档","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 写在前面RooKie_Z Compiler编译器设计文档，本编译器 在最终的竞速中排名第五 Update time: 2024年12月3日 星期二 18时19分15秒 CST “免责声明” 文档撰写要求中要求按照编码前的设计、编码完成之后的修改的顺序完成各部分撰写 而事实上，我向来偏好调研先于实践，设计早于编码的代码撰写理念，而这篇设计文档也完全是本人的有感而发，设计用时相较编码用时极长，故代码重构较少，因此，请允许我不采用推荐的格式，按照我的编译器设计完成的思路完成这篇设计文档，不胜感激！！！ 参考编译器介绍参考了强生学长的 Pansy编译器，这是一个简单的编译SysY语言到Mips的编译器。该编译器设计极为精美，架构相当完整，可拓展性强，我的架构主要也模仿了 Pansy编译器 另外，据强生学长介绍，Pansy还有美人之意，这样一看我的代码也属于是东施效颦了😇 总体结构 接口设计具体的接口层有四层 Tokens -&gt; CST：向前负责，有一个统一的 Parser 用于生成 CST。 CST -&gt; LLVM IR：向后负责，CST 的每个节点实现了相应的 irBuild。 CST -&gt; Errors：向后负责，CST 的每个节点实现了相应的 check。 LLVM IR -&gt; MIR：向前负责，有一个统一的 IrParser 用于生成 MIR。 文件组织 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189.├── Compiler.java├── back│ ├── Backend.java│ ├── README.md│ ├── component│ │ ├── ObjBlock.java│ │ ├── ObjFunction.java│ │ ├── ObjGlobalVariable.java│ │ └── ObjModule.java│ ├── instruction│ │ ├── ObjBinary.java│ │ ├── ObjBranch.java│ │ ├── ObjCall.java│ │ ├── ObjCoMove.java│ │ ├── ObjComment.java│ │ ├── ObjCompare.java│ │ ├── ObjCondType.java│ │ ├── ObjInstr.java│ │ ├── ObjLoad.java│ │ ├── ObjMove.java│ │ ├── ObjRet.java│ │ ├── ObjShift.java│ │ └── ObjStore.java│ ├── operand│ │ ├── ObjImm.java│ │ ├── ObjLabel.java│ │ ├── ObjOperand.java│ │ ├── ObjPhyReg.java│ │ ├── ObjReg.java│ │ └── ObjVirReg.java│ └── process│ ├── BlockLiveInfo.java│ ├── IrParser.java│ ├── Peephole.java│ └── RegAllocator.java├── check│ ├── CheckDataType.java│ ├── Checker.java│ ├── ErrorType.java│ ├── FuncInfo.java│ ├── PansyException.java│ ├── README.md│ ├── SymbolInfo.java│ ├── SymbolTable.java│ └── VarInfo.java├── driver│ ├── Config.java│ └── Driver.java├── ir│ ├── IrBuilder.java│ ├── IrSymbolTable.java│ ├── README.md│ ├── types│ │ ├── ArrayType.java│ │ ├── DataType.java│ │ ├── FunctionType.java│ │ ├── IntType.java│ │ ├── LabelType.java│ │ ├── PointerType.java│ │ ├── ValueType.java│ │ └── VoidType.java│ └── values│ ├── Argument.java│ ├── BasicBlock.java│ ├── Function.java│ ├── GlobalVariable.java│ ├── Module.java│ ├── User.java│ ├── Value.java│ ├── constants│ │ ├── ConstArray.java│ │ ├── ConstInt.java│ │ ├── ConstStr.java│ │ ├── Constant.java│ │ └── ZeroInitializer.java│ └── instructions│ ├── Add.java│ ├── Alloca.java│ ├── BinInstruction.java│ ├── Br.java│ ├── Call.java│ ├── GetElementPtr.java│ ├── Icmp.java│ ├── Instruction.java│ ├── Load.java│ ├── MemInstruction.java│ ├── Mul.java│ ├── Phi.java│ ├── Ret.java│ ├── Sdiv.java│ ├── Srem.java│ ├── Store.java│ ├── Sub.java│ ├── TerInstruction.java│ └── Zext.java├── lexer│ ├── Lexer.java│ ├── README.md│ └── token│ ├── Comment.java│ ├── Delimiter.java│ ├── EOFToken.java│ ├── FormString.java│ ├── Identifier.java│ ├── IntConst.java│ ├── Reserved.java│ ├── SyntaxType.java│ └── Token.java├── parser│ ├── ParseSupporter.java│ ├── Parser.java│ ├── README.md│ ├── SysY.g4│ └── cst│ ├── AddExpNode.java│ ├── AssignStmtNode.java│ ├── BTypeNode.java│ ├── BlockItemNode.java│ ├── BlockNode.java│ ├── BreakStmtNode.java│ ├── CSTNode.java│ ├── CalleeNode.java│ ├── CondNode.java│ ├── ConditionStmtNode.java│ ├── ConstDeclNode.java│ ├── ConstDefNode.java│ ├── ConstExpNode.java│ ├── ConstInitValNode.java│ ├── ContinueStmtNode.java│ ├── DeclNode.java│ ├── EqExpNode.java│ ├── ExpNode.java│ ├── ExpStmtNode.java│ ├── FuncDefNode.java│ ├── FuncFParamNode.java│ ├── FuncFParamsNode.java│ ├── FuncRParamsNode.java│ ├── FuncTypeNode.java│ ├── InStmtNode.java│ ├── InitValNode.java│ ├── LAndExpNode.java│ ├── LOrExpNode.java│ ├── LValNode.java│ ├── MainFuncDefNode.java│ ├── MulExpNode.java│ ├── NumberNode.java│ ├── OutStmtNode.java│ ├── PrimaryExpNode.java│ ├── RelExpNode.java│ ├── ReturnStmtNode.java│ ├── RootNode.java│ ├── StmtNode.java│ ├── TokenNode.java│ ├── UnaryExpNode.java│ ├── UnaryOpNode.java│ ├── VarDeclNode.java│ ├── VarDefNode.java│ └── WhileStmtNode.java├── pass│ ├── Pass.java│ ├── PassManager.java│ ├── README.md│ ├── analyze│ │ ├── BuildCFG.java│ │ ├── DomInfo.java│ │ ├── Loop.java│ │ ├── LoopInfo.java│ │ ├── LoopInfoAnalysis.java│ │ └── SideEffectAnalysis.java│ └── refactor│ ├── BranchOpt.java│ ├── DeadCodeEmit.java│ ├── FunctionClone.java│ ├── GCM.java│ ├── GVN.java│ ├── GlobalVariableLocalize.java│ ├── InlineFunction.java│ ├── InstructionSimplify.java│ ├── Mem2reg.java│ └── UselessRetEmit.java└── util ├── MyCompare.java ├── MyIO.java ├── MyList.java ├── MyMath.java ├── MyPair.java └── MyPrintf.java 编译器总体设计总体结构通过理论课的学习可以知道，我们通常将编译过程分为如下阶段： 词法分析，语法分析，语义分析，llvm生成，llvm优化，mips生成及优化，其中错误处理贯穿整个前端过程。 前端 词法分析：构建了贪心简化的 DFA，输入源程序，输出 token序列。 语法分析：通过递归下降子程序，进行最左推导。其中采用了 扩充的BNF范式解决左递归问题，并通过 预读FIRST集的方式来尽可能避免回溯并完成错误处理。 语义分析：通过遍历语法分析得到的语法树，构建符号表。 错误处理：在词法分析、语法分析中进行语法错误处理，在语义分析中进行语义错误处理。 中端(llvm优化) 中端实现了 Mem2reg，重构并生成了带有 phi函数的中间代码。 构建控制流图(CFG)，求解支配者与支配边界。 重构SSA，phi指令的插入与变量重命名。 副作用分析 GVL DCE（死代码删除） 后端(mips代码生成及优化) 非 phi指令中间代码的翻译，phi指令的翻译。至此为止分配的都是虚拟寄存器。 图着色寄存器分配。 少量窥孔优化。 接口设计类似于 Pansy： 具体的接口层有四层 Tokens -&gt; AST：向前负责，有一个统一的 Parser 用于生成 AST。 AST -&gt; Symbol：向后负责，AST 的每个节点实现了相应的 visit方法。 AST -&gt; Errors：向后负责，AST 的每个节点实现了相应的 visit方法在其中完成错误处理。 AST -&gt; LLVM IR：向后负责，AST 的每个节点实现了相应的 BuildIr方法。 LLVM IR -&gt; MIPS：向前负责，有一个统一的 MipsBuilder用于生成 MIPS。 文件组织123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170.├── Compiler.java├── backend│ ├── MipsBuilder.java│ ├── MipsFactory.java│ ├── components│ │ ├── MipsBlock.java│ │ ├── MipsFunction.java│ │ ├── MipsGlobalVariable.java│ │ └── MipsModule.java│ ├── instructions│ │ ├── MipsBinary.java│ │ ├── MipsBranch.java│ │ ├── MipsCall.java│ │ ├── MipsComment.java│ │ ├── MipsCompare.java│ │ ├── MipsCondType.java│ │ ├── MipsInstruction.java│ │ ├── MipsLoad.java│ │ ├── MipsMacro.java│ │ ├── MipsMove.java│ │ ├── MipsMoveHI.java│ │ ├── MipsRet.java│ │ ├── MipsShift.java│ │ └── MipsStore.java│ ├── operands│ │ ├── MipsImm.java│ │ ├── MipsLabel.java│ │ ├── MipsOperand.java│ │ ├── MipsRealReg.java│ │ ├── MipsVirtualReg.java│ │ └── RegType.java│ ├── reg│ │ ├── BlockLiveVarInfo.java│ │ └── RegAllocator.java│ └── utils│ ├── MipsMathOpt.java│ ├── MipsUtil.java│ ├── Pair.java│ └── Triple.java├── compiler.zip├── config.json├── error│ ├── Error.java│ ├── ErrorHandler.java│ ├── ErrorType.java│ └── ErrorUtil.java├── exception│ └── LexerException.java├── frontend│ ├── Lexer.java│ ├── Parser.java│ └── Visitor.java├── ir│ ├── IrBuilder.java│ ├── IrFactory.java│ ├── IrSymbolTable.java│ ├── IrSymbolTableStack.java│ ├── IrUtil.java│ ├── types│ │ ├── ArrayType.java│ │ ├── CharType.java│ │ ├── FuncType.java│ │ ├── IntType.java│ │ ├── LabelType.java│ │ ├── PointerType.java│ │ ├── ValueType.java│ │ └── VoidType.java│ └── values│ ├── BasicBlock.java│ ├── Function.java│ ├── GlobalVariable.java│ ├── Module.java│ ├── User.java│ ├── Value.java│ ├── constants│ │ ├── ConstArray.java│ │ ├── ConstChar.java│ │ ├── ConstInt.java│ │ ├── ConstString.java│ │ ├── Constant.java│ │ └── ZeroInitializer.java│ ├── instructions│ │ ├── Add.java│ │ ├── Alloca.java│ │ ├── ArithmeticInstruction.java│ │ ├── Br.java│ │ ├── Call.java│ │ ├── GetElementPtr.java│ │ ├── Icmp.java│ │ ├── Instruction.java│ │ ├── Load.java│ │ ├── Mul.java│ │ ├── Phi.java│ │ ├── Ret.java│ │ ├── Sdiv.java│ │ ├── Srem.java│ │ ├── Store.java│ │ ├── Sub.java│ │ ├── Trunc.java│ │ └── Zext.java│ └── pass│ ├── AggressiveDeadCodeEmit.java│ ├── BuildCFG.java│ ├── DeadCodeEmit.java│ ├── DomInfo.java│ ├── GVL.java│ ├── Loop.java│ ├── LoopInfo.java│ ├── Mem2Reg.java│ ├── SideEffectAnalysis.java│ └── UselessRetEmit.java├── node│ ├── AddExpNode.java│ ├── BTypeNode.java│ ├── BlockItemNode.java│ ├── BlockNode.java│ ├── CharacterNode.java│ ├── CompUnitNode.java│ ├── CondNode.java│ ├── ConstDeclNode.java│ ├── ConstDefNode.java│ ├── ConstExpNode.java│ ├── ConstInitValNode.java│ ├── DeclNode.java│ ├── EqExpNode.java│ ├── ExpNode.java│ ├── ForStmtNode.java│ ├── FuncDefNode.java│ ├── FuncFParamNode.java│ ├── FuncFParamsNode.java│ ├── FuncRParamsNode.java│ ├── FuncTypeNode.java│ ├── InitValNode.java│ ├── LAndExpNode.java│ ├── LOrExpNode.java│ ├── LValNode.java│ ├── MainFuncDefNode.java│ ├── MulExpNode.java│ ├── Node.java│ ├── NodeType.java│ ├── NumberNode.java│ ├── PrimaryExpNode.java│ ├── RelExpNode.java│ ├── StmtNode.java│ ├── StmtType.java│ ├── UnaryExpNode.java│ ├── UnaryOpNode.java│ ├── VarDeclNode.java│ └── VarDefNode.java├── opt│ └── Peephole.java├── symbol│ ├── CharSymbol.java│ ├── FuncSymbol.java│ ├── NumSymbol.java│ ├── Symbol.java│ ├── SymbolTable.java│ ├── SymbolTableStack.java│ └── SymbolType.java├── test│ └── testReg.java├── token│ ├── Token.java│ └── TokenType.java├── utils│ ├── Config.java│ ├── IO.java│ └── Phases.java└── 设计文档.md 词法分析大体思路词法分析部分的主要任务是顺序遍历源程序代码，将其按照文法转化为token序列。 词法分析可以通过正则表达式匹配或者贪心简化过的DFA实现，我完成了正则表达式的撰写，但由于我是正则苦手﫠，最终我选择了后者。 DFA的设计DFA通过 fronted/Lexer.java实现，我们的单词大致分为四类，分别是保留字、 字符串常量、标识符、分界符。通过贪心匹配不同类别的FIRST集合，即可根据当前字符，确定下面将要处理的单词的大致种类。 调用 next()方法即可读取下一个token，大致框架如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public Token next() throws LexerException { currentToken = null; do { skipWhite(); } while (skipComment()); if (pos &gt; maxLength) { return null; } char nowChar = inputText.charAt(pos); if (Character.isDigit(nowChar)) { int endPos = pos + 1; while (endPos &lt;= maxLength &amp;&amp; Character.isDigit(inputText.charAt(endPos))) { endPos++; } String str = inputText.substring(pos, endPos); // 更新pos pos = endPos; currentToken = new Token(str, lineNum, TokenType.INTCON); } else if (isIdentifierNondigit(nowChar)) { int endPos = pos + 1; while (endPos &lt;= maxLength &amp;&amp; isIdentifierDigit(inputText.charAt(endPos))) { endPos++; } String str = inputText.substring(pos, endPos); // 更新pos pos = endPos; // 判断是否为保留字 TokenType type = TokenType.isReserved(str); currentToken = new Token(str, lineNum, Objects.requireNonNullElse(type, TokenType.IDENFR)); } else if (nowChar == '\\'') { int endPos = pos + 1; boolean backslashFlag = false; while (endPos &lt;= maxLength &amp;&amp; (inputText.charAt(endPos) != '\\'' || (inputText.charAt(endPos) == '\\'' &amp;&amp; backslashFlag))) { backslashFlag = inputText.charAt(endPos) == '\\\\' &amp;&amp; !backslashFlag; endPos++; } // 检查'是否匹配 if (endPos &gt; maxLength) { throw new LexerException(lineNum); } endPos++; String str = inputText.substring(pos, endPos); pos = endPos; currentToken = new Token(str, lineNum, TokenType.CHRCON); } else if (nowChar == '\\&quot;') { int endPos = pos + 1; boolean backslashFlag = false; while (endPos &lt;= maxLength &amp;&amp; (inputText.charAt(endPos) != '\\&quot;' || inputText.charAt(endPos) == '\\&quot;' &amp;&amp; backslashFlag)) { backslashFlag = inputText.charAt(endPos) == '\\\\' &amp;&amp; !backslashFlag; endPos++; } // 检查&quot;是否匹配 if (endPos &gt; maxLength) { throw new LexerException(lineNum); } endPos++; String str = inputText.substring(pos, endPos); pos = endPos; currentToken = new Token(str, lineNum, TokenType.STRCON); } else { TokenType tokenType = null; int tokenLength = 0; String str = &quot;&quot;; if (TokenType.singleCharList.contains(nowChar)) { tokenType = TokenType.getTokenType((str = inputText.substring(pos, pos + 1))); tokenLength = 1; } if (pos &lt; maxLength &amp;&amp; TokenType.doubleCharList.contains(nowChar)) { TokenType t = TokenType.getTokenType(inputText.substring(pos, pos + 2)); if (t != null) { tokenType = t; tokenLength = 2; str = inputText.substring(pos, pos + 2); } else if (isErrorA(inputText.charAt(pos))) { System.out.println(inputText.charAt(pos) + &quot; &quot; + &quot;我做了错饭&quot;); ErrorHandler.addError(new Error(ErrorType.a, lineNum)); tokenType = (inputText.charAt(pos) == '&amp;') ? TokenType.AND : TokenType.OR; str = (inputText.charAt(pos) == '&amp;') ? &quot;&amp;&amp;&quot; : &quot;||&quot;; tokenLength = 1; } } if (tokenType != null) { currentToken = new Token(str, lineNum, tokenType); pos += tokenLength; } } if (currentToken != null) { tokenResult.add(currentToken); } return currentToken; } Token类为了进行可能的语法拓展，我对于各种 token进行了抽象，建立Token类，该类记录了 Token的原字符串，token的类型，以及其所在行号（供错误处理使用） 12345public Token(String content, int lineNum, TokenType type) { this.content = content; this.lineNum = lineNum; this.type = type; } 有关文法设定部分位于 token/TokenType.java 对于所有 Token标识符，我都加以枚举，定义在枚举类 TokenType里。 此外，为了便于状态机读取当前字符后的进一步状态转移，对于文法中规定的 保留字、以及 单/双分界符$ ==, \\ne, \\le, \\ge, \\gt, \\lt, !, &amp;, |$，进行建表与划分。 以上两种信息均为“文法给出的设定”，因此在设计上理应放入一个类中，这使得我们的 Lexer类并不会把文法写死在代码里，便于后续期中期末考试修改文法时，快速完成词法分析部分的修改。 语法分析大体思路语法分析的任务是是读入 token序列，并分析确定其语法结构，最终生成语法树的过程。 [!NOTE]通过理论课我们知道，我们可以使用递归下降分析法来实现语法分析，而由于递归下降子程序本质上是在进行最左推导，因此可能会遇到左递归和回溯的问题。 具体来说: 我为每个非终结符编写一个递归子程序，以完成该非终结符所对应的语法成分的分析与识别任务，若正确识别，则可以退出该非终结符号的子程序，返回到上一级的子程序继续分析；若发生错误，即源程序不符合文法，则要进行相应的错误信息报告以及错误处理。 nextSym()的实现 [!NOTE] 通过理论课的学习我们知道，法分析的推进，本质上是终结符识别进度的推进，因此 nextSym的调用时机应当是成功识别一个终结符后。 事实上，在理论课提供的 Pascal语言编译器的语法分析部分，对于 nextSym的设计太过简单，导致示例程序低内聚，高耦合，考虑到在语法分析部分就有进行错误处理的需要，我对于 nextSym()程序进行了改写。 具体思路为：将识别终结符，nextSym，以及后续可能的错误处理整合进一个函数当中。 左递归的处理涉及到左递归的文法主要是关于 Exp系列的非终结符。 1AddExp -&gt; MulExp | AddExp ('+' | '−') MulExp [!NOTE] 通过理论课的学习我们知道，对于左递归文法，一般有2种处理方式——右递归改写 or 采用扩充的BNF范式 右递归改写例如： 1AddExp -&gt; MulExp | MulExp ('+' | '−') AddExp 但如此处理是存在潜在风险的，因为修改了文法 扩充的BNF范式还有一种处理方式是采用BNF范式，修改了文法，直接丢掉 AddExp。 1AddExp -&gt; MulExp {'+' MulExp} 这种处理方式依然存在风险，因为后续的所有编译环节都要相应地使用修改后的文法。 处理方式 [!IMPORTANT] 经过上述分析，考虑到未来 期中期末考试可能涉及的潜在的文法修改与更新，通过参考学长编译器的设计，我决定采用一种更符合实际编译器撰写的方法进行处理，即： 对于上述例子，在扩充的BNF范式的基础上再进一步，把刚刚拆出来的所有 MulExp全部手动组装回左递归的形态。我们利用 java的面向对象特性，将解析出的 MulExp重新组装为 AddExp。 此时左递归对于后续的编译部分不再有影响，因为我们的信息已经全部存储在编译器中，不再受到最左推导的限制。 代码示例： 12345678910111213// AddExp → MulExp | AddExp ('+' | '−') MulExp public AddExpNode AddExp() { AddExpNode addExpNode = null; Token opToken = null; MulExpNode mulExpNode = MulExp(); while (currentToken.type == TokenType.PLUS || currentToken.type == TokenType.MINU) { addExpNode = new AddExpNode(addExpNode, opToken, mulExpNode); opToken = matchToken(currentToken.type); mulExpNode = MulExp(); } return new AddExpNode(addExpNode, opToken, mulExpNode); } 回溯法对于一般的产生式，我们采用FIRST集来判别即可，但是也有一些不那么友好的产生式，我们难以判别： 选择哪个产生式。 产生式中 {xxx}的重复部分，到底应该何时结束。 重复部分啥时候结束？看看 )，]不就好了？事实上，我们在后续错误处理中采取的，补全的错误局部化策略，迫使我们的程序在 )，]缺失时依然要正常工作。为解决这个问题，我们只得以循环部的FIRST集来判别。 回到我们的回溯问题来。 回溯，即FIRST也失灵的情况下，我们被迫跳过某个非终结符，对后面的标志性符号进行分析，从而判断选取的产生式分支的手段。 回溯只产生在 Stmt的左值与 Exp判别上： 1234plaintextStmt -&gt; LVal '=' Exp ';'Stmt -&gt; [Exp] ';'Stmt -&gt; LVal '=' 'getint''('')'';' 在这里，Exp当然可以透过 PrimaryExp推出左值 LVal，FIRST集失灵。 为此，我们要处理掉碍事的 LVal，暴露出后面的 =和 getint。 回溯主要是采用 pinToken()和 reflow()来记录、复原当前游标在token序列的位置。详细代码及注释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647default -&gt; { // 最喜欢的一集 // 余下四种情况： // LVal '=' Exp ';' // [Exp] ';' // LVal '=' 'getint''('')'';' // LVal '=' 'getchar''('')'';' if (currentToken.type == TokenType.SEMICN) { //直接匹配，最喜欢的一集 tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.EXP; } else { pinToken(); LValNode lValNode = LVal(); if (currentToken.type == TokenType.ASSIGN) { nodes.add(lValNode); tokens.add(matchToken(TokenType.ASSIGN)); // LVal '=' 'getint''('')'';' // LVal '=' 'getchar''('')'';' if (currentToken.type == TokenType.GETINTTK) { tokens.add(matchToken(TokenType.GETINTTK)); tokens.add(matchToken(TokenType.LPARENT)); tokens.add(matchToken(TokenType.RPARENT)); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALGETINT; } else if (currentToken.type == TokenType.GETCHARTK) { tokens.add(matchToken(TokenType.GETCHARTK)); tokens.add(matchToken(TokenType.LPARENT)); tokens.add(matchToken(TokenType.RPARENT)); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALGETCHR; } else { // LVal '=' Exp ';' nodes.add(Exp()); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.LVALASSIGN; } } else { reflow(); ExpNode expNode = Exp(); nodes.add(expNode); tokens.add(matchToken(TokenType.SEMICN)); type = StmtType.EXP; } } } Node类——前端🔗中端的关键node类是语法分析中，语法树的结点，记录了语法分析的结果。是贯穿了语法分析、错误处理、中间代码生成的重要类。 对于每一个非终结符，都建立一个 node类。所有 node类都继承了抽象父类 Node。 Node规定了所有 node类都要实现的三个方法，用于在遍历语法树时执行相应的动作（即递归下降时的动作符号）： print()方法，透过遍历语法树，输出语法分析结果至文件。 visit()方法，透过遍历语法树，检查错误并记录。 buildIr()方法，透过遍历语法树，生成 llvm代码。 语义分析&amp;&amp;错误处理在当前前端阶段，我们要求生成的符号表还是过于简易，实际上，只对于错误处理有指导意义，可以说，我们的初步语义分析，就是为了错误处理准备的。 错误总论语法&amp;&amp;词法错误并不是所有的错误都是语义错误，常见的语义错误有“变量重命名，变量未定义”等，这些错误是可以通过词法分析和语法分析的，不会造成语法分析的错误。但是有些错误，是没有办法通过词法分析和语法分析的，有如下这些类 编号 类型 原因 a 非法符号 无法通过词法分析 i 缺少分号 无法通过语法分析 j 缺少右小括号 无法通过语法分析 k 缺少右中括号 无法通过语法分析 对于 A类错误，此类错误直接处理也不会导致语法，语义分析无法进行，故直接处理： 1234ErrorHandler.addError(new Error(ErrorType.a, lineNum)); tokenType = (inputText.charAt(pos) == '&amp;') ? TokenType.AND : TokenType.OR; str = (inputText.charAt(pos) == '&amp;') ? &quot;&amp;&amp;&quot; : &quot;||&quot;; tokenLength = 1; 而对于 i，j，k这些导致语法分析进行不下去的错误一定需要被“包容”，否则就坚持不到错误处理流程了。这种包容设置还有一种“补充”的意味在里面。但是最难的其实是缺失符号对于正常语法解析的影响，缺失符号会让原本就很困难的语法分析变得更加困难，这是因为语法分析本就需要依靠符号确定解析的分支，缺少符号会让这个过程变得模糊不清，这也是像 i, j, k 这类错误并不太多的原因，因为一旦多了，就会导致解析困难。 在三种缺失中，以缺少右中括号最为好处理，中括号意味着维度信息，只要有左中括号，那么右中括号一定是可以补上的，基本上无脑就可以了。 但是对于缺失分号和小括号，有可能造成解析分支的判断不当。所以需要进行回退处理（如果不回退的话就要改写文法，而且文法改的毫无语义意义）。 对于缺失分号，有无法区分赋值语句和表达式的问题。 1234567// 缺失前i + 1;a = b + c;// 缺失后i + 1a = b + c; 这就意味着没法通过前瞻（即“在分号前有一个等于号“）来确定是否是赋值语句。所以只能通过“尝试解析-判断 LAST”的方法进行。 对于 return 语句，可能也有这种现象，虽然应该被语义约束了 1234567// 缺失前return;a;// 缺失后return a; 对于 Callee 语句，也是这样（应该也被约束了），这里应该是同时缺失了小括号和分号 1234567// 缺失前f();a;// 缺失后f(a; 具体来看，我们结合前文 Parser中 nextSym的实现，统一处理： 12345678910111213141516171819//通过依次匹配理想语法成分来避免回溯 public Token matchToken(TokenType tokenType) { if (currentToken.type == tokenType) { Token tmp = currentToken; if (pos &lt; maxLength) { pos++; currentToken = tokens.get(pos); } return tmp; } else if (tokenType == TokenType.SEMICN || tokenType == TokenType.RPARENT || tokenType == TokenType.RBRACK) { int lineNum = tokens.get(pos - 1).lineNum; String str = tokenType.getStr(); ErrorType errorType = mismatchErrors.get(tokenType); ErrorHandler.addError(new Error(errorType, lineNum)); return new Token(str, lineNum, tokenType); } return null; } 语义错误处理 &amp;&amp; 语义分析错误处理的各个语义错误类型是相对独立的，彼此之间仅存在一定的联系，可以分别对每一种错误进行处理。在进行错误处理的过程中，我建立了栈式符号表。 符号Symbol我将符号的类型分为函数符号 FuncSymbol和变量符号 NumSymbol, CharSymbol，二者都继承一个父类 Symbol。 对于函数符号，我们额外记录其返回值类型以及形参的Symbol： 12345678public class FuncSymbol extends Symbol{ public enum FuncReturnType{ INT, VOID, CHAR; } private FuncReturnType returnType; private ArrayList&lt;NumSymbol&gt; params; // 参数符号列表 ...} 对于变量符号，由于其只可能是 int char 或者int char数组类型，因此我们只需要额外记录其维数。 1234567891011javapublic class NumSymbol extends Symbol{ private int dim; // 数组维数 0 1 private String ifArray;}public class CharSymbol extends Symbol { private int dim; // 数组维数 0 1 private String ifArray;} 符号表SymbolTable对于符号表，我使用栈式符号表。在设计之初，我是想要保留一个双向的类似树结构（其实也确实实现了，但是ir生成时没有采用该符号表），在使用栈式符号表后保留根节点，这样就可以留下该符号表。具体来说是把下图中的单向边换成双向边： 每个符号表中，都由 TreeMap来存储具体信息，fatherSymbolTable和 sonSymbolTables维护父子间的关系。 1234567891011121314public class SymbolTable { private final TreeMap&lt;String, Symbol&gt; symbolMap; //TreeMap提高检索速度 private final SymbolTable fatherSymbolTable; // 所属的父符号表 private final ArrayList&lt;SymbolTable&gt; sonSymbolTables; // 所有子符号表 private final Node node; // 由此语法树成分开始新建此符号表 private Integer regionIndex; public SymbolTable(SymbolTable fatherSymbolTable, Node node, Integer regionIndex) { this.symbolMap = new TreeMap&lt;&gt;(); this.fatherSymbolTable = fatherSymbolTable; this.sonSymbolTables = new ArrayList&lt;&gt;(); this.node = node; this.regionIndex = regionIndex; }} 符号表栈SymbolTableStack该类内封装有构建符号表、查符号表的各种方法，以及一个符号表栈 Stack。 该类内还有为 continue，break，return等对应错误而设置的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class SymbolTableStack { private Stack&lt;SymbolTable&gt; stack; private static TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; visitResults = new TreeMap&lt;&gt;(); private static Integer regionIndex = 1; private SymbolTableStack() { this.stack = new Stack&lt;&gt;(); } private static SymbolTableStack instance = new SymbolTableStack(); public static SymbolTableStack getInstance() { return instance; } // ====================== 栈操作======================= public static SymbolTable peek() { if (instance.stack.empty()) { return null; } return instance.stack.peek(); } public static void stackPush(SymbolTable symbolTable) { if (!instance.stack.empty()) { peek().addSon(symbolTable); } instance.stack.push(symbolTable); } public static void nodePush(Node node) { regionIndex++; stackPush(new SymbolTable(peek(), node, regionIndex)); } public static void pop() { instance.stack.pop(); } public static void addSymbolToPeek(Symbol symbol) { peek().addSymbol(symbol); Integer index = peek().getRegionIndex(); if (!visitResults.containsKey(index)) { ArrayList&lt;Symbol&gt; symbols = new ArrayList&lt;&gt;(); symbols.add(symbol); visitResults.put(index, symbols); //System.out.println(&quot;成功向符号表中添加元素 &quot; + index + &quot; &quot; + symbol); } else { visitResults.get(index).add(symbol); //System.out.println(&quot;成功向符号表中添加元素 &quot; + index + &quot; &quot; + symbol); } } public static TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; getVisitResults() { return visitResults; } public static void outputResult() { for (Map.Entry&lt;Integer, ArrayList&lt;Symbol&gt;&gt; entry : visitResults.entrySet()) { Integer key = entry.getKey(); ArrayList&lt;Symbol&gt; symbols = entry.getValue(); for (Symbol symbol : symbols) { System.out.println(key + &quot; - &quot; + symbol); } } } // ================= 栈查找 ================= // 检测栈顶符号表是否包含指定名称的元素 public static boolean peekHasSymbol(String name) { return peek().hasSymbol(name); } // 在整个栈内查找并返回第一个指定名称指定类型的元素 public static Symbol getSymbol(String name, SymbolType symbolType) { Symbol symbol; for (int i = instance.stack.size() - 1; i &gt;= 0; i--) { symbol = instance.stack.get(i).getSymbol(name, symbolType); if (symbol != null) { return symbol; } } return null; } // 检查整个栈内是否包含指定名称的元素 public static boolean stackHasSymbol(String name) { for (SymbolTable symbolTable : instance.stack) { if (symbolTable.hasSymbol(name)) { return true; } } return false; } public static boolean stackHasSymbolSameType(String name, SymbolType symbolType) { for (int i = instance.stack.size() - 1; i &gt;= 0; i--) { Symbol symbol = instance.stack.get(i).getSymbol(name, null); if (symbol != null) { if (symbolType == SymbolType.Const) { return symbol.type.isConst(); } else { return symbol.type == symbolType; } } } return false; } // ================= 循环工具 ================= // 记录当前所在的循环深度 private int loopDepth = 0; public static boolean inLoop() { return instance.loopDepth &gt; 0; } public static void enterLoop() { instance.loopDepth++; } public static void exitLoop() { instance.loopDepth = instance.loopDepth &gt; 0 ? instance.loopDepth - 1 : 0; } // ================= 函数工具 ================= // 记录当前是否在一个无返回值的函数内部 private boolean noReturn = false; public static boolean ifNoReturn() { return instance.noReturn; } public static void setIfReturn(boolean inVoidFunc) { instance.noReturn = inVoidFunc; }} 入栈新符号表的时机在遍历语法树的过程中，于 MainFuncDef，FuncDef以及 Stmt的 StmtType.BLOCK场合下，调用 SymbolTableStack中封装好的方法即可入栈新的符号表，例如： 1234567891011121314if (type == StmtType.BLOCK) { SymbolTableStack.nodePush(this); } public static void stackPush(SymbolTable symbolTable) { if (!instance.stack.empty()) { peek().addSon(symbolTable); } instance.stack.push(symbolTable); } public static void nodePush(Node node) { regionIndex++; stackPush(new SymbolTable(peek(), node, regionIndex)); } 添加新符号的时机在遍历语法树的过程中，于 MainFuncDef，FuncDef以及 Stmt的 StmtType.BLOCK场合下，读取到新符号（变量、常量、函数）时调用 SymbolTableStack中封装好的方法即可。 12FuncSymbol funcSymbol = new FuncSymbol(identToken.content, identToken.lineNum, this, returnType, params); SymbolTableStack.addSymbolToPeek(funcSymbol); 错误处理的逻辑错误记录方法在 error/ErrorUtil.java内封装有检查当前语境下错误并记录的方法。在遍历到语法树的特定位置时直接调用，即可进行错误处理。 记录错误的接口我将所有能够生成并记录错误的方法都统一放置在了 error/ErrorUtil.java里，调用其中的方法便可（判断并）记录错误，便于后期修改。例如： 12345678910111213/** * @param token 当前终结符 * @return noDuplicateError */ // 重定义 public static boolean checkDuplicateError(Token token) { boolean noDuplicateError = true; if (SymbolTableStack.peekHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.b, token.lineNum)); noDuplicateError = false; } return noDuplicateError; } 具体错误的处理方法 b 类错误 - 名字重定义 对于出现错误的四条文法，读取到 ident的创建时，调用： 12345678public static boolean checkDuplicateError(Token token) { boolean noDuplicateError = true; if (SymbolTableStack.peekHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.b, token.lineNum)); noDuplicateError = false; } return noDuplicateError; } c 类错误 - 未定义的名字 对于出现错误的三条文法，读取到 ident的引用时，调用： 123456789// 未定义 public static boolean checkUndefinedError(Token token) { boolean noUndefinedError = true; if (!SymbolTableStack.stackHasSymbol(token.content)) { ErrorHandler.addError(new Error(ErrorType.c, token.lineNum)); noUndefinedError = false; } return noUndefinedError; } d 类错误 - 函数参数个数不匹配 对于题目给出的文法，当 UnaryExp需要进行函数调用时，从符号表得到其形参个数，再读取其子节点的 funcRParamsNode的 expNodes的 size()，两者比较，如果不同，那就报错。 123456789101112131415else if (identToken != null) { if (ErrorUtil.checkUndefinedError(identToken)) { FuncSymbol symbol = (FuncSymbol) SymbolTableStack.getSymbol(identToken.content, SymbolType.Func); if (symbol == null) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (symbol.getParams().size() != getParaSize()) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (!checkParamsIllegal(symbol)) { ErrorHandler.addError(new Error(ErrorType.e, identToken.lineNum)); } } if (funcRParamsNode != null) { funcRParamsNode.visit(); } } e 类错误 - 函数参数类型不匹配 我们的变量类型只有2种：整型、一维数组。 123456789101112131415else if (identToken != null) { if (ErrorUtil.checkUndefinedError(identToken)) { FuncSymbol symbol = (FuncSymbol) SymbolTableStack.getSymbol(identToken.content, SymbolType.Func); if (symbol == null) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (symbol.getParams().size() != getParaSize()) { ErrorHandler.addError(new Error(ErrorType.d, identToken.lineNum)); } else if (!checkParamsIllegal(symbol)) { ErrorHandler.addError(new Error(ErrorType.e, identToken.lineNum)); } } if (funcRParamsNode != null) { funcRParamsNode.visit(); } } f 类错误 - 无返回值的函数存在不匹配的 return语句；g 类错误 - 有返回值的函数缺少 return语句 在 stmt的类型是 Return时，如果在函数当中但 expNode != null就报错。 h 类错误 - 不能改变常量的值 判断 &lt;LVal&gt;当中的 &lt;ident&gt;是否是常量即可。 m 类错误 - 在非循环块中使用 break 和 continue 语句 我们在符号表栈内维护了 loopCount，初始为 0，每次进入循环就加一，退出循环就减一。 在 stmt 的类型是 Break 或者 Continue 时，判断当前的 loopCount 是否为零即可，如果是，那就报错。 语义分析结果输出12345678910public void print() { TreeMap&lt;Integer, ArrayList&lt;Symbol&gt;&gt; visitResults = SymbolTableStack.getVisitResults(); for (Map.Entry&lt;Integer, ArrayList&lt;Symbol&gt;&gt; entry : visitResults.entrySet()) { Integer key = entry.getKey(); ArrayList&lt;Symbol&gt; symbols = entry.getValue(); for (Symbol symbol : symbols) { IO.write(IO.IOType.VISITOR, (key + &quot; &quot; + symbol), true, true); } } } LLVM IR生成LLVM简介LLVM是一种三地址码，即一条LLVM语句可以表示为如下形式： 1&lt;运算结果&gt; = &lt;指令类型&gt; &lt;操作数1&gt;, &lt;操作数2&gt; 观察这种指令可以发现，一条语句主要由三个要素组成： （1）操作数（2）指令类型（3）运算结果 现在我们需要将LLVM的这种语言特性，使用Java的类设计来表达： 在Java代码中，使用具体的类对象，来表示语句中的各个元素。（就像语法分析中使用各种 node类来表达各种语法元素一样） 具体措施是，通过遍历之前语法分析的语法树，透过结合属性翻译文法的递归下降的方式，来生成llvm的语法树。 对LLVM的简单理解我们将 llvm采用树的形式存储，根节点为 Module。 一个 module 中可以拥有两种顶层实体： Function 和 GlobalVariable 每个 Function 下都有若干基本块 BasicBlock 每个 BasicBlock下都有若干指令 instruction 在以上结构中，关键节点类的设计如下： 空心粗箭头表示类继承关系（User和Value类也是继承关系，图应该是画错了）。 实心细箭头表示聚合关系，从而形成树结构（例如每一个基本块 BasicBlock里有一条条指令 Instruction）。 1&lt;运算结果&gt; = &lt;指令类型&gt; &lt;操作数1&gt;, &lt;操作数2&gt; 操作数 Value类将操作数表示为一个类：Value，它表示能够作为操作数的对象。 例如如下乘法语句中： 1%2 = mul i32 %1, 2 按照上面的设计，%1和 2都是Value，在Java代码中都以Value类的形式存在。 操作数使用者 User类将指令的运算结果表示为一个类：User，它表示能够作为运算结果的对象，或者说是操作数的使用者。 例如如下乘法语句中： 1%2 = mul i32 %1, 2 按照上面的设计，%2是User，它 use了 %1和 2。%2在Java代码中以User类的形式存在。 User类继承Value类观察如下语句： 12%2 = mul i32 %1, 2%3 = add i32 %2, 3 乘法产生的 %2运算结果在下一条加法语句中作为了操作数。User类应该继承 Value类，这样后面的运算才能用到前面的结果。 指令 Instruction类为每一种指令类型都创建一个 Instruction指令类，这个指令类继承 User，既用来表示运算结果，也用来表示这一条指令。 如何理解”既用来表示运算结果，也用来表示这一条指令”？ 回到 User类的例子 1%2 = mul i32 %1, 2 在代码实现当中，%2是一个 Mul指令类对象。 它既表示 %2这个运算结果：Mul extends User，这意味着这个 Mul类对象可以表示运算结果；User extends Value，这意味着这个 Mul类对象还可以作为操作数。 又表示这条语句本身：Mul类是llvm语法树中，挂在BasicBlock下的一个节点，通过遍历语法树，并调用 toString()方法，即可从这个Mul类中取出目标代码 1234567891011public class Mul extends ArithmeticInstruction { public Mul(String name, BasicBlock parent, Value op1, Value op2) { super(name, parent, op1, op2); } @Override public String toString() { return getArithmeticString(&quot;mul&quot;); }} 再例如，如下中间代码，将其翻译为Java代码，可以是： 123456%1 = mul i32 1, 2%2 = mul i32 %1, %1// IrBuilder.buildxxx是封装了具体操作的工厂模式方法，// 其参数是操作数Value类，返回结果是计算结果Instruction类Mul mul1 = IrBuilder.buildMulInstruction(new ConstInt(1), new ConstInt(1))Mul mul2 = IrBuilder.buildMulInstruction(mul2, mul2) 常用的llvm指令罗列如下： LLVM IR 使用方法 简介 add &lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / sub &lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / mul &lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; / sdiv &lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 有符号除法 srem &lt;result&gt; = srem &lt;type&gt; &lt;op1&gt;, &lt;op2&gt; 有符号取余 icmp &lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 比较指令 and &lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 按位与 or &lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; 按位或 call &lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;) 函数调用 alloca &lt;result&gt; = alloca &lt;type&gt; 分配内存 load &lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt; 读取内存 store store &lt;ty&gt; &lt;value&gt;, ptr &lt;pointer&gt; 写内存 getelementptr &lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt;{, &lt;ty&gt; &lt;idx&gt;}* 计算目标元素的位置（数组部分会单独详细说明） phi &lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ... / zext..to &lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt; 将 ty 的 value 的 type 扩充为 ty2（zero extend） trunc..to &lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt; 将 ty 的 value 的 type 缩减为 ty2（truncate） br br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt; br label &lt;dest&gt; 改变控制流 ret ret &lt;type&gt; &lt;value&gt; , ret void 退出当前函数，并返回值 我在 LLVM IR 当中，给每条指令都写了一个类（Binary 指的是诸如 add sub mul 这样的二元指令），为了方便我对每种类型的指令进行管理和输出。 特殊的Value类：Function和BasicBlock类Function和 BasicBlock类也可以作为操作数。 例如调用指令：&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;fnptrval&gt;(&lt;function args&gt;)的实现上，我们直接将function作为了一个操作数，用来构建Call指令。 1234567891011Function function = (Function) IrSymbolTableStack.getSymbol(identToken.content); assert function != null; ArrayList&lt;Value&gt; argRValues = new ArrayList&lt;&gt;(); // 实参列表IrFactory.synValue = IrBuilder.buildCallInstruction(function, argRValues, IrFactory.curBlock); if (IrFactory.synValue.getType() instanceof CharType) { if (IrFactory.synValue instanceof ConstChar) { IrFactory.synValue = new ConstInt(32, ((ConstChar) IrFactory.synValue).getValue()); } else { IrFactory.synValue = IrBuilder.buildZextInstruction(IrFactory.synValue, IrFactory.curBlock); } } 根节点：Module类如同编译单元一样的存在，LLVM IR 文件的基本单位称为 module，我们的实验只有单 module。 内存 SSAllvm 是 SSA 形式的，但是在没有经过 mem2reg 的时候，SSA 是内存形式的，也就是说，对于每个变量，只要在定义他的时候，为他在内存中划分空间存入，在使用他的时候在取出来，这样就可以达到 SSA 的效果。这是因为 SSA 只要求我们不能改变一个已经定义的值，改变内存的内容显然并不违法 SSA。 这会导致当我们提到（也就是查询）一个局部变量的时候，其实是从符号表中取出来的是它的指针，这个过程一般发生在 LVal。一般我们会对变量干两件事情，读变量和写变量和做实参。对于读变量，一般发生在 LVal 作为 PrimaryExp 的时候发生，此时需要在 PrimaryExp 中对其进行 Load，而写变量一般发生在 LVal 在 AssignStmt 和 InStmt 中，只需要用 Store 将其写入即可。做实参要单独挑出来讲，是因为它的逻辑是与 C 需要保持一致的，他是有指针类型的，这就要求我们对他进行单独的处理。这就是内存式 SSA 的基本逻辑。 符号表正如前面所述，因为 LLVM IR 是 SSA 形式的，所以符号表中存的内容也和 C 中理解并不相同，比如说对于 1234f(){ int a = 2;} 在 C 中，我们会认为 a 在符号表中是一个 int，但是在 llvm 中，为了满足 SSA ，所以在符号表中，a 中对应的是一个指向 int 的指针，如果想要获得 a 中的内容，那么就需要使用一个 load 指令 。这就造成了某种逻辑的不一致性。更可悲的是，C 中还有 const 的概念。 12345f(){ const a = 3; int b[a] = {1, 2, 3};} 是不是可以直接也用一个指针去存他，然后用一个 load 访存呢？大概是不行的，因为下面那个语句会用到 alloca，虽然我不确定 alloca 是否可以动态分配，但是如果是下面这种，就肯定不行了 123456const a = 3;int b[a] = {1, 2, 3};f(){ } 在全局部分是没有办法使用 load 指令的，尤其是我们一般面对上面的情况，会要求求出 b 的维度信息，如果维度信息不是 3 ，而是一个 load，显然就无法求出了，这就导致面对这种情况，我们必须存一个常量到符号表中，这就更要求我们在解析的时候，知道我么你啥时候存的是常量，啥时候存的是指针，这需要额外的继承属性（也是最重要的继承属性）canCalValueDown ，其实这个属性意味着一种 “常量读” 。 符号的定义符号的定义本质是填写符号表和定义，我本来打算总结起来再写，但是感觉太冗杂了，很难理出一个头绪，所以就变成了罗列。 全局单常量如果是一个单常量，那么只需要把 ConstInitVal 求解出来，会得到一个 int ，然后在符号表中，只需要存储一个 ConstInt 就可以了。 局部单常量与全局单常量相同，依然是将 ConstInt 存入到符号表中，并没有任何问题。 全局常量数组对于常量数组的初始值，我们要求是可以在编译器求值的，所以它的每个元素的初始值一定是可以被求值的，当我们求出来它的值以后，没有办法直接在符号表中存入它的值，这是因为我们会进行类似于变量的访问： 12345678const int a[2] = {1, 2};int main(){ int i = 2; a[i]; return 0;} 这样我们是没有办法在编译时就求出 a[i] 的，所以 a 必须提供变量访问形式，这就要求他必须被当成一个全局变量，所以他确实是一个全局变量，我们在符号表中存入的其实是一个全局变量，因为在 llvm 中，全局变量本质是一个指向其内容的指针，所以其实符号表中存入的是一个指针。但是也需要注意的是，其实符号表中 a 这个东西对应了两个 Value ，一个是 GlobalVariable ，另一个是 GlobalVariable.getInitValue() 获得的 ConstArray ，这样是极其有必要的，因为对于这种情况 12345678const int a[2] = {1, 2};const int b = a[1];int main(){ int i = 2; a[i]; return 0;} b 的初始值没法使用 load 访问，所以只能用常量形式获得，所以依然是需要 ConstArray 的。 局部常量数组局部常量数组与全局常量数组类似，因为它也具有“变量”的访问形式，所以也不能仅仅在符号表中存入一个 ConstArray，而是需要利用 Alloca 分配一块内存，然后利用 gep, store （这么看比全局常量数组还有麻烦一些）将这片内存填写成正确的值。同时依然需要注意，就是我们还是需要在 Alloca 里面存入一个 ConstArray 的，这是因为我们依然需要像一个“常量”一样读取这个局部常量数组，比如说在一些常量初始化或者维度信息方面，所以还是需要存入 ConstArray 的。 全局单变量需要当成一个 GlobalVariable 处理，这是因为必须给这个单变量开辟空间，这是因为我们有可能修改这个值。 全局变量数组也需要当成一个 GlobalVariable 处理，似乎这里保证了初始值一定是常量。 全局变量声明中指定的初值表达式必须是常量表达式。 局部单变量用 Alloca 处理，最后在符号表中存入的是一个指针。 局部变量数组用 Alloca 处理，但是此时的 Alloca 是不需要像局部常量数组一样在里面存储一个 ConstArray 的，这是因为第一没有意义，第二不一定能办到。 符号的使用写变量写一个变量一般都是对于 LVal 进行操作，并不是可以写内存中的所有东西，这是因为常量是不允许写操作的，所以对于 LVal 获得的东西一定是一个指针（LVal 的本质就是在符号表中按照符号查询出对应的 Value ），然后利用 Store 指令就可以将内容写入，“写变量”这个过程本身十分简单。 比较复杂的是如何处理 LVal ，首先需要明白，对于 LVal.builIr 可以将其分为两类，一类是 canCalValue ，也就是常量形式的读（显然没有常量写），另外就是没有办法常量读的 build，对于第二种情况，除了在符号表中找到找到指针，对于数组指针，还涉及一些 gep 操作以找到正确的数组元素。 读变量读变量用于表达式当一个 LVal 用于表达式的时候（也就是参与运算的时候），可以分成两个情况讨论，如果是一个常量，那么就直接用就行了；如果是一个指针，那么就需要将其 Load 出来使用。 读变量用于实参实参和表达式计算不同在于，他可能是一个指针。而因为 C 的指针与 llvm 是不同的，比如说同样一个一维数组 a[2] ，在 C 中为 int* ，而在 llvm 中，却是 [2 x i32]* 。而当参数为 int a[] 的时候，又要求 llvm 划为 int*，这就说需要控制 gep 的数量进行降维，同时对于为指针的变量，也不能一味的 load，这样有可能将原本的指针实参给 Load 出一个整型来。 短路求值对于短路求值，并不是一件可有可无的事情，因为对于 1if (1 == 2 &amp;&amp; f()) 如果没有短路求值，那么 f() 就会被指令，如果 f() 是一个有副作用的函数（也就是对内存写了），那么就会导致 bug 的出现，所以短路求值是必要的。 实现短路求值就是将 1if (cond1 &amp;&amp; cond2) 变成 12if (cond1) if (cond2) 这样的结构，将 1if (cond1 || cond2) 变成 123456789if (cond1) { // then-block} else { if (cond2) { // then-block } else { // else-block }} 对于多个条件，只要确定好优先级，递归处理即可。 控制结构控制结构就是通过制造 BasicBlock 来对数据流进行控制。 分支ConditionNode 有两种可能，有无 else 决定了到底是 2 个 BasicBlock 或者是 3 个 BasicBlock。对于没有 else 的分支结构，只用一个三参数的 Br 就可以解决，对于有 else 的结构，只需要将 Br 的 falseBlock 调整为 else 对应的块即可。 循环需要制作出 3 个块，分别为 condBlock, bodyBlock, nextBlock ，其中 condBlock 选择跳转到 bodyBlock 或者是 nextBlock （这个部分由 LOrExp, LAndExp 自动完成 ），bodyBlock 会无条件跳转到 condBlock。 Break &amp; Continue &amp; Return这些指令面对的最大问题是为了满足基本块的定义，与这些指令所处同一基本块并位于这些指令之后的指令不应该得到翻译。我们可以直接做一个新的块，让其后的指令都依附与这个块，而入口块并没有到达这个块的方式，这样就完成了对其后指令的忽略。 此外，break, continue 都需要确定跳转的目标，break 会跳转到 nextBlock ，而 continue 会跳转到 condBlock ，但是因为循环存在嵌套结构，所以不同层的 break, continue 需要跳转到不同的层。所以在全局用一个栈维护该结构，如下所示 1234567891011/** * 处理多重循环中的continue， * 栈顶的loopEndBlock即是当前层Continue跳转的对象 */ public static Stack&lt;BasicBlock&gt; loopEndBlockStack = new Stack&lt;&gt;(); /** * 处理多次循环中的break * 栈顶的endBlock即是当前层break跳转的对象 */ public static Stack&lt;BasicBlock&gt; endBlockStack = new Stack&lt;&gt;(); 在循环的时候，进行出入栈操作 12345678IrFactory.loopEndBlockStack.push(loopEndBlock); IrFactory.endBlockStack.push(endBlock); // 解析Stmt ((StmtNode) nodes.get(nodePos)).setStmtReturnType(this.stmtReturnType); nodes.get(nodePos).buildIr(); // 完成当前解析，弹栈 IrFactory.loopEndBlockStack.pop(); IrFactory.endBlockStack.pop(); 在 break 中： 12// 强制跳转至endBlock IrBuilder.buildBrInstruction(IrFactory.endBlockStack.peek(), IrFactory.curBlock); 在 continue 中 12// 强制跳转至endLoopBlock IrBuilder.buildBrInstruction(IrFactory.loopEndBlockStack.peek(), IrFactory.curBlock); 具体架构设计IrBuilder类：指令的工厂IrBuilder类是中间代码的入口，同时也封装有构建 llvm元素的工厂模式方法。 举例来说，我们现在正要取出一个指针类型变量所指空间中的内容，可以构建一条 Load指令（当然如果是数组就需要GEP指令了），并将其插入当前所处的基本块。可以如此做： 1234567891011121314151617181920212223242526272829303132// LValNode.java，其对应文法LVal → Ident {'[' Exp ']'}，是指针的发祥地Value fParamValue = IrBuilder.buildLoadInstruction(lvalValue, IrFactory.curBlock); if (expNode == null) { IrFactory.synValue = fParamValue; } else { expNode.buildIr(); if (IrFactory.synValue.getType() instanceof CharType) { if (IrFactory.synValue instanceof ConstChar) { IrFactory.synValue = new ConstInt(32, ((ConstChar) IrFactory.synValue).getValue()); } else { IrFactory.synValue = IrBuilder.buildZextInstruction(IrFactory.synValue, IrFactory.curBlock); } } Value indexValue = IrFactory.synValue; Value ptrVal = IrBuilder.buildGetElementPtrInstruction(fParamValue, indexValue, IrFactory.curBlock); if (IrUtil.getPointingTypeOfPointer(fParamValue) instanceof ArrayType) { // System.out.println(&quot;can't delete&quot;); ptrVal = IrBuilder.buildRankDownInstruction(ptrVal, IrFactory.curBlock); } IrFactory.synValue = ptrVal;// IrBuilder.java/** * 构建加载指令 * @param pointer 要加载的地址，从这个地址处读取操作数 * @return 完成加载的Value */ public static Load buildLoadInstruction(Value pointer, BasicBlock parent) { Load load = new Load(getName(), parent, pointer); parent.addInstruction(load); return load; } IrFactory：递归下降的上下文信息刚刚我们提到，要进行基于属性翻译文法的递归下降。既然是属性翻译文法，势必涉及到综合属性（synthesized attribute)的向上传递，以及继承属性（inherited attribute）的向下传递。 得益于递归下降的方法，我们可以直接在 node类内，通过父子 node间直接调用对方的相关 setter或者 getter来粗暴地实现信息传递。 但如果我们传递的链条很长呢？譬如我们在一个 LVal内的信息，要经过好长好长的路，才能抵达真正需要该信息的 ConstExp，这时候如果还要写那么多 setter，未免也过于笨。 考虑到只有综合属性会出现这种长线的传递，我们可以在 Irc里直接记录全局的，正在传递的综合属性（们）： 12345678910111213//=========================== 综合属性 =================================/** * Value类型列表的综合属性 up向上传递 */public static ArrayList&lt;Value&gt; synValueArray = null;/** * Value类型的综合属性 up向上传递 */public static Value synValue = null;/** * int类型的综合属性 up向上传递 */public static int synInt = -114514; 中间代码的构建过程，是字面意义上拆东墙建西墙的过程，即在根据文法递归下降 扫描语法分析结果的同时，在另一边逐步（用动作符号）搭建起另一个 llvm的体系。 既然是同步在扫描两个体系，就应当有两组指针来记录扫描进度。语法分析的扫描进度（由递归下降保证外，还有当前是否在扫描常量表达式，是否在扫描函数实参，是否正在经历循环），llvm的构建进度（即当前在搭建哪个函数，哪个基本块，）都应当得到记录： 1234567891011121314151617181920212223242526272829303132/** * 当前所在基本块 */ public static BasicBlock curBlock = null; /** * 当前所在函数 */ public static Function curFunction = null; /** * 当前是否正在计算 无变量常数表达式 * 如果是，那么综合属性只需要传递synInt，且计算情况有所减少 */ public static boolean isBuildingConstExp = false; /** * 当前是否在进行全局变量的初始化 */ public static boolean isBuildingGlobalInit = false; /** * 当前是否正在构建一个int类型的实参 * 如果是，但是当前解析到的却是int*类型，那么需要load */ public static boolean isBuildingPointerRParam = false; /** * 处理多重循环中的continue， * 栈顶的loopEndBlock即是当前层Continue跳转的对象 */ public static Stack&lt;BasicBlock&gt; loopEndBlockStack = new Stack&lt;&gt;(); /** * 处理多次循环中的break * 栈顶的endBlock即是当前层break跳转的对象 */ public static Stack&lt;BasicBlock&gt; endBlockStack = new Stack&lt;&gt;(); llvm元素llvm元素主要放置在 ir/values内。 该类主要存储了 llvm体系下，该元素的要素及其相应的 getter和 setter。 此外，所有 llvm元素都实现了 buildMips()方法（及辅助方法），用于后续构建 mips体系。 因此，llvm元素类是贯穿了 llvm初步生成，中端的 mem2reg重构，mips初步生成的重要类。 举例来说，我们在基本块 BasicBlock类内，会记录这样的一些信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 前驱与后继块 */ private final HashSet&lt;BasicBlock&gt; preBlocks = new HashSet&lt;&gt;(); private final HashSet&lt;BasicBlock&gt; sucBlocks = new HashSet&lt;&gt;();// ==================支配分析==================== /** * 支配者块 */ private final ArrayList&lt;BasicBlock&gt; domers = new ArrayList&lt;&gt;(); /** * 直接支配的基本块 */ private final ArrayList&lt;BasicBlock&gt; idomees = new ArrayList&lt;&gt;(); /** * 直接支配基本块 */ private BasicBlock Idomer; /** * 在支配树中的深度 */ private int domLevel; /** * 支配边际，即刚好不被当前基本块支配的基本块 */ private final HashSet&lt;BasicBlock&gt; dominanceFrontier = new HashSet&lt;&gt;(); public ArrayList&lt;BasicBlock&gt; getDomers() { return domers; } /** * 当前块是否是另一个块的支配者 */ public boolean isDominating(BasicBlock other) { return other.domers.contains(this); } public ArrayList&lt;BasicBlock&gt; getIdomees() { return idomees; } public void setIdomer(BasicBlock idomer) { Idomer = idomer; } public void setDomLevel(int domLevel) { this.domLevel = domLevel; } public int getDomLevel() { return domLevel; } public HashSet&lt;BasicBlock&gt; getDominanceFrontier() { return dominanceFrontier; } public BasicBlock getIdomer() { return Idomer; } // =================== 循环分析 ====================== /** * 当前块直属的循环 */ private Loop loop = null; /** * 获得循环深度 * 如果不在循环中，则深度为 1 * * @return 循环深度 */ public int getLoopDepth() { if (loop == null) { return 0; } return loop.getLoopDepth(); } public void setLoop(Loop loop) { this.loop = loop; } public Loop getLoop() { return loop; } 再议 SSA现在再看回SSA： 当涉及到分支语句时，SSA会遇到一些问题，以下面这个循环为例： 1234567891011int main(){ int i = 0; i = getint(); int a = 1; a = getint(); for(; i &lt; 10; i = i + 1){ i = i + 2; a = a + 3; } return 0;} 我们会发现，对于循环的归纳变量，其注定会有两处赋值。因此同样对于 i和 a，我们需要再来一个 i1和 a1来放置这第二个赋值。 那么问题来了，在 i1和 a1的汇聚点，到底该采取哪个赋值？这时候就必须用到 phi指令。 phi 指令这个指令能够根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值。 1&lt;result&gt; = phi &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], [&lt;val1&gt;, &lt;label1&gt;] ... 有了 phi，我们就可以写出代码： 1234567891011121314151617181920define dso_local i32 @main() {b0: %i3 = call i32 @getint() %i7 = call i32 @getint() br label %b9b9: %p25 = phi i32 [ %i3, %b0 ], [ %i16, %b11 ] %p24 = phi i32 [ %i7, %b0 ], [ %i19, %b11 ] %i14 = icmp slt i32 %p25, 10 br i1 %i14, label %b10, label %b12b10: %i19 = add i32 %p24, 2 %i22 = add i32 %p25, 3 br label %b11b11: %i16 = add i32 %i22, 1 br label %b9b12: ret i32 0} 但实际上，phi指令的构建有亿点点复杂，这也太难写了！如果有一个能够摆脱SSA限制的办法就好了。 这就要用到我们之前提到的内存SSA： 这种生成存取内存的 llvm有四个特点： 每个局部变量都变为了栈上分配的空间（变量在符号表中存的其实是其 alloca 指令） 每次对局部变量的读都变成了从内存空间中的一次读（在 LValNode中实现，这也是为什么这里是指针的故乡之一！） 每次对局部变量的写都变成了对内存的一次写（每次更新一个变量的值都变成了通过 store 对变量所在内存的写） 获取局部变量的地址等价于获取内存的地址 需要进行的主要操作有： 局部变量定义时： alloca（分配变量的栈空间，返回指向该空间的指针） 将 alloca记录进入符号表。 store（给变量赋值，即向指针所指空间内进行写） 局部变量使用时： LVal: 查符号表获得指定局部变量或形参的 alloca指针 PrimaryExp: 对于LVal传上来的 alloca指针，进行 load处理 函数形参接收时： 特别地，函数的形参也类似于局部变量，我们也要将其处理为SSA形式，在栈上分配空间并赋值以代之，否则还是会遇到我们上一节分析出来的问题！ FuncFParamNode：读取形参的类型、名称，创建形参的Value FuncFParamsNode： 对于每一个形参，都进行 alloca，store，其中 store的内容就是刚创建的形参的Value。符号表中存入的也是 alloca对应的value ConstExp的处理与“后门”常量传播在我们的文法当中，有这样的声明： 常量表达式 ConstExp ConstExp -&gt; AddExp 中使用的 ident 必须是常量 何为常量？即能够在编译阶段就确定值的量，包括了常量标识符与立即数。对于常量，我们可以在编译阶段就计算出常量表达式的值，以及将常量标识符替换为其值。 为此，我们在 IrFactory里设置有字段，在 Exp系的 buildIr内，构建常量时的分类讨论的方式有所不同，且由于能够计算出int类型具体值，我们只需要进行 synInt综合属性的传递。 常量分为数组常量和非数组常量，其行为有所不同： int常量 数组常量 是否在llvm代码中显式声明 否 与普通数组变量一致，采用alloca,store 在 ConstExp下 直接求出int, char值 直接求出指定元素的int值 非 ConstExp下 直接求出int, char值 与普通数组变量一致，采用gep，load Mips 生成在llvm中，我们已经将源代码转换成了很接近中间代码的形式了：我们划分并生成了基本块，生成了几乎能一等一转化为mips的llvm指令。因此在目标代码的初步生成的过程中，我们的关注点主要在于存储管理、指令的等价翻译。 MipsBuilder：指令的工厂类在MipsBuilder中封装有构建各种指令、构建操作数的工厂模式方法。 例如构建一条 add指令并加入指定的 MipsBlock： 12345678910/** * 构建双操作数指令 * * @param type 指令类型 */ public static MipsBinary buildBinary(MipsBinary.BinaryType type, MipsOperand dst, MipsOperand src1, MipsOperand src2, BasicBlock irBlock) { MipsBinary binary = new MipsBinary(type, dst, src1, src2); MipsFactory.irBlock2MipsBlock(irBlock).addInstruction(binary); return binary; } MipsFactory：记录 llvm成分到 mips成分的映射我们是在llvm的成分类中进行的mips生成，因此需要将llvm成分与mips成分进行映射。 1234567891011121314151617181920212223242526272829/** * 获取ir函数对象 对应的 mips函数对象 * * @param irFunction ir函数对象 * @return mips函数对象 */ public static MipsFunction irFunction2MipsFunction(Function irFunction) { return functionMap.get(irFunction); } /** * 获取ir基本块对象 对应的 mips基本块对象 * * @param irBlock ir基本块对象 * @return mips基本块对象 */ public static MipsBlock irBlock2MipsBlock(BasicBlock irBlock) { return blockMap.get(irBlock); } /** * 获取ir Value对象 对应的 mipsOperand对象 * * @param irValue ir Value对象 * @return mipsOperand对象 */ public static MipsOperand irValue2MipsOp(Value irValue) { return opMap.get(irValue); } llvm的成分类：mips生成的主要场所通过遍历 llvm的树形结构来生成 mips，遍历在 ir/values下的各个value类进行，他们都实现了父类 Value的 buildMips()方法。 backend/instructions: Mips指令类指令类都继承了 MipsInstruction类，该类内有 src操作数和 dst操作数的相应管理方法，包括 use，def的记录，用于活跃变量分析，以及后续寄存器分配时，对虚拟寄存器进行查询、替换。 backend/operands: 操作数类该包内的类均可以作为 mips指令的操作数，具体来说有立即数、虚拟寄存器、物理寄存器、标签。 物理寄存器的相关配置在 RegType枚举类中，记录了物理寄存器的编号、名称、何者需要在函数调用时保存、何者能够作为全局寄存器分配等信息。 构建流程带有虚拟寄存器的mips的总体构建流程如下： 构建.data段构建.data段主要是在翻译 llvm的全局变量元素 GlobalVariable。 先前在 llvm生成过程中，我们将需要 printf输出的字符串重新分配为了全局常量字符串，因此这里全局变量共有三类：字符串、int变量、int数组。依次构建 mipsGlobalVariable，然后加入 MipsModule即可。 123456789101112131415161718192021222324252627282930313233343536373839404142@Override public void buildMips() { MipsGlobalVariable mipsGlobalVariable = null; // 无初始值错误 if (initValue == null) { System.out.println(&quot;[buildMips] GlobalVariable：initValue == null&quot;); } // 未初始化的全局数组 else if (initValue instanceof ZeroInitializer) { mipsGlobalVariable = new MipsGlobalVariable(getName(), initValue.getType().getSize()); } // 常量字符串 else if (initValue instanceof ConstString) { mipsGlobalVariable = new MipsGlobalVariable(getName(), ((ConstString) initValue).getContent()); } // int变量 else if (initValue instanceof ConstInt) { mipsGlobalVariable = new MipsGlobalVariable(getName(), new ArrayList&lt;&gt;() {{ add(((ConstInt) initValue).getValue()); }}, MipsGlobalVariable.GVType.Int); } else if (initValue instanceof ConstChar) { mipsGlobalVariable = new MipsGlobalVariable(getName(), new ArrayList&lt;&gt;() {{ add(((ConstChar) initValue).getValue()); }}, MipsGlobalVariable.GVType.Char); } // int | Char数组 else if (initValue instanceof ConstArray) { ArrayList&lt;Integer&gt; inits = new ArrayList&lt;&gt;(); if (((ConstArray) initValue).getElements().get(0).getType() instanceof IntType) { for (Constant element : ((ConstArray) initValue).getElements()) { inits.add(((ConstInt) element).getValue()); } mipsGlobalVariable = new MipsGlobalVariable(getName(), inits, MipsGlobalVariable.GVType.Int); } else { for (Constant element : ((ConstArray) initValue).getElements()) { inits.add(((ConstChar) element).getValue()); } mipsGlobalVariable = new MipsGlobalVariable(getName(), inits, MipsGlobalVariable.GVType.Char); } } MipsModule.addGlobalVariable(mipsGlobalVariable); } 为所有Block和Function创建Mips对象，并映射到llvm的相应对象没有太多可说的，作用主要是方便在后续遍历语句时，能够方便地引用函数和基本块（用于call、br等llvm指令的翻译） 123456789101112131415161718192021222324252627282930/** * 将中间代码的函数和基本块对象: * 1.构建mips里的相应对象 * 2.加入Module * 3.信息存储到mips对象里 */ private void mapFunctionBlockIr2Mips() { // 遍历所有函数 for (Function irFunction : functions) { // 构建函数对象 MipsFunction mipsFunction = new MipsFunction(irFunction.getName(), irFunction.isLibFunc()); MipsFactory.addFunctionMapping(irFunction, mipsFunction); MipsModule.addFunction(mipsFunction); // 构建基本块对象 ArrayList&lt;BasicBlock&gt; blocks = irFunction.getBasicBlocks(); for (BasicBlock irBlock : blocks) { MipsBlock mipsBlock = new MipsBlock(irBlock.getName(), irBlock.getLoopDepth()); MipsFactory.addBlockMapping(irBlock, mipsBlock); } // 记录mipsBlock的前驱块信息, 前驱块当然也是mipsBlock for (BasicBlock irBlock : blocks) { MipsBlock mipsBlock = MipsFactory.irBlock2MipsBlock(irBlock); for (BasicBlock irPreBlock : irBlock.getPreBlocks()) { mipsBlock.addPreBlock(MipsFactory.irBlock2MipsBlock(irPreBlock)); } } } } 遍历 llvm的树形结构依序遍历 llvm的所有函数、所有基本块、所有指令，进行翻译。 具体构建难点实际上，将 LLVM指令挨个翻译成 MIPS指令并不困难，我们重点讲一下翻译成 Mips时函数调用的部分，这是一大难点，至于寄存器分配则放到优化部分详述。 Call：参数传递Call的作用是调用函数，理所当然地，在mips中需要我们手动进行实参的传递，同时记录 MipsCall指令对于寄存器的修改（即def）。 对于前四个参数，保存在 a0-a3里即可。对于更多的参数，需要保存在栈上。 调用函数在调用者处的准备工作，都由Call进行翻译。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Override public void buildMips() { MipsBuilder.buildComment(this.toString(), getParent()); MipsBlock mipsBlock = MipsFactory.irBlock2MipsBlock(getParent()); MipsFunction mipsFunction = MipsFactory.irFunction2MipsFunction(function); // 先构建出call指令，后续要记录该指令用到的A寄存器 // ！这也是唯一一次使用野生未封装的new MipsInstruction MipsInstruction call; // 内建函数，需要宏调用 if (function.isLibFunc()) { call = new MipsMacro(mipsFunction.getName()); // 系统调用必然改变 v0, v0加入def call.addDefReg(MipsRealReg.V0); // TODO: addDefReg 双参数修改为单参数 } // 非内建函数，直接构建jal指令即可 else { call = new MipsCall(mipsFunction); } // 进行传参, 遍历所有irValue参数 int argc = getArgs().size(); for (int i = 0; i &lt; argc; i++) { Value irArg = getArgs().get(i); MipsOperand src; // 前四个参数存储在a0-3内 if (i &lt; 4) { src = MipsBuilder.buildOperand(irArg, true, MipsFactory.curIrFunction, getParent()); MipsMove move = MipsBuilder.buildMove(new MipsRealReg(&quot;a&quot; + i), src, getParent()); // 加入use，保护寄存器分配时不消除move call.addUseReg(move.getDst()); } // 后面的参数先存进寄存器里，再store进内存 else { boolean isByte = irArg.getType() instanceof CharType; // 要求存入寄存器 src = MipsBuilder.buildOperand(irArg, false, MipsFactory.curIrFunction, getParent()); // 存入 SP - 4 * nowNum 处 MipsImm offsetOperand = new MipsImm(-(argc - i) * 4); MipsBuilder.buildStore(src, MipsRealReg.SP, offsetOperand, getParent(), isByte); } } // 栈的生长 if (argc &gt; 4) { // 向下生长4 * allNum: SP = SP - 4 * allNum MipsOperand offsetOperand = MipsBuilder.buildImmOperand(4 * (argc - 4), true, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildBinary(MipsBinary.BinaryType.SUBU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent()); } // 参数准备妥当后，再执行jal指令 mipsBlock.addInstruction(call); // 这条语句执行完成的场合，恰是从函数中返回 // 栈的恢复 与生长相反，做加法即可 if (argc &gt; 4) { MipsOperand offsetOperand = MipsBuilder.buildImmOperand(4 * (argc - 4), true, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildBinary(MipsBinary.BinaryType.ADDU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent()); } // 因为寄存器分配是以函数为单位的，所以相当于 call 指令只需要考虑在调用者函数中的影响 // 那么 call 对应的 bl 指令会修改 lr 和 r0 (如果有返回值的话) // 此外，r0 - r3 是调用者保存的寄存器，这会导致可能需要额外的操作 mov ，所以这边考虑全部弄成被调用者保存 for (int i = 0; i &lt; 4; i++) { call.addDefReg(new MipsRealReg(&quot;a&quot; + i)); } // 非内建函数需要保存返回地址 ra if (!function.isLibFunc()) { call.addDefReg(MipsRealReg.RA); } // 处理返回值 // 调用者应当保存 v0，无论有没有返回值 ValueType returnType = function.getReturnType(); call.addDefReg(MipsRealReg.V0); // 带有返回值，则需要记录该返回值 if (!(returnType instanceof VoidType)) { MipsOperand dst = MipsBuilder.buildOperand(this, false, MipsFactory.curIrFunction, getParent()); MipsBuilder.buildMove(dst, MipsRealReg.V0, getParent()); } } MipsFunction：保存现场MipsFunction是Mips函数对象。 在与Call的关系中，MipsFunction是被调用的一方，由MipsFunction负责保存现场。 如下方法能够记录在本函数内有改动（def）的寄存器，同时计算栈帧大小。这些寄存器在返回调用者后可能有改变，需要保存在栈帧内。 1234567891011121314151617181920212223242526272829303132333435363738/** * 栈上的空间从上到下依次为： * 1.调用者保存的寄存器 * 2.其他alloca * 3.参数alloca */ public void rebuildStack() { // 遍历下属所有语句，记录所有用过的寄存器，作为函数调用前要保存的现场 for (MipsBlock block : blocks) { for (MipsInstruction instruction : block.getInstructions()) { // 保存写过的寄存器(的类型) for (MipsOperand defReg : instruction.getDefRegs()) { if (defReg instanceof MipsRealReg) { RegType regType = ((MipsRealReg) defReg).getType(); if (RegType.regsNeedProtection.contains(regType)) { regsNeedSaving.add(regType); } } else { System.out.println(&quot;[MipsFunction] defReg中混入了非物理寄存器！&quot;); } } } } // 需要分配的用于保存现场的空间 int stackRegSize = 4 * regsNeedSaving.size(); System.out.println(stackRegSize); for (RegType regType : regsNeedSaving) { System.out.println(regType); } // 总的空间大小：alloca空间 + 保存现场的空间 totalStackSize = stackRegSize + allocaSize; // 更新先前记录的 保存在栈上的参数 的位移 for (MipsImm argOffset : argOffsets) { int newOffset = argOffset.getValue() + totalStackSize; argOffset.setValue(newOffset); }// System.out.println(&quot;重建函数栈&quot; + getName() + &quot;, stackRegSize:&quot; + stackRegSize + &quot;, allocaSize:&quot; + allocaSize); } 保存现场的具体代码则直接放在了 MipsFunction的打印处，实际上没有加入指令序列。 123456789101112131415161718192021222324252627282930313233343536373839/** * 需要输出： * 函数 label * 保存被调用者寄存器 * 移动栈指针 sp * 基本块的mips代码 */ @Override public String toString() { if (isLibFunc) { return &quot;&quot;; } StringBuilder sb = new StringBuilder(); sb.append(name).append(&quot;:\\n&quot;); // 非主函数需要保存寄存器 if (!name.equals(&quot;main&quot;)) { // 保存现场 int stackOffset = -4; for (RegType regType : regsNeedSaving) { // 保存位置：-stackOffset($SP) sb.append(&quot;\\t&quot;).append(&quot;sw\\t&quot;).append(regType).append(&quot;,\\t&quot;) .append(stackOffset).append(&quot;($sp)\\n&quot;); // 继续向下生长 stackOffset -= 4; } } // $SP = $SP - totalStackSize if (totalStackSize != 0) { sb.append(&quot;\\taddiu\\t$sp,\\t$sp,\\t&quot;).append(-totalStackSize).append(&quot;\\n&quot;); }// System.out.println(blocks); // 生成基本块的mips for (MipsBlock block : blocks) { sb.append(block); } return sb.toString(); } MipsRet：恢复现场MipsRet是Mips的返回指令对象，由llvm的Ret指令直接翻译而来。 Ret对象会记录其所属的MipsFunction，以方便地取用寄存器的保存信息。 同样地，恢复现场的具体代码则直接放在了 MipsRet的打印处，实际上没有加入指令序列。 123456789101112131415161718192021222324252627@Override public String toString() { StringBuilder sb = new StringBuilder(); int stackSize = function.getTotalStackSize(); // 返回前将SP复位 if (stackSize != 0) { sb.append(&quot;addiu\\t$sp, \\t$sp,\\t&quot;).append(stackSize).append(&quot;\\n&quot;); } // 主函数直接结束运行 if (function.getName().equals(&quot;main&quot;)) { sb.append(&quot;\\tli\\t$v0,\\t10\\n&quot;); sb.append(&quot;\\tsyscall\\n\\n&quot;); } // 非主函数，需要恢复现场 else { // 在返回之前回复寄存器寄存器 int stackOffset = -4; for (RegType regType : function.getRegsNeedSaving()) { sb.append(&quot;\\t&quot;).append(&quot;lw\\t&quot;).append(regType).append(&quot;,\\t&quot;).append(stackOffset).append(&quot;($sp)\\n&quot;); stackOffset -= 4; } // 跳转返回 sb.append(&quot;\\tjr\\t$ra\\n&quot;); } return sb.toString(); } 代码优化总论优化分为两类，一类是分析型优化，这种类型的优化并不会改变 llvm ir 的结构，所以也不会有实际的优化效果，但是它们分析出来的信息，会去指导加工型优化的进行。另一种是加工型优化，这种优化会真正改变 llvm ir &amp; mips 的结构，达到优化的目的。 控制流图构建在构建控制流图之前，我们先进行简单的死代码删除： 该部分会删除所有 ret指令后的代码。 这其实是为了解决在debug时发现的一个严重错误：为了确保在构建控制流图时，不会产生奇怪的后继，从而导致控制流图构建错误、phi指令报错。 在遇到 ret指令后，删除所有指令即可。 123456789101112public static void deadCodeEmit(BasicBlock block) { LinkedList&lt;Instruction&gt; instructions = new LinkedList&lt;&gt;(block.getInstructions()); boolean flag = false; for (Instruction instruction : instructions) { if (flag) { instruction.dropAllOperands(); instruction.eraseFromParent(); } else if (instruction instanceof Ret || instruction instanceof Br) { flag = true; } } } 支配分析 [!IMPORTANT] 在进行很多分析之前，都需要进行支配分析，这是因为支配树会提供很多的支配流信息，尤其是数据是怎样在数据块中流动，哪些数据必然从这个块流入另一个块，可以说，支配信息是对于 CFG 图的一种高度凝练的表达。 在求解支配树的时候，分为两步，第一步首先支配者和被支配者，这是一个不动点问题，利用的公式是 $$temp = {index} \\cup (\\bigcap_{j \\in preds(index)} domer(j) )$$ [!IMPORTANT] 需要一直求解到不发生变化为止。 第二步是计算支配边界，构造支配树，支配树是比原来的支配图更加直观而且“强”的条件，我们在优化中一般也是使用支配树的信息条件。所谓支配边界，就是恰好不被支配的一个块。 需要强调，支配树不仅应用在编译领域，这是一个很常见的图论算法，所以可以在网上找到详实的资料，所以对于算法问题就不赘述。 支配分析基于 CFG图会被用在 LoopInfoAnalyze， mem2reg，所以只要 CFG 发生改变，就会需要重新分析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 计算支配信息 * * @param function 待分析的函数 */ public static void passDominanceInfo(Function function) { // 入口块 BasicBlock entryBlock = function.getHeadBlock(); // 基本块的数目 int blockNum = function.getBasicBlocks().size(); // 每个基本块都有一个 bitSet，用于表示这个块的 domer ArrayList&lt;BitSet&gt; domers = new ArrayList&lt;&gt;(blockNum); ArrayList&lt;BasicBlock&gt; blocks = function.getBasicBlocks(); // 作为 block 的索引 int index = 0; for (BasicBlock block : blocks) { domers.add(new BitSet()); // 入口块的支配者是自己 if (block == entryBlock) { domers.get(index).set(index); } else { domers.get(index).set(0, blockNum); } index++; } // 不动点算法 计算domer boolean changed = true; while (changed) { changed = false; index = 0; // 遍历基本块 for (BasicBlock curBlock : blocks) { // 对于非入口块 if (curBlock != entryBlock) { // temp 初始全置1 BitSet temp = new BitSet(); temp.set(0, blockNum); // 就是下面的公式 // temp &lt;- {index} \\cup (\\BigCap_{j \\in preds(index)} domer(j) ) for (BasicBlock preBlock : curBlock.getPreBlocks()) { int preIndex = blocks.indexOf(preBlock); temp.and(domers.get(preIndex)); } // 自己也是自己的domer temp.set(index); // 若temp更新，则temp 赋给domer if (!temp.equals(domers.get(index))) { domers.get(index).clear(); domers.get(index).or(temp); changed = true; } } index++; } } // 将domer信息存入所有基本块 for (int i = 0; i &lt; blockNum; i++) { BasicBlock curBlock = blocks.get(i); BitSet domerInfo = domers.get(i); // 遍历bitset，找到并记录每一个支配者 for (int domerIndex = domerInfo.nextSetBit(0); domerIndex &gt;= 0; domerIndex = domerInfo.nextSetBit(domerIndex + 1)) { BasicBlock domerBlock = blocks.get(domerIndex); curBlock.getDomers().add(domerBlock); } } // 计算所有基本块的：直接支配者 直接被支配者 for (BasicBlock curBlock : blocks) { // 遍历当前块的支配者 for (BasicBlock maybeIdomerBlock : curBlock.getDomers()) { // 排除自身 if (maybeIdomerBlock != curBlock) { boolean isIdom = true; for (BasicBlock domerBlock : curBlock.getDomers()) { // maybeIdomerBlock支配了domerBlock，domerBlock支配curBlock，表明并不是直接的支配者 if (domerBlock != curBlock &amp;&amp; domerBlock != maybeIdomerBlock &amp;&amp; domerBlock.getDomers().contains(maybeIdomerBlock)) { isIdom = false; break; } } // 是直接支配块，则双方都要互相登记 if (isIdom) { curBlock.setIdomer(maybeIdomerBlock); maybeIdomerBlock.getIdomees().add(curBlock); break; } } } } // calculate dom level passDominanceLevel(entryBlock, 0); } 函数调用分析 [!IMPORTANT] 如果在调用者和被调用者之间构建一条有向边，那么就可以构建一个函数调用图，函数调用关系主要是为了后面的副作用分析，无用函数删除做准备。在实际应用中，一般不会单独作为一个 pass ，这是因为这个用的很多，基本上是随用随做。 因为 SysY并不支持函数声明，所以其实不会出现循环递归或者其他的阴间情况，这无疑对后面是一个好消息。 副作用分析 [!IMPORTANT] 所谓的副作用（SideEffect），其实没有一个明确的概念，大概就是我们不喜欢的作用，就会被叫做副作用。在中端的副作用，指的是某个指令或者函数，会不会对内存或者 IO 造成影响，如果不会，那么就是没有副作用的。 没有副作用的东西很良好，因为他们造成的唯一影响只能通过返回值，所以如果返回值没有用到，那么这个东西就可以去掉了。不仅仅是去掉这么暴力，如果没有副作用，相当于有了一个很“强”的条件保证，我们对于某些优化的进行会变得更加自信，比如说一个函数如果没有副作用，我们就可以直接把他当成一条指令处理，对于 12%i1 = call i32 f(%a1);%i2 = call i32 f(%a1); [!IMPORTANT] 我们可以直接判断 i1 == i2 是很好的东西。 进行副作用分析的时候，需要先构建一个函数调用关系图，这是因为有的函数本身并不会造成副作用，但是他调用的函数就会有副作用，导致调用这个函数也会有副作用。 我们一般认为这几个东西有副作用 store 指令 call 内联函数 call 有副作用的函数 副作用分析会被用在 AggressiveDeadCodeEmit 中。 Mem2Reg在 LLVM生成部分中，我们已经了解了SSA的两种形式：走访存后门的SSA，和真正能提高效率的采取 phi的真SSA 。 在这一步，我们将进行如下两项工作以重构llvm代码： 后门SSA中，繁复 alloca,store,load三件套的彻底铲除优化。 phi指令的插入与变量的重命名。 [!IMPORTANT] 一个基本块的开始需要插入一个变量的 phi 节点的条件，是这个基本块是这个变量某个定义的支配边界。这个操作需要迭代，事实上就只需要建立一个队列，每次取出队首，计算其支配边界，并把新算出的支配边界插入到队列的末尾。 注意，这时的 phi 节点还是空的，即只有左值没有右值。 简单的运算强度削弱即对于 a * 0, 0 / a, a % 1, a / a这一类指令提前完成优化，避免繁复计算 Aggressive Dead Code Emit [!IMPORTANT] 在这一步中我们认为的死代码，就是不会对程序造成影响的代码，我们可以用与“副作用分析”类似的眼光去看，所有的访存指令，return 指令，call 一个有副作用的函数，分支指令，这些东西都是有用的，我们不能删除，那么这些指令使用到的指令，同样也是不能删除的，以此类推，这样求出一个有用指令的闭包，所有不在这个指令闭包内的指令，都是死代码，是可以删除的。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * DFS求解闭包 */ private void findUsefulClosure(Instruction instruction) { if (!usefulInstrClosure.contains(instruction)) { // 记录所有用到的指令 usefulInstrClosure.add(instruction); for (Value operand : instruction.getOperands()) { if (operand instanceof Instruction) { findUsefulClosure((Instruction) operand); } } } } private void deleteDeadInstructions(Function curFunction) { usefulInstrClosure.clear(); for (BasicBlock basicBlock : curFunction.getBasicBlocks()) { for (Instruction instruction : basicBlock.getInstructions()) { if (isUseful(instruction)) { findUsefulClosure(instruction); } } } // 删除不在闭包内的指令 for (BasicBlock basicBlock : curFunction.getBasicBlocks()) { LinkedList&lt;Instruction&gt; newInstructions = new LinkedList&lt;&gt;(); for (Instruction instruction : basicBlock.getInstructions()) { boolean delete = false; if (!usefulInstrClosure.contains(instruction)) { instruction.dropAllOperands(); delete = true; //instruction.eraseFromParent(); } if (!delete) { newInstructions.add(instruction); } } basicBlock.setInstructions(newInstructions); } } 全局变量局部化 [!IMPORTANT] 因为全局变量的访问需要在 llvm 中访存，比较低效，所以考虑对于只被一个函数使用了的全局变量（这就没有意义是全局的了），将其移入成局部变量。 乘除法优化对于处理器来说，执行乘除法的代价要远大于执行其他指令，而执行除法的代价又远大于乘法的代价，所以我们理想的情况是通过算术运算将除常数转化为乘法和移位指令，将乘常数转化为移位和其他指令。 乘法优化乘法可以被优化成加法和移位操作，因为乘法的代价是 4，所以加法和移位操作最多有 3 条，那么考虑“移位-加法-移位”的组合，那么也就是可以拆出两条移位指令，那么可以枚举 32 位内由上述组合可以达到的组合，然后记录下来。在乘法运算的时候，可以按照事先准备的进行操作。 除法优化对于任何处理器，进行除法计算所需要的时间都远远高于乘法和移位运算（当然这两者也不在一个量级上），所以我们有一种想法，就是把除法转换成乘法和移位操作，也就是 $$\\tt{quotient = \\frac{dividend}{divisor} = (dividend \\times multiplier) &gt;&gt; shift}$$ 具体实现则参考了教程所给论文：Division by Invariant Integers using Multiplication。 图着色寄存器分配首先以函数为单位，对其所有基本块进行活跃变量分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 对一个函数以块为单位进行活跃变量分析 * * @return 一个每个 block 都对应的一个 info 的 map */ public static HashMap&lt;MipsBlock, BlockLiveVarInfo&gt; liveAnalysis(MipsFunction func) { HashMap&lt;MipsBlock, BlockLiveVarInfo&gt; liveInfoMap = new HashMap&lt;&gt;(); // 开始遍历每一个 block for (MipsBlock block : func.getMipsBlocks()) { BlockLiveVarInfo blockLiveInfo = new BlockLiveVarInfo(); liveInfoMap.put(block, blockLiveInfo); // 开始遍历 block 中的指令, 跟定义中的一模一样 for (MipsInstruction instruction : block.getInstructions()) { // 还没定义就被使用，这里是正确的 instruction.getUseRegs().stream() .filter(MipsOperand::needsColor) .filter(use -&gt; !blockLiveInfo.liveDef.contains(use)) .forEach(blockLiveInfo.liveUse::add); // 还没使用就被定义，这里应该是错误的，因为定义就是定义，就是杀死，不会因为使用而不杀死 instruction.getDefRegs().stream() .filter(MipsOperand::needsColor) .forEach(blockLiveInfo.liveDef::add); } // 这里应该是没有问题的 blockLiveInfo.liveIn.addAll(blockLiveInfo.liveUse); } // 不动点 boolean changed = true; while (changed) { changed = false; // 开始遍历 func 中的 block for (MipsBlock block : func.getMipsBlocks()) { BlockLiveVarInfo blockLiveInfo = liveInfoMap.get(block); HashSet&lt;MipsOperand&gt; newLiveOut = new HashSet&lt;&gt;(); // 下面是加入两个后继,这里是正确的，LiveOut 就是 LiveIn 的并集 if (block.getTrueSucBlock() != null) { BlockLiveVarInfo sucBlockInfo = liveInfoMap.get(block.getTrueSucBlock()); newLiveOut.addAll(sucBlockInfo.liveIn); } if (block.getFalseSucBlock() != null) { BlockLiveVarInfo sucBlockInfo = liveInfoMap.get(block.getFalseSucBlock()); newLiveOut.addAll(sucBlockInfo.liveIn); } // 第一次的时候应该是没有办法 equal 的，这是因为之前 liveOut 并没有被赋值 if (!newLiveOut.equals(blockLiveInfo.liveOut)) { changed = true; blockLiveInfo.liveOut = newLiveOut; // 这里模拟的是 LiveUse blockLiveInfo.liveIn = new HashSet&lt;&gt;(blockLiveInfo.liveUse); // liveIn = liveUse + liveOut - liveDef blockLiveInfo.liveOut.stream() .filter(objOperand -&gt; !blockLiveInfo.liveDef.contains(objOperand)) .forEach(blockLiveInfo.liveIn::add); } } } return liveInfoMap; } 基于活跃变量分析的结果，我们就可以开始图着色算法了： 主要流程如下，遍历所有函数，对于每个函数，进行活跃变量分析直至不再变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 进行寄存器分配 * 入口方法 */ public void buildRegs() { // 遍历所有函数 for (MipsFunction function : mipsModule.getFunctions()) { if (function.isLibFunc()) { continue; } curFunction = function; // 对于每个函数，进行活跃变量分析直至不再变化 boolean finished = false; while (!finished) { initStatus(); buildConflictGraph(); buildWorklist(); do { if (!simplifyList.isEmpty()) { doSimplify(); } if (!mergableMoves.isEmpty()) { coalesce(); } if (!freezeList.isEmpty()) { doFreeze(); } if (!spillList.isEmpty()) { doSelectSpill(); } } while (!(simplifyList.isEmpty() &amp;&amp; mergableMoves.isEmpty() &amp;&amp; freezeList.isEmpty() &amp;&amp; spillList.isEmpty())); assignColors(function); // 实际溢出的节点 if (spilledNodes.isEmpty()) { finished = true; } // 存在实际溢出的点 else { try { rewriteProgram(function); } catch (Exception e) { System.out.println(&quot;[RewriteProgramException] &quot; + e + &quot;, function: &quot; + function.getName()); } } } } // 因为在 color 的时候，会把 isAllocated 设置成 true，这个函数的功能就是设置成 false // 应该是为了避免物理寄存器在判定 equals 时的错误 resetRealRegState(); for (MipsFunction function1 : mipsModule.getFunctions()) { if (function1.isLibFunc()) { continue; } function1.rebuildStack(); } } 构造冲突图(build)本阶段的主要任务是通过数据流分析方法，计算在每条指令执行时同时活跃的临时变量，该集合的每一对临时变量两两形成一条边加入冲突图中， 构造阶段的主要工作是进行数据流分析，分为两个阶段：基本块的数据流分析，指令间的数据流分析，得到冲突图，指令冲突的条件是在变量定义处所有出口活跃的变量和定义的变量是互相冲突的，以及同一条指令的出口变量互相之间是冲突的。 简化（simplify）进行启发式图着色，删除度数小于K（通用寄存器个数）的节点，简化冲突图，产生更多图着色机会。 具体的做法是对于一个节点m，如果它的度数小于K，那么将它从冲突图当中删除，并且将其压入栈中，以便进行后续的着色。 这样进行启发式删除之后，都会减少其他结点的度数，从而产生更多的简化的机会，并且也为之后的合并提供更多机会，这要求在这个阶段不会简化非冻结指令。 合并（coalesce）进行保守的合并，减少最终代码的move指令。 对于move指令（例如 move $2, $3），源操作数和目的操作数实际上相同，这种情况下可以将两个节点合并，减少一条move指令的代价，但是，合并两个结点之后，两个节点的活跃范围会增加，其邻接结点的集合实际上是原来两个集合的并集，这种情况下可能会导致一些能够着色的节点变为被溢出的结点，这样就得不偿失了，因此我们给出的一种策略是在合并的时候进行判断，保证合并之后高度数（度数&gt;=K）的结点不会增加。通过简化之后，冲突图很多节点的度数已经降低，所以这个时候合并的机会可能多于原有的冲突图。 合并的效果通常决定了整个图着色算法的质量，另外由于在进行指令选择之前需要消PHI，会在这个时候产生很多冗余的move指令，通过图着色的时候进行合并能够极大的减少冗余的move指令，这对程序性能的提升非常大。 冻结（freeze）在进行简化和合并之后，有一些变量无法进行合并，并且可以进行简化，这个时候需要将其标记为传送冻结的结点，重新开始简化阶段。 溢出（spill）简化和合并完成之后，冲突图中只剩下高度数（度数&gt;=K）的节点，这个时候我们需要在图中选择一个高度数的结点，将它存入内存当中，然后将它压入栈中。这个时候其他结点的度数降低，可以继续进行简化。 选择（select）对虚拟寄存器指派颜色，即分配真实的寄存器。具体做法是以一个空图开始，从栈中弹出一个节点，加入到冲突图中，并且为他指派一种颜色，该节点必须是可着色的，可着色的条件是其邻接结点使用的颜色小于真实的寄存器数K，对于简化阶段入栈的变量显然一定能够着色，对于溢出阶段入栈的变量，通过合并之后，邻接点中有一些变量的颜色相同，最后邻接点的颜色小于K种，能够进行着色，可以将其加入冲突图中，否则将其加入无法进行着色的集合中。 重新开始(restart)如果无法进行着色的集合不为空，那么则需要改写程序，为这些变量在内存当中分配空间，并且在每次使用需要将其从内存当中取出，每次修改需要存进内存当中，这种情况下，溢出的临时变量会转变为几个活跃范围很小的新的临时变量，这个时候需要重新进行活跃分析、寄存器分配，直到没有溢出和简化为止（通常只需要迭代一两次）。 窥孔优化对于相邻的部分少量指令进行优化。 处理无意义的加减法 旧指令 新指令 add/sub r0, r0, 0 删除 add/sub r0, r1, 0 move r0, r1 处理无意义的mov 旧指令 新指令 move r0, r0 删除 处理对同一个dst的连续mov 旧指令 新指令 move r0, r1 move r0, r2 … move r0, rk move r0, rk 处理向相邻块或者无意义块的跳转 旧指令 新指令 j next_block Move r0, rk 处理向同一个地址的存储+加载的store+load对 旧指令 新指令 store a, memory load b, sameMemory move b, a","link":"/2025/08/14/compiler/"}],"tags":[{"name":"CO","slug":"CO","link":"/tags/CO/"},{"name":"OO","slug":"OO","link":"/tags/OO/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"compiler","slug":"compiler","link":"/tags/compiler/"}],"categories":[{"name":"大二上课上","slug":"大二上课上","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%AF%BE%E4%B8%8A/"},{"name":"大二下课上","slug":"大二下课上","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E4%B8%8A/"},{"name":"CO理论","slug":"大二上课上/CO理论","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%AF%BE%E4%B8%8A/CO%E7%90%86%E8%AE%BA/"},{"name":"CO实验","slug":"大二上课上/CO实验","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%AF%BE%E4%B8%8A/CO%E5%AE%9E%E9%AA%8C/"},{"name":"OO","slug":"大二下课上/OO","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E4%B8%8A/OO/"},{"name":"OS","slug":"大二下课上/OS","link":"/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E4%B8%8A/OS/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"大三上课上","slug":"大三上课上","link":"/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E4%B8%8A/"},{"name":"database","slug":"大三上课上/database","link":"/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E4%B8%8A/database/"},{"name":"compiler","slug":"大三上课上/compiler","link":"/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E4%B8%8A/compiler/"}],"pages":[{"title":"About Me","text":"/* 常用颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 处理警告框 document.addEventListener('DOMContentLoaded', function() { const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; } } }); }); 👋 你好，我是 RooKie_Z🎓 个人简介我是一名北京航空航天大学的计算机科学与技术专业的本科生，对人工智能、软件工程、编译器技术等方向有着浓厚兴趣。在学习过程中，我注重理论与实践结合，参与过多项课程项目与科研实习，积累了扎实的编程能力和项目管理经验。 🚀 技术栈 编程语言: C++, Java, Python, JavaScript, Go 开发工具: IntelliJ IDEA, CLion, PyCharm, GoLand, VS Code 框架与技术: Django, Qt, Vue.js, Pytorch, Hexo 数据库: MySQL 操作系统: Linux, macOS, Windows 📚 学习与实践 面向对象设计与构造 (OO): 担任课程助教与高阶助教，负责命题与指导学生项目实现。 科研实习: 参与大语言模型越狱攻击研究，积累了人工智能安全方向的实验与分析经验。 软件工程项目: 担任“科研文献助手”项目经理及AI功能负责人，带领团队完成从需求分析到功能实现的全流程，并与导师合作推进项目迭代。 🏆 荣誉与奖项 多次获得校级奖学金与学科竞赛奖项 全国大学生英语竞赛北京市二等奖 全国大学生数学竞赛北京市一等奖 美国大学生数学建模竞赛 Meritorious Winner 互联网+北京赛区三等奖 🌟 兴趣爱好 算法与编程竞赛 开源项目贡献 技术写作与分享 阅读与探索新技术 💌 联系方式 GitHub: RooKie_Z 邮箱：RooKie_Z 博客: RooKie_Z的小窝 💡 座右铭 “Ever tried, Ever failed, No matter. Try again, Fail again, Fail better.” —— 塞缪尔·贝克特 感谢访问我的博客！如果你对我的项目或技术文章有任何问题或建议，欢迎随时交流。","link":"/about.html"},{"title":"MathJax 数学公式测试","text":"🧮 MathJax 数学公式测试页面1. 行内公式测试这是一个行内公式：$E = mc^2$，爱因斯坦的质能方程。 另一个行内公式：$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$，高斯积分。 2. 块级公式测试二次方程求根公式： $$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ 欧拉公式： $$e^{i\\pi} + 1 = 0$$ 傅里叶变换： $$F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$$ 3. 复杂公式测试矩阵乘法： $$\\begin{pmatrix}a &amp; b \\c &amp; d\\end{pmatrix}\\begin{pmatrix}e &amp; f \\g &amp; h\\end{pmatrix} =\\begin{pmatrix}ae+bg &amp; af+bh \\ce+dg &amp; cf+dh\\end{pmatrix}$$ 积分方程： $$\\int_{0}^{1} \\frac{x^n}{1+x} dx = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{n+k+1}$$ 极限公式： $$\\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n = e$$ 4. 中文混合公式测试当 $x \\to 0$ 时，$\\sin x \\approx x$，这是正弦函数在原点附近的线性近似。 对于任意实数 $a$ 和 $b$，都有：$(a+b)^2 = a^2 + 2ab + b^2$ 5. 特殊符号测试希腊字母： $\\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\zeta, \\eta, \\theta$ 数学符号： $\\sum, \\prod, \\int, \\oint, \\nabla, \\partial, \\infty$ 关系符号： $\\leq, \\geq, \\neq, \\approx, \\equiv, \\propto$ 如果上面的数学公式都能正确显示和居中，说明 MathJax 配置成功！","link":"/math-test.html"},{"title":"功能测试页面","text":"🧪 功能测试页面 /* 内联样式测试 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #DC143C !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-emphasis { color: #007bff; font-weight: bold; } .text-warning { color: #ffc107; font-weight: bold; } .text-success { color: #28a745; font-weight: bold; } .text-danger { color: #7835dc; font-weight: bold; } /* 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } blockquote[data-callout=\"important\"] { border-left-color: #7835dc; background:rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"caution\"] { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"note\"] { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"success\"] { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } blockquote[data-callout=\"warning\"] { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } // 内联JavaScript测试 document.addEventListener('DOMContentLoaded', function() { console.log('内联JavaScript加载成功！'); // 处理警告框 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); blockquote.setAttribute('data-callout', calloutType); // 移除标记文本 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; console.log('处理警告框:', calloutType); } } }); }); 1. 颜色类测试&lt;span class=&quot;text-cadetblue&quot;&gt;这是CadetBlue颜色的文本 &lt;span class=&quot;text-blue&quot;&gt;这是蓝色文本 &lt;span class=&quot;text-green&quot;&gt;这是绿色文本 &lt;span class=&quot;text-red&quot;&gt;这是红色文本 &lt;span class=&quot;text-orange&quot;&gt;这是橙色文本 &lt;span class=&quot;text-purple&quot;&gt;这是紫色文本 2. 警告框测试 [!IMPORTANT]这是一个重要的警告框测试 [!CAUTION]这是一个注意提示框测试 [!NOTE]这是一个提示信息框测试 [!SUCCESS]这是一个成功信息框测试 [!WARNING]这是一个警告信息框测试 3. 强调文本测试&lt;span class=&quot;text-emphasis&quot;&gt;这是强调文本 &lt;span class=&quot;text-warning&quot;&gt;这是警告文本 &lt;span class=&quot;text-success&quot;&gt;这是成功文本 &lt;span class=&quot;text-danger&quot;&gt;这是错误文本 如果上面的样式都正常显示，说明内联样式和JavaScript工作正常！","link":"/test.html"},{"title":"","text":"","link":"/theme-test.html"},{"title":"","text":"/* 自定义颜色类 */ .text-cadetblue { color: CadetBlue !important; } .text-blue { color: #007bff !important; } .text-green { color: #28a745 !important; } .text-red { color: #7835dc !important; } .text-orange { color: #fd7e14 !important; } .text-purple { color: #6f42c1 !important; } .text-pink { color: #e83e8c !important; } .text-gray { color: #6c757d !important; } .text-dark { color: #343a40 !important; } /* 强调文本 */ .text-emphasis { color: #007bff; font-weight: bold; } /* 警告文本 */ .text-warning { color: #ffc107; font-weight: bold; } /* 成功文本 */ .text-success { color: #28a745; font-weight: bold; } /* 错误文本 */ .text-danger { color: #7835dc; font-weight: bold; } /* 文章摘要样式 */ .article-excerpt { background: #f8f9fa; border-left: 4px solid #007bff; padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0; } .article-excerpt p { margin: 0; color: #6c757d; font-style: italic; } /* 封面图片样式 */ .article-cover { width: 100%; max-height: 300px; object-fit: cover; border-radius: 8px; margin-bottom: 20px; } /* 阅读更多按钮样式 */ .read-more { display: inline-block; background: #007bff; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; margin-top: 10px; transition: background-color 0.3s; } .read-more:hover { background: #0056b3; color: white; text-decoration: none; } /* 文章底部标签和分类样式 */ .article-tags, .article-categories { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff; } .article-tags h4, .article-categories h4 { margin: 0 0 10px 0; color: #495057; font-size: 16px; font-weight: 600; } .article-tags .tag, .article-categories .category { display: inline-block; background: #007bff; color: white; padding: 4px 12px; margin: 2px 4px 2px 0; border-radius: 20px; font-size: 12px; text-decoration: none; transition: all 0.3s ease; } .article-tags .tag:hover, .article-categories .category:hover { background: #0056b3; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); } .article-categories .category { background: #28a745; } .article-categories .category:hover { background: #1e7e34; } /* 文章元信息样式 */ .article-meta { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #6c757d; } .article-meta .meta-item { display: flex; align-items: center; gap: 5px; } .article-meta .meta-item i { color: #007bff; width: 16px; } /* Giscus评论系统样式 */ #giscus-comments { margin-top: 40px; padding: 20px; background: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #eaecef; } #giscus-comments h3 { margin: 0 0 20px 0; color: #24292e; font-size: 20px; font-weight: 600; text-align: center; } /* 评论加载状态 */ .giscus-loading { text-align: center; padding: 40px; color: #6a737d; } .giscus-loading::before { content: \"🔄 正在加载评论...\"; font-size: 16px; } /* 评论区域响应式设计 */ @media (max-width: 768px) { #giscus-comments { margin: 20px 10px; padding: 15px; } #giscus-comments h3 { font-size: 18px; } } /* Callout 警告框样式 */ blockquote { position: relative; margin: 20px 0; padding: 16px 20px; border-left: 4px solid #007bff; background: #f8f9fa; border-radius: 0 6px 6px 0; font-style: normal; } /* IMPORTANT 警告框 */ blockquote[data-callout=\"important\"], blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\")) { border-left-color: #7835dc; background: rgb(242, 241, 251); border-left-width: 6px; } blockquote[data-callout=\"important\"]::before, blockquote:has(> p:first-child:contains(\"[!IMPORTANT]\"))::before { content: \"💬 重要\"; display: block; font-weight: bold; color: #7835dc; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* CAUTION 警告框 */ blockquote[data-callout=\"caution\"], blockquote:has(> p:first-child:contains(\"[!CAUTION]\")) { border-left-color: #ffc107; background: #fffbf0; border-left-width: 6px; } blockquote[data-callout=\"caution\"]::before, blockquote:has(> p:first-child:contains(\"[!CAUTION]\"))::before { content: \"⚠️ 注意\"; display: block; font-weight: bold; color: #b8860b; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* NOTE 提示框 */ blockquote[data-callout=\"note\"], blockquote:has(> p:first-child:contains(\"[!NOTE]\")) { border-left-color: #17a2b8; background: #f0f9ff; border-left-width: 6px; } blockquote[data-callout=\"note\"]::before, blockquote:has(> p:first-child:contains(\"[!NOTE]\"))::before { content: \"ℹ️ 提示\"; display: block; font-weight: bold; color: #17a2b8; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* SUCCESS 成功框 */ blockquote[data-callout=\"success\"], blockquote:has(> p:first-child:contains(\"[!SUCCESS]\")) { border-left-color: #28a745; background: #f0fff4; border-left-width: 6px; } blockquote[data-callout=\"success\"]::before, blockquote:has(> p:first-child:contains(\"[!SUCCESS]\"))::before { content: \"✅ 成功\"; display: block; font-weight: bold; color: #28a745; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* WARNING 警告框 */ blockquote[data-callout=\"warning\"], blockquote:has(> p:first-child:contains(\"[!WARNING]\")) { border-left-color: #fd7e14; background: #fff8f0; border-left-width: 6px; } blockquote[data-callout=\"warning\"]::before, blockquote:has(> p:first-child:contains(\"[!WARNING]\"))::before { content: \"🚨 警告\"; display: block; font-weight: bold; color: #fd7e14; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; } /* 移除第一个段落的 [!TYPE] 标记 */ blockquote p:first-child { margin-top: 0; } /* 响应式设计 */ @media (max-width: 768px) { blockquote { margin: 15px 10px; padding: 12px 16px; } blockquote::before { font-size: 12px; } } /* MathJax 样式优化 */ .MathJax_Display { text-align: center !important; margin: 1em auto !important; } .MathJax { outline: none; } /* 行内公式样式 */ .MathJax_Display .MathJax { text-align: center !important; } /* 块级公式容器 */ .MathJax_Display { display: block !important; text-align: center !important; margin: 1em auto !important; } /* 确保公式不被截断 */ .MathJax_Display .MathJax { overflow-x: auto; overflow-y: hidden; } /* 响应式设计 */ @media (max-width: 768px) { .MathJax_Display { margin: 0.5em auto !important; } } mjx-container[display=\"true\"] { display: block !important; text-align: center !important; margin: 1em auto !important; } mjx-container[display=\"false\"] { display: inline-block !important; } /* 列表页/首页摘要中的警告框覆盖 */ article.media .media-content .content blockquote, .article-excerpt .content blockquote { background: rgba(2, 215, 242, 0.15) !important; /* 蓝色半透明背景，符合 cyberpunk */ border: .5px solid #02d7f2 !important; border-left: 5px solid #02d7f2 !important; } /* 文字颜色提亮，避免被通用文字色覆盖 */ article.media .media-content .content blockquote, article.media .media-content .content blockquote p, article.media .media-content .content blockquote * , .article-excerpt .content blockquote, .article-excerpt .content blockquote p, .article-excerpt .content blockquote * { color: #ffffff !important; font-weight: 500 !important; text-shadow: 0 0 2px rgba(0,0,0,.6) !important; } /* 分类型：IMPORTANT / CAUTION / NOTE */ article.media .media-content .content blockquote[data-callout=\"important\"], .article-excerpt .content blockquote[data-callout=\"important\"] { background: rgba(149,97,210,.22) !important; /* 紫色半透明 */ border-left-color: #02d7f2 !important; } article.media .media-content .content blockquote[data-callout=\"caution\"], .article-excerpt .content blockquote[data-callout=\"caution\"] { background: rgba(255,142,60,.22) !important; /* 橙色半透明 */ border-left-color: #ff8e3c !important; } article.media .media-content .content blockquote[data-callout=\"note\"], .article-excerpt .content blockquote[data-callout=\"note\"] { background: rgba(2,215,242,.20) !important; /* 蓝色半透明 */ border-left-color: #02d7f2 !important; } /* 标题行（::before）提亮 */ article.media .media-content .content blockquote[data-callout]::before, .article-excerpt .content blockquote[data-callout]::before { color: #02d7f2 !important; text-shadow: 0 0 4px rgba(2,215,242,.6) !important; }","link":"/css/custom.css"},{"title":"","text":"/* FontAwesome 6.5.2 CDN */ @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css'); /* 确保 FontAwesome 6.5.2 优先级最高 */ .fab.fa-x::before { content: \"\\f1e3\" !important; } .fab.fa-x-twitter::before { content: \"\\f1e3\" !important; } /* 覆盖主题默认的 FontAwesome 版本 */ .fab.fa-twitter::before { content: \"\\f099\" !important; }","link":"/css/fontawesome-6.5.2.css"},{"title":"","text":"// Callout 警告框增强器 (function() { function enhanceCallouts() { // 查找所有 blockquote 元素 const blockquotes = document.querySelectorAll('blockquote'); blockquotes.forEach(function(blockquote) { // 检查第一个段落是否包含 callout 标记 const firstParagraph = blockquote.querySelector('p:first-child'); if (firstParagraph) { const text = firstParagraph.textContent; // 匹配 [!TYPE] 格式 const calloutMatch = text.match(/\\[!(IMPORTANT|CAUTION|NOTE|SUCCESS|WARNING)\\]/i); if (calloutMatch) { const calloutType = calloutMatch[1].toLowerCase(); // 添加 data-callout 属性 blockquote.setAttribute('data-callout', calloutType); // 移除第一个段落中的 [!TYPE] 标记 const cleanText = text.replace(/\\[![^\\]]+\\]\\s*/, ''); firstParagraph.textContent = cleanText; // 添加图标和标题 const calloutHeader = document.createElement('div'); calloutHeader.className = 'callout-header'; calloutHeader.style.cssText = ` display: block; font-weight: bold; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; `; // 根据类型设置样式 const calloutConfig = { important: { icon: '⚠️', text: '重要', color: '#7835dc' }, caution: { icon: '⚠️', text: '注意', color: '#b8860b' }, note: { icon: 'ℹ️', text: '提示', color: '#17a2b8' }, success: { icon: '✅', text: '成功', color: '#28a745' }, warning: { icon: '🚨', text: '警告', color: '#fd7e14' } }; const config = calloutConfig[calloutType]; if (config) { calloutHeader.innerHTML = `${config.icon} ${config.text}`; calloutHeader.style.color = config.color; // 在第一个段落之前插入标题 firstParagraph.parentNode.insertBefore(calloutHeader, firstParagraph); } } } }); } // 页面加载完成后执行 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', enhanceCallouts); } else { enhanceCallouts(); } // 如果页面使用了PJAX，需要重新执行 if (window.pjax) { document.addEventListener('pjax:end', enhanceCallouts); } // 监听动态内容变化 const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if (mutation.type === 'childList' && mutation.addedNodes.length > 0) { enhanceCallouts(); } }); }); // 开始观察 observer.observe(document.body, { childList: true, subtree: true }); })();","link":"/js/callout-enhancer.js"},{"title":"","text":"// Giscus评论系统加载脚本 (function() { // 等待页面完全加载 function initGiscus() { // 检查是否在文章页面 const isArticlePage = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || window.location.pathname.includes('/2025/'); if (isArticlePage) { console.log('检测到文章页面，正在加载Giscus评论系统...'); // 检查是否已经加载过评论 if (document.getElementById('giscus-comments')) { console.log('评论系统已存在，跳过重复加载'); return; } // 创建Giscus容器 const giscusContainer = document.createElement('div'); giscusContainer.id = 'giscus-comments'; giscusContainer.style.marginTop = '40px'; giscusContainer.style.padding = '20px'; giscusContainer.style.borderTop = '1px solid #eaecef'; giscusContainer.style.background = '#ffffff'; giscusContainer.style.borderRadius = '8px'; giscusContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)'; // 添加加载状态 giscusContainer.innerHTML = ` 💬 评论 🔄 正在加载评论... `; // 查找文章内容区域并插入评论框 const articleContent = document.querySelector('.article') || document.querySelector('.content') || document.querySelector('.post') || document.querySelector('.column-main') || document.querySelector('main') || document.querySelector('article'); if (articleContent) { articleContent.appendChild(giscusContainer); // 延迟加载Giscus脚本，确保页面完全渲染 setTimeout(function() { try { // 加载Giscus脚本 const script = document.createElement('script'); script.src = 'https://giscus.app/client.js'; script.setAttribute('data-repo', 'rookie-zgy1513/rookie-zgy1513.github.io'); script.setAttribute('data-repo-id', 'R_kgDOKRlxNA'); script.setAttribute('data-category', 'General'); script.setAttribute('data-category-id', 'DIC_kwDOKRlxNM4CuKH8'); script.setAttribute('data-mapping', 'pathname'); script.setAttribute('data-strict', '0'); script.setAttribute('data-reactions-enabled', '1'); script.setAttribute('data-emit-metadata', '0'); script.setAttribute('data-input-position', 'bottom'); script.setAttribute('data-theme', 'preferred_color_scheme'); script.setAttribute('data-lang', 'zh-CN'); script.crossOrigin = 'anonymous'; script.async = true; // 脚本加载成功后的处理 script.onload = function() { console.log('Giscus脚本加载成功'); // 移除加载状态 const loadingElement = giscusContainer.querySelector('.giscus-loading'); if (loadingElement) { loadingElement.remove(); } }; // 脚本加载失败的处理 script.onerror = function() { console.error('Giscus脚本加载失败'); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败，请刷新页面重试 `; }; giscusContainer.appendChild(script); } catch (error) { console.error('加载Giscus时发生错误:', error); giscusContainer.innerHTML = ` 💬 评论 ❌ 评论系统加载失败: ${error.message} `; } }, 1500); // 延迟1.5秒加载 } else { console.warn('未找到文章内容区域，无法加载评论系统'); } } else { console.log('非文章页面，跳过评论系统加载'); } } // 多重检查确保页面加载完成 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGiscus); } else { // 如果DOM已经加载完成，等待一小段时间再执行 setTimeout(initGiscus, 100); } // 额外检查，确保在Icarus主题完全加载后执行 window.addEventListener('load', function() { setTimeout(initGiscus, 500); }); // 如果页面使用了PJAX，需要重新初始化 if (window.pjax) { document.addEventListener('pjax:end', function() { setTimeout(initGiscus, 300); }); } })();","link":"/js/giscus.js"}]}